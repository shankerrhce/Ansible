`


`

## Module 01:

## Privacy

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objective

- What is Privacy?
- Obstruction of Privacy
- Panopticon
- Cypherpunks and Crypto

Anarchists &

- Cypherpunks Manifesto


### <Content Slide>


## Obstruction of Privacy as Means of Oppression

- 1917 - during WW1 the DOJ creates a special "N**** Subversion section devoted to
    spying on Black Americans
- 1942 - during WWII, the FBI gathers info on enemy aliens leading to the internment of
    110,000 Japanese Americans
- 1956 - The FBI begins COINTELPRO to disrupt and discredit black civil rights groups
    leading to the assassination or imprisonment of key leaders
- 1961 - The FBI targets 12 leaders of the Puerto Rican independence movement for
    surveillance
- 1973 - After years of surveilling the American Indian Movement, the FBI sends 200
    heavily armed agents to stop the protest at Wounded Knee.
- 1985 - of the 33,120 pages of information on 600 Muslim entities in the U.S. by FBI's
    Operation Vulgar, there have been no convictions.


###### Michel Foucault's Panopticon

The Panopticon is constructed such that "the prisoner is seen without ever seeing and
that the guards see everything without ever being seen." As a result of constantly being
watched, prisoners "change their own behavior-their paranoia becomes as effective a
tool of control as actual surveillance. They become silent, docile, alienated."

```
Quotes from Assia Bantu's The Feeling of Being Watches
```

###### Cypherpunks and Crypto Anarchists

- **Cypherpunks andCrypto-anarchists** :
    - libertarian groups concerned with privacy, and advocated cryptography as an
       important tool
- " **_Privacy_** is the power to selectivelyreveal oneself to the world.”
- “ **_Privacy_** in an open societyrequires anonymous transaction systems."



###### Cypherpunks and Crypto Anarchists

- "Privacy is necessary for an open society in the electronic age. Privacy
is not secrecy. A private matter is something one doesn't want the whole
world to know, but a secret matter is something one doesn't want
anybody to know. Privacy is the power to selectivelyreveal oneself to
the world."
_- A Cypherpunk Manifesto (Eric Hughes, 90s)_


### Summary

- Privacy
- Obstruction of Privacy as a

mean of Oppression

- Panopticon
- Cypherpunks and Crypto

Anarchists &

- Cryptopunks Manifesto



`


`

## Module 01:

## Evolution of Money

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```


###### Evolution of Money

- High Level Overview:
    - Barter –value is a question
    - Cash & Credit –precise value
    - Credit Cards –it was not secure 15 years ago using online
    - Interest in Intermediaries
    - First Virtual –exchanges through emails, no security protocols in 1990s
    - SET –competing standard developed by VISA & MasterCard with Netscape, IBM,
       Microsoft, Verisign, and RSA
    - CyberCash implemented SET and they had digital cash product CyberCoin.
       Company failed due to Y2K issue and were double billing customers. Company
       went bankrupt.


###### Evolution of Money (continued)

- SET did not work due to digital certificates needed by the system for each
    customer. Certificate is a way for cryptographic identity, public key with real life
    identity from Verisign.
- PayPal took over SET software and built on it.
- In mid 90s, World Wide Web Consortium worked on to enhance http to https with
    use cases.
- In 2015, W3C standardized the https protocol.
- Credit Card needs approval and issuing bank can track all your spending
- Cash has better anonymity and can happen during offline without any approval


###### Evolution of Money (continued)

- In 1983, David Shaum came up with an idea of applying cryptography to actual
    cash
- In 1988, Shaum in collaboration with two other cryptographers Fiat and Naor
    proposed offline electronic cash; but not able to resolve double spend. Later
    Shaum started DigiCash.
- All of these ideas ultimately peg the value of digital cash to the dollar or a
    commodity. If the dollar’s value goes up or down, the value of your digital money
    holdings will change along with it
- Bitcoin was the first digital / virtual currency to resolve all issues of Cryptocurrency.



`


`

## Module 01:

## Evolution of Digital Money

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Baseline of Digital

Transactions

- David Chaum – DigiCash
- Adam Back – HashCash
- Wei Dai – B-Money
- Nick Sabo - BitGold


### Base Timeline of Digital-Transactions

- ~1990 –Start of the movement from cash to digital
- 1991 - DigiCash –David Chaum
- 1992: Start of the Cypherpunks. Publication of "ACypherpunk's Manifesto”.
- 1997: HashCash –Adam Back
- 1998: B-Money –Wei Dai
- 2005: BitGold –Nick Szabo


###### David Chaum - DigiCash

- Originator: David Chaum
- 1982: paper "Blind Signatures for
    Untraceable Payments" –anonymous or
    pseudonymous
- Founds DigiCash in 1990
- DigiCash goes bankrupt in 1998, bought
    out in 2002
- DigiCash focuses on making transactions
    anonymous.
- The consideration was that having digital
    payments would lead to undesirable
    ability to have insight into people's
    spendings and thus private life.


### Early Attempts at Cryptocurrency: DigiCash

- DigiCash: "Blind signatures" public key
    cryptography
- David Chaum's company
- Allowed users to sign off on transactions
    without revealing anything abouttheir
    identity
- Failed due to centralization


### Adam Back - HashCash

- Originator: Adam Back
- 1997: creation of HashCash, "A partial
    hash collision based postage scheme”
- Spam prevention system by making a
    sender do easily verifiable computations
    (hashing)
- Paper explicitly referenced possible
    outlawing of DigiCash


### Early Attempts at Cryptocurrency: HashCash

- HashCash: Coins are minted by expending
    resources instead of by a central bank
- Solve puzzle using a cryptographic hash
    function
- Originally designed as a mechanism to
    limit email spam


### Wei Dai – B-Money

- Originator: Wei Dai
- 1998: creation of B-Money
- B-Money introduces
    - Public Key pseudonyms
    - Creation of Money using HashCash
    - Two possible ways of keeping Ledger
       - All participants check (POW)
       - Servers put up collateral ((D)POS)
- Missing: A way to control Money Creation

```
Proposes a few ways that are still Centralized
```

### Early Attempts at Cryptocurrency: B-Money

B-Money: Introduced two protocols

- Practical way to enforce contractual
    agreements between anonymous actors
- Protocol in which every participant
    maintains an individual database of how
    much money belongs to each user


### Nick Szabo - BitGold

- Originator: Nick Szabo
- 1998: inception of BitGold
- introduces
    - Timestamping
    - Creation of Money using HashCash
- Missing: incentives to keep nodes honest
- Missing: A way to keep tokens fungible
    (no agreed way to set difficulty. One token
    might be made with significantly more
    difficulty than the other)


### Who, What & When

- Who sends? →David Chaum, eventually DigiCash, starting 1981
- What do I send? →Wei Dai, B-Money, but also Hal Finney RPOW

and Nick Szabo Bit Gold. Proposed in the period 1997 (HashCash) –2005.

- When do I send? →Satoshi Nakamoto, Bitcoin. Solves the waycoin supply cannot be
inflated as well as POW being reused by adding blocks and roles in the network.


### Summary

- Baseline of Digital

Transactions

- David Chaum – DigiCash
- Adam Back – HashCash
- Wei Dai – B-Money
- Nick Sabo - BitGold


### References



`


`

## Module 01:

## Cryptocurrency

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Whether Central Bank is

needed?

- Satoshi Nakamoto
- Cryptocurrency



### Whether Central Bank is needed?



###### Satoshi Nakamoto

- **Satoshi Nakamoto** is the founder of Bitcoin and creator of the Original
    Bitcoin Client.
       - He has been working on the Bitcoin project since 2007.
       - His involvement in the Bitcoin project had tapered and by late 2010 it has ended.
       - The most recent messages reportedly indicate that Satoshi is "gone for good“.
- **Satoshi Nakamoto** is the name used by the unknown person or people
    who developed bitcoin, authored the bitcoin white paper (2008), and
    created and deployed bitcoin's original reference implementation. As
    part of the implementation, they also devised the first blockchain
    database. In the process, they were the first to solve the double
    spending problem for digital currency using a peer-to-peer network.
    They were active in the development of bitcoin up until December 2010.
- Perhaps he chose the name Satoshi because it means "wisdom" or
    "reason" and Nakamoto means "Central source".


###### Cryptocurrency

- A cryptocurrency is a digital asset designed to work as a

medium of exchange that

- uses strong cryptography to secure financial transactions,
- control the creation of additional units, and
- verify the transfer of assets.
- Cryptocurrencies are a kind of alternative currency and digital

currency.

- Cryptocurrencies use decentralized control as opposed to

centralized digital currency and central banking systems.


### Summary

- Whether Central Bank is

needed?

- Satoshi Nakamoto
- Cryptocurrency



`


## ` Module 01:

## Evolution of Digital Ledger

## Technology (DLT)

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- History of Digital Ledger
- Timestamping of

Documents

- Proof of Work (POW)


### History of Digital Ledger

- High Level Overview:
    - In 1475, Fr. Luca Pacioli published the work on double entry system of booking
       known as ledger. He is referred to as "The Father of Accounting and Bookkeeping“.
    - In 1991, Haber and Stornetta proposed a method for secure timestamping of
       digital documents.
    - Goal of timestamping
       - give an approximate idea of when a document came into existence
       - accurately conveys the order of creation of these documents
       - security property requires that a document’s timestamp can’t be changed after
          the fact



### Stuart Haber and Scott Stornetta


### Timestamping of Documents

- In Haber and Stornetta’s scheme, there’s a timestamping service to which clients
    send documents to timestamp. When the server receives a document, it signs the
    document together with the current time and as well as a link or a pointer to the
    previous document and issues a “certificate” with this information. The pointer in
    question is a special type pointer which links to a piece of data instead of a
    location. That means that if the data in question changes, the pointer automatically
    becomes invalid.
- What this achieves is that each document’s certificate ensures the integrity of the
    contents of the previous document. In fact, you can apply this argument
    recursively; each certificate essentially fixes the entire history of documents and
    certificates up until that point.


### Timestamping of Documents (continued)

- If we assume that each client in the system keeps track of at least a few certificates —
    their own documents’ certificates, and those of the previous and following
    documents —then collectively the participants can ensure that the history cannot be
    changed after the fact. In particular, the relative ordering of documents is
    preserved.
- A later paper proposed an efficiency improvement; instead of linking documents
    individually, we can collect them into blocks and link blocks together in a chain.
    Within each block, the documents would again be linked together, but in a tree
    structure instead of linearly. This decreases the amount of checking needed to
    verify that a particular document appears at a particular point in the history of the
    system.
- Bitcoin uses the above concepts to record the Bitcoin transactions as blocks in a
    Blockchain.


### Proof of Work (POW)

- In 1993, Moni Naor and Cynthia Dork came up with a concept as a way to deter denial-
    of-service (DOS) attacks and other service abuses such as spam on a network by
    requiring some work from a service requester, usually meaning processing time by a
    computer.
- Proof of Work was first coined and formalized in a 1999 paper by Markus Jakobsson
    and Ari Juels.
- Bitcoin uses the above concept to solve a cryptographic hashing puzzle by the miners.
    The first miner who solves the puzzle, gets the right to create the next block in the
    Bitcoin blockchain.


### Summary

- History of Digital Ledger
- Timestamping of

Documents

- Proof of Work (POW)


### References

- https://en.wikipedia.org/wiki/Luca_Pacioli
- https://en.wikipedia.org/wiki/Proof_of_work



`


`

## Module 01:

## Blockchain

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- About Blockchain

Technology

- Blockchain
- Blockchain in a nutshell


### About Blockchain Technology

- W. Scott Stornetta remains one of the founding fathers of current blockchain
    technology. He is also a notable figure in the science of cryptography and
    distributed computing. In fact, the first mention of blockchain architecture was
    mentioned in a publication that Stornetta co-authored which described a
    digital hierarchy system known as a “block chain" that utilized digital time-
    stamps for ordering transactions.
- The concept that Stornetta described as a “block chain system” was eventually
    utilized by Satoshi Nakamoto when he was developing Bitcoin's blockchain
    infrastructure. Together with his colleague and friend, Stuart Haber, W. Scott
    Stornetta would go on to lay the foundation for the emergence of the 21st
    century's blockchain technology revolution.


### Blockchain

- A **blockchain** is a growing list of records, called blocks, which are linked using
    cryptography. Each block contains a cryptographic hash of the previous block, a
    timestamp, and transaction data (generally represented as a merkle tree root hash).
- By design, a blockchain is resistant to modification of the data. It is "an open,
    distributed ledger that can record transactions between two parties efficiently and in a
    verifiable and permanent way". For use as a distributed ledger, a blockchain is typically
    managed by a peer-to-peer network collectively adhering to a protocol for inter-node
    communication and validating new blocks. Once recorded, the data in any given block
    cannot be altered retroactively without alteration of all subsequent blocks, which
    requires consensus of the network majority. Although blockchain records are not
    unalterable, blockchains may be considered secure by design and exemplify a
    distributed computing system with high Byzantine fault tolerance. Decentralized
    consensus has therefore been claimed with a blockchain.
- First block in the chain is called Genesis block.


### Father of Blockchain Technology

### W. SCOTT

### STORNETTA



### Blockchain in a nutshell

**Blockchain**

- a shared, replicated, permissioned
ledgertechnology
- opens up business networks by
taking out cost, improving efficiencies and
increase accessibility
- provides full visibility to all actors
across business ecosystems

```
Key Benefits
```
- Reduces settlement time from days
to nearinstantaneous
- Removes overhead and cost
intermediaries
- Reduces risk of collusion and
tampering
- Increases trust through shared
processes and recordkeeping
- eliminates fraud
- reduces integration complexity and
the need for intermediation whilst increasing
efficiency


### Summary

- About Blockchain

Technology

- Blockchain
- Blockchain in a nutshell



`


`

## Module 01:

## Decentralized Applications

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Networked Applications

and Databases

- Centralized Systems
- Decentralized Systems
- Distributed Systems


### Networked Applications and Databases


### Centralized Systems

- In a Centralized System, all nodes are connected to one
    central node that is controlled by one entity.
- It is a Client-Server model. Controlling node runs the
    server software & central database and all other nodes
    run the client software.
- It’s a single point of failure. If the server fails or runs
    into an error, the whole system fails.


### Distributed Systems

- In a Distributed System, each node knows the identity of
    other nodes and all nodes are controlled by one entity.
- Distributed Systems are used when large volume of data is
    handled by the applications.
- Each node will have different set of data and same set of
    software.
- The common goal is to use processing power to collectively
    accomplish a task by distributing responsibility across all
    nodes. Controlling node will aggregate the results.
- If the controlling node fails another node will take over as the
    controlling node. If any of the node fails, the data from that
    node is not available and the result will be partial. It is not a
    total failure.


### Decentralized Systems

- Peer-to-Peer architecture –all nodes are peers of each other. No
    one node has supremacy over other nodes.
- Master-Slave architecture –One node can become a master by
    voting or staking and help in coordinating part of the system; but
    this does not mean the node has supremacy over the other node
    which it is coordinating.
- In a Decentralized System, each central node contains a
    replicated copy of the same software application and database,
    including same set of data.
- Each node may not know the identify of other nodes and all
    nodes are anonymous. The final behavior of the system is the
    aggregate of the decisions of the individual nodes. Note that
    there is no single entity that receives and responds to the
    request.
- Decision-making is done through some form of consensus rather
    than having this responsibility rest in the hands of a single entity.
- No point of failure. If one node goes down, the system will run
    with other nodes successfully.


### Summary

- Networked Applications

and Databases

- Centralized Systems
- Decentralized Systems
- Distributed Systems


### References

- https://www.oreilly.com/library/view/mastering-
    blockchain/9781492054696/ch01.html
- https://www.geeksforgeeks.org/comparison-centralized-decentralized-
    and-distributed-systems/



`


`

## Module 01:

## Bitcoin

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Information on Bitcoin P2P

e-cash paper

- Bitcoin definition
- Concepts used by

```
Cryptocurrency &
Blockchain
```


### Bitcoin

- Bitcoin represents the culmination of decades of research in cryptography and
    distributed systems and includes four key innovations brought together in a unique
    and powerful combination.
- Bitcoin consists of:
    - A de-centralized peer-to-peer network (the bitcoin protocol);
    - A public transaction ledger (the blockchain);
    - A de-centralized mathematical and deterministic currency issuance (distributed
       mining), and;
    - A de-centralized transaction verification system (transaction script).


### Concepts used by Cryptocurrency &

### Blockchain

- Analysis is based on Bitcoin.
- Cryptocurrency uses concepts of:
    - Currency (cash)
    - Cryptography
- Blockchain uses concepts of:
    - Ledger
    - Secured timestamping of digital documents


### Summary

- Information on Bitcoin P2P

e-cash paper

- Bitcoin definition
- Concepts used by

```
Cryptocurrency &
Blockchain
```

### References

- Bitcoin -Wikipedia



`


`

## Module 01:

## CBDC and Digital Rupee

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Central Bank Digital

Currency (CBDC)

- Digital Rupee
- Digital Banknotes and

Coins


### Central Bank Digital Currency (CBDC)

- CBDCs are digital tokens issued by the Central Banks and pegged to the value
    of that country’s fiat currency.
- Two types of CBDCs –wholesale and retail:
    - Wholesale CBDCs are primarily used by Financial Institutions to hold reserves and
       settle inter bank transfers
    - Retail CBDCs are government backed and used by consumers and businesses
- Two types of Retail CBDCs based on access and usage:
    - Token based retail CBDCs are accessible using private/public keys. This method
       allows users to execute transactions anonymously.
    - Account based retail CBDCs require digital identification to access an account.
- The Bahamas, Nigeria, Dominica, Montserrat, Antigua and Barbuda, Saint Lucia,
    St. Kitts and Nevis, St. Vincent and the Grenadines have already launched their
    digital currency.
- Russia’s Digital Ruble, China’s Digital Yuan and India’s Digital Rupee are on trial
    now. In 80 countries projects are underway now.


### Digital Rupee

- Reserve Bank of India has issued a tokenized version of the Digital Rupee (e₹)
    or eINR or E-Rupee as a Central Bank Digital Currency. It is on trial now.
- Digital Rupee for Wholesale (01/11/2022): e₹-W
    - It will be used to settle secondary market transactions in government securities. It
       will help cut transaction cost and prevent the need for settlement guarantee
       infrastructure or for collateral to mitigate settlement risks.
- Digital Rupee for Retail (01/12/2022): e₹-R
    - It will be used by consumers and businesses. It uses blockchain technology and
       transactions are anonymous. Once e₹-R transferred to individual wallet, small value
       transactions will not be traced by banks to maintain anonymity. It will not earn any
       interest but can be converted to bank deposits.


### Denomination - Digital Banknotes and Coins


### Summary

- Central Bank Digital

Currency (CBDC)

- Digital Rupee
- Digital Banknotes and

Coins


### References

- https://www.investopedia.com/terms/c/central-bank-digital-currency-
    cbdc.asp
- https://en.wikipedia.org/wiki/Digital_Rupee



`


## ` Module 2:

## Introduction to

## Cryptography

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- What is Cryptology?
- Symmetric & Asymmetric

key Cryptography

- Different Ciphers
- DES & AES


### Introduction: What is Cryptology?

- Cryptography: The art of writing in secret characters
- Cryptanalysis: The analysis and deciphering of secret writings
- Cryptology: (Webster’s)The scientific study of Cryptography

and Cryptanalysis

- In our contest, Cryptology is the scientific study of protection

of Information.


### Applications

- Secure Communications (war-time)
- File and data base security
- Electronic funds transfer
- Electronic commerce
- Digital cash
- Contract signing
- Electronic mail
- Electronic voting
- Authentication: Passwords, PINs
- Secure identification, Accesscontrol
- Secure protocols


### Principles of Security

- **Secrecy/Confidentiality**
    - Only intended receiver understands themessage
- **Authentication**
    - Sender and receiver need to confirm each other’sidentity
- **Message Integrity**
    - Ensure that their communication has not been altered,either maliciously or by
       accident duringtransmission
- **Nonrepudiation**
    - Sender should not be able to falsely deny that a messagewas sent
- **Availability (System)**
    - Ensure that the information concerned is always readily accessible by the authorized
       viewer


### Principles of Security


### The CIA triad in Cryptography

- Three Fundamental Principles


### Cryptography Components: Cipher

- Cipher is a method for encrypting messages
    - Encryption algorithms are standardized & published
    - The key which is an input to the algorithm is secret


### Categories of Cryptography


### Symmetric-key cryptography


### Digital Signatures

- Asymmetric Key Cryptography


### Digital Signatures

- Asymmetric Key Cryptography


### Keys used in Cryptography


### Symmetric Key Cryptography: Traditional

### Ciphers

- Symmetric-key cryptography started thousands of years ago

```
when people needed to exchange secrets (for example, in a
war).
```

### Caesar Cipher






- Convey one piece of information for decryption: Shift Value
- Trivially easy to crack (26 possibilities for a 26 characters

alphabet)


### Transposition Cipher: Columnar

### Transposition

- This involves rearrangement of characters on the plain text

into columns

- If the letters are not exact multiples of thetransposition

size, padding with an infrequent letter such as x or z.


### Block vs Stream Ciphers

- Stream ciphers process messages a bit or byte at a time when

en/decrypting.

- Block ciphers process messages in into blocks, each of

which is then en/decrypted.

- Like a substitution on very big characters: 64 - bits or more
- Many current ciphers are block ciphers, one of the most

widely used types of cryptographic algorithms


### DES (Data Encryption Standard)


### Strength of DES - Key Size

- 64 - bit keys have 264 values
- Brute force search looks hard
- Recent advances have shown is possible
    - in 1997 on a huge cluster of computers over the Internet ina few
       months
    - in 1998 on dedicated hardware called “DES cracker” by Electronic
       Frontier Foundation (EFF) in a few days($220,000)
    - in 1999 above combined in 22hrs!


### AES (Advanced Data Encryption Standard)

- Advanced Encryption Standards (AES)
    - US NIST issued call for ciphers in 1997
    - Rijndael was selected as the AES in Oct- 2000
- Private key symmetric block cipher
- Stronger & faster than Triple-DES
    - In AES, all operations are performed on 8-bit bytes. In
       particular, the arithmetic operations of addition,
       multiplication, and division are performed over the finite field
       GF(2^8 ).


### AES (Advanced Data Encryption Standard)

- AES has three different configurations with respect to the

number of rounds and key size.


### AES (Advanced Data Encryption Standard)


### Substitution-Permutation Ciphers

- Substitution-permutation (S-P) networks [Shannon, 1949]
    - modern substitution-transposition product cipher
- S-P networks are based on the two primitive
    cryptographic operations
       - _substitution_ (S-box)
       - _permutation_ (P-box)
- Provide _confusion_ and _diffusion_ of message
- These form the basis of modern block ciphers


### Confusion and Diffusion

- Cipher needs to completely obscure statistical
    properties of original message
- A one-time pad does this
- More practically Shannon suggested S-P networks to obtain:
- **Diffusion** – dissipates statistical structure of plaintext
over bulk of ciphertext
- **Confusion** – makes relationship between ciphertext
and key as complex as possible


### Conclusion

- What is Cryptology?
- Symmetric & Asymmetric

key Cryptography

- Different Ciphers
- DES & AES


### References

- Understanding Cryptography: A Textbook for Students and
    Practitioners Textbook by Christof Paar and Jan Pelzl



`


`

## Module 2:

## Asymmetric Key

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Symmetric Cryptography
- Diffie-Hellman Exponential Key
    Exchange
- RSA Algorithm
- Asymmetric Encryption
- Communication with Public
    Key Algorithms
- Communications with a Hybrid
    Cryptosystems


### Symmetric Cryptography

- Both parties must agree on a secret key, _K_
- Message is encrypted, sent, decrypted at other side
- Key distribution must be secret
    - otherwise, messages can be decrypted
    - users can be impersonated


###### Key explosion

- Each pair of users needs a separate key forsecure

communication


### Key Distribution

- Secure key distribution is the biggest problem with symmetric

cryptography


### Key Distribution

- How can you communicate securely with someone you’ve

never met?

- Whitfield Diffie: idea for a public key algorithm challeng _e_
    _- can this be done securely?_
       - _Knowledge of public key should not allow derivation of private_
          _key_


### Diffie-Hellman Exponential Key Exchange

- Key distribution algorithm
    - first algorithm to use public/private keys
    - _not_ public key encryption
    - based on difficulty of computing discrete logarithms in a finite field
       compared with ease of calculating exponentiation
- Allows us to negotiate a secret **session key** without fear of

eavesdroppers


### Diffie-Hellman Exponential Key Exchange

- All arithmetic performed in field of integers modulo some

large number

- Both parties agree on
    - a **large prime number** **_p_**
    - and a number α< _p_
- Each party generates a public/private key pair
    - Private key for user i: Xi
    - Public key for user i:𝑦𝑖 = 𝛼𝑥𝑖 mod𝑝


### Diffie-Hellman Exponential Key Exchange

K = 𝑌𝐵ሶ

```
𝑋𝐴
mod𝑝
```
_K = (Bob’s public key) (Alice’s private key) modp_

- Alice has secret key _XA_
- Alice has public key _YA_
- Alice computes
    - Bob has secret key _XB_
    - Bob has public key _YB_


### Diffie-Hellman Exponential Key Exchange

- Alice has secret key _XA_
- Alice has public key _YA_
- Alice computes
    - Bob has secret key _XB_
    - Bob has public key _YB_
    - Bob computes

```
K = K’
K is a common key, known only to Bob and Alice
```

### Diffie-Hellman Example

Suppose, _p =_ 31667, α = 7

Alice picks

XA = 18

Alice’s public key is:

YA = 718 mod 31667

= 6780

```
Bob picks
XB = 27
Bob’s public key is:
YB = 727 mod 31667
= 22184
```
```
K = 2218418 mod 31667
K = 14265
```
```
K = 678027 mod 31667
K = 14265
```

### Key Distribution Problem is solved!

- User maintains private key
- Publishes public key in database (“phonebook”)
- Communication begins with key exchange to establish a

common key

- Common key can be used to encrypt a **session key**
    - increase difficulty of breaking common key by reducing
       the amount of data we encrypt with it
    - session key is valid _only_ for one communication session


### RSA: Public Key Cryptography

- Ron Rivest, Adi Shamir, Leonard Adleman created a true

public key encryption algorithm in 1977

- Each user generates two keys
    - private key (kept secret)
    - public key
- Difficulty of algorithm based on the difficulty of factoring

large numbers

- keys are functions of a pair of large (~200 digits) prime
    numbers


### RSA Algorithm

Generate keys

- Choose two random large prime numbers _p_ , _q_
- Compute the product _n =pq_
- randomly choose the encryption key, _e_ , such that:
    - _e_ and ( _p_ - 1)( _q_ - 1) are relatively prime
- use the extended Euclidean algorithm to compute the
decryption key, _d_ :
- _ed_ = 1 mod (( _p_ - 1) ( _q_ - 1))
- _d = e_ -^1 mod (( _p_ - 1) ( _q_ - 1))
- discard _p_ , _q_


- Encrypt
    - divide data into numerical blocks < _n_
    - encrypt each block:
       - _c_ = _m_ e mod _n_
- Decrypt:
    - _m_ = _c_ d mod _n_

### RSA Algorithm


### Asymmetric Encryption: RSA

 P=5 & q=7

 n=5*7=35 and z=(4)*(6) = 24

 e = 5

 d = 29 , (29x5 = 1 mod 24)

 Keys generated are

```
 Public key: (5, 35)
 Private key is (29,35)
```
 Encrypt the word love using (c = me modn)

```
 Assume that the alphabets are between 1 & 26
```

### Asymmetric Encryption: RSA

- Decrypt the word love using (m = cd modn)
    - d=29, n=35


### Communication with Public Key Algorithms

- Different keys for encrypting and decrypting
    - no need to worry about key distribution


### Communication with Public Key Algorithms

Alice Bob

Alice’s public key: KA

Bob’s public key: KB

exchange public keys

(or look up in a directory/DB)


### Communication with Public Key Algorithms

Alice Bob

Alice’s public key: KA

Bob’s public key: KB

```
Encrypt message with
Bob’s public key
```
```
Decrypt message with
Bob’s private key
```

### Communication with Public Key Algorithms

Alice Bob

Alice’s public key: KA

Bob’s public key: KB


### Public Key Woes

Public key cryptography is great but:

- RSA about 100 times slower than DES in software, 1000 times
    slower in HW
- Vulnerable to chosen plaintext attack
    - if you know the data is one of _n_ messages, just encrypt
       each message with the recipient’s public key and compare
- It’s a good idea to reduce the amount of data encrypted with
    any given key
       - but generating RSA keys is computationally very time
          consuming


### Hybrid Cryptosystems

- Use public key cryptography to encrypt a randomly

generated symmetric key

Session key


### Communication with a Hybrid Cryptosystem

Alice Bob

Bob’s public key: KB

Get recipient’s public key

(or fetch from directory/database)


### Communication with a Hybrid Cryptosystem

Alice Bob

Bob’s public key: KB

Pick random session key, _K_

```
Encrypt session key with
Bob’s public key
```
_K_ = Db(E _B_ ( _K_ ))

```
Bob decrypts K with
his private key
```
𝐸𝐵 𝐾


### Communication with a Hybrid Cryptosystem

Alice Bob

Bob’s public key: KB

𝐸𝐵 𝐾 _K_ = Db(E _B_ ( _K_ ))

Encrypt message usinga

```
symmetric algorithm
and key K
```
```
Decrypt message using a
symmetric algorithm
and key K
```

### Communication with a Hybrid Cryptosystem

Alice Bob

```
Bob’s public key: KB
𝐸𝐵 𝐾 K = Db(E B ( K ))
```
Decrypt message using a

```
symmetric algorithm
and key K
```
```
Encrypt message using a
symmetric algorithm
and key K
```

### Conclusion

- Symmetric Cryptography
- Diffie-Hellman Exponential Key
    Exchange
- RSA Algorithm
- Asymmetric Encryption
- Communication with Public
    Key Algorithms
- Communications with a Hybrid
    Cryptosystems


### References

- Understanding Cryptography: A Textbook for Students and
    Practitioners Textbook by Christof Paar and Jan Pelzl



`


`

## Module 2:

## Digital Signatures

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Signatures
- Digital Signatures – Public

Key Cryptography

- Secure and Authenticated

Messaging

- Cryptographic Toolbox


### Signatures

We use signatures because a signature is:

- Authentic
- Not reusable
    - Unforgeable
    - Non repudiable
- Renders document unalterable


### Signatures

We use signatures because a signature is:

- Authentic
- Not reusable
    - Unforgeable
    - Non repudiable
- Renders document unalterable

**All Untrue!**

```
Can we do better with Digital
Signature?
```

### Digital Signatures - Public Key Cryptography

Encrypting a message with a private key is the same as signing!


### Digital Signatures - Public Key Cryptography

- What if Alice was sending Bob binary data?
    - Bob might have a hard time knowing whether the
       decryption was successful or not
- Public key encryption is considerably slower than symmetric

encryption

- what if the message is very large?
- What if we don’t want to hide the message, yet want a valid

signature?


### Digital Signatures - Public Key Cryptography

- Create a hash of themessage
- Encrypt the hash and send it with themessage
- Validate the hash by decrypting it and comparing it with the

hash of the received message


### Digital Signatures - Public Key Cryptography

Alice generates a hash of the message


### Digital Signatures - Public Key Cryptography

Alice encrypts the hash with her private key


### Digital Signatures - Public Key Cryptography

Alice sends Bob the message and the encrypted hash


### Digital Signatures - Public Key Cryptography

1. Bob decrypts the hash using Alice’s publickey
2. Bob computes the hash of the message sent by
    Alice


### Digital Signatures - Public Key Cryptography

Ifthe hashes match

- the encrypted hash _must_ have been generated byAlice
- the signature is valid


### Secure and Authenticated Messaging

- If we want secrecy of the message
    - combine encryption with a digital signature
    - use a session key:
       pick a random key, _K_ , to encrypt the message with a
symmetric algorithm
    - encrypt _K_ with the public key of each recipient
    - for signing, encrypt the hash of the message with sender’s
       private key


### Secure and Authenticated Messaging

Alice generates a digital signature by encrypting the message

digest with her privatekey.


### Secure and Authenticated Messaging

Alice picks a random key, _K_ , and encrypts the message (P) with it

using a symmetric algorithm.


### Secure and Authenticated Messaging

Alice encrypts the session key for each recipient of this message:

Bob and Charles using their public keys.


### Secure and Authenticated Messaging

The aggregate message is sent to Bob and Charles


### Secure and Authenticated Messaging

Bob receives the message:

- extracts key by decrypting it with his private key


### Secure and Authenticated Messaging

Bob decrypts the message using _K_


### Secure and Authenticated Messaging

Bob computes the hash of the message


### Secure and Authenticated Messaging

Bob looks up Alice’s publickey


### Secure and Authenticated Messaging

Bob decrypts Alice’s signature using Alice’s publickey


### Secure and Authenticated Messaging

Bob validates Alice’ssignature


### Cryptographic toolbox

- Symmetric encryption
- Public key encryption
- One-way hash functions
- Random number generators
    - Nonces, session keys


### Examples

- Key exchange
    - Public key cryptography
- Key exchange + secure communication
    - Public key + symmetric cryptography
- Authentication
    - Nonce + encryption
- Message authentication codes
    - Hashes
- Digital signature
    - Hash + encryption


### Conclusion

- Signatures
- Digital Signatures – Public

Key Cryptography

- Secure and Authenticated

Messaging

- Cryptographic Toolbox


### References

- Understanding Cryptography: A Textbook for Students and
    Practitioners Textbook by Christof Paar and Jan Pelzl



`


`

## Module 2:

## Message Digest

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Hash Function
- Hash Properties
- Attacks against Cryptographic
    Function
- Message Digest (MD)
- Secure Hash Algorithm (SHA)


```
possible inputs
```
```
possible outputs
```
Hash Function

- mathematical function takes any string as

input

- fixed-size output (we’ll use 256 bits)
- efficiently computable (say, O(n))

H(.)


### One-Way Hash Functions

Example

- M = “Elvis”
- H(M) = (“E” + “L” + “V” + “I” + “S”) mod 26
- H(M) = (5 + 12 + 22 + 9 + 19) mod 26
- H(M) = 67 mod 26
- H(M) = 15

```
M H H(M) = h
```

### Collision

Example

- x = “Viva”
- y = “Vegas”
- H(x) = H(y) = 2

```
x H H(x)
=
```
```
y H H(y)
```

### Avalanche Effect


- Collision resistance implies 2nd pre-image resistance
- Collision resistance does not imply pre-image resistance

### Hash Properties


- Authentication is the process of validating the identity of a

user (Authenticity) or the integrity of a piece of data (Integrity).

- Technologies that provide authentication
    - Message Digests (MD)
    - Message Authentication Codes (MAC)
    - Digital Signatures
    - Others....

### Authentication


- A message digest is a fingerprint
    for a document.
- Purpose of the message digest is to
    provide proof that data has not
    altered – Integrity.
- Process of generating a message
    digest from data is called hashing

### Message Digests (MD)

```
Message
```
```
Message
Digest
Algorithm Digest
```

### Message Authentication Codes (MAC)

- A message digest created with a key
    - Creates security by requiring a secret key to be possessed by
    both parties in order to retrieve the message
    - A MAC is a short string used to verify the message integrity and
    authentication

```
Message
```
```
Message
Digest
Algorithm Digest
```
```
SecretKey
```


- Integrity

### Cryptographic Hash Functions:

### Applications


### Attacks against Cryptographic Function


### Attacks against Cryptographic Function


### Attacks against Cryptographic Function


### Attacks Against Cryptographic Function


### Commonly Used Hash Functions


- Standards:

MD5 : 128 bit hashing algorithm by Ron Rivest of RSA

- Broken since 2004 by Xiaoyun Wang
- Collisions can be constructed in seconds on a laptop

SHA & SHA-1 : 160 bit hashing algorithm developed by NIST

- Considered insecure
- Practically broken since 2005 by Xiaoyun Wang

### Message Digests (MD)


- SHA- 2 family: 224, 256, 384 or 512 bits
- SHA- 3 family output can be arbitrary size
    - NIST started a competition for SHA- 3 in 2007.
    - NIST’s original concern was that SHA- 2 would soon
       be broken, although in fact SHA- 2 is still fine.
- SHA-3 (Secure Hash Algorithm 3) is the latest member of

```
the Secure Hash Algorithm family of standards, released by
NIST on August 5, 2015.
```
### Message Digests (MD)


### MD5: Message Digest Version 5

- Author: R. Rivest, 1992
- 128 - bit hash

Based on earlier, weaker MD4(1990)

- Collision resistance (B-day attack resistance)

Only 64-bit

- Output size not long enough today (due to various

attacks)


### MD5 Overview

```
Similar forMD4/MD5/SHA- 1
```

### MD5: Padding

- Given original message M, add padding bits “100...” such

```
that resulting length is 64 bits less than a multiple of 512
bits.
```
- Append original length in bits to the padded message.
- Final message chopped into 512-bit blocks


### MD5: Blocks

- As many stages as the number of 512-bit blocks in

the final padded message


### Secure Hash Algorithm (SHA)

- SHA originally designed by NIST & NSA in 1993
- Was revised in 1995 as SHA- 1
- US standard for use with DSA signature scheme
    - standard is FIPS 180-1 1995, also Internet
       RFC3174
- Based on design of MD4 with key differences
- produces 160-bit hash values
- 2005 results on security of SHA-1 raised concerns

on its use in future applications


### Revised Secure Hash Standard

- NIST issued revision to FIPS 180-2 in 2002
- Added 4 additional versions of SHA
    - SHA-224, SHA-256, SHA-384, SHA- 512
- Designed for compatibility with increased security
    provided by the AES cipher
- Structure & detail is similar to SHA- 1
- Hence analysis should be similar
- But security levels are rather higher


### SHA- 512 Overview


### SHA-512 Compression Function

- Heart of the algorithm
- Processing message in 1024 - bit blocks
- Consists of 80 rounds
    - updating a 512 - bit buffer
    - using a 64 - bit value wt derived from
       the current message block
    - and a round constant based on cube
       root of first 80 prime numbers


### SHA-512 Compression Function


### SHA

```
Output sizestate (bits) Internalsize
(bits)
```
```
Block
(bits)size
```
```
Maxmessage
size(bits)
```
```
Wd or
(bitssize
)
```
```
Rounds Operations Collisionsfound
```
SHA- 0 160 160 512 264 − 1 32 80 +, and, or, xor,rot Yes

SHA- 1 160 160 512 264 − 1 32 80 +, and, or, xor,rot (2 52 None
attack)

```
256/224 256 512 264 − 1 32 64 +, and, or, shr, xor,rot None
```
SHA- 2

```
512/384 512
Secure HashAlgorithm
```
```
1024 2128 −^16480 +, and, or, shr, xor,rot None
```

### Conclusion

- Hash Function
- Hash Properties
- Attacks against Cryptographic
    Function
- Message Digest (MD)
- Secure Hash Algorithm (SHA)


### References

- Handbook of Applied Cryptography1996 Edition Paul C. van Oorschot,
    Scott A. Vanstone A. J. Menezes



`


## ` Module 2:

## Elliptical Curve

## Cryptography

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Elliptic Curve Cryptography
    (ECC)
- Discrete Logarithm Problem
    (DLP)
- Elliptic Curve
    Encryption/Decryption


### General Form of EC

- An _elliptic curve_ is a plane curve defined by an equation of the

```
form
y^2 = x^3 + a x + b
```
where 4a^3 + 27b^2 ≠ 0



### Characteristics of Elliptic Curve

Forms an abelian group

- Symmetric about the x-axis
- Point at Infinity acting as the identity element
- (A1) Closure: If _a_ and _b_ belongs to _G_ , then _a*b_ is also in _G_.
- (A2) Associative: _a*(b*c) = (a*b)*c_ for all _a, b, c_ in _G_.
- (A3) Identity element: There is an element e in _G_ such that

_a*e=e*a=a_ for all a in _G_.

- (A4) Inverse element: For each a in _G_ there is an element a’ in

_G_ such that _a*a=a’*a=e_.

- (A5) Commutative: a*b=b*a for all a, b in G.


### Discrete Logarithm Problem (DLP)

- Let P and Q be two points on the ellipticcurve
    - Such that Q = kP, where k is a scalar value
- DLP: Given P and Q, find k?
    - If k is very large, it becomes computationally infeasible
- The security of ECC depends on the difficulty of DLP
- Main operation in ECC is Point Multiplication


### Point Multiplication

- Point Multiplication is achieved by two basic curve operations:
1. Point Addition, L = J + K
2. Point Doubling, L = 2J
- Example:
- If k = 23; then, kP = 23*P

= 2(2(2(2P) + P) + P) + P


### Point Addition

- Geometrical explanation:


### Point Addition

Analytical Explanation:

- Consider two distinct points J and K such that J = (xJ, yJ) and

K = (xK, yK)

- Let L = J + K where L = (xL, yL), then

xL = s^2 - xJ – xK

```
yL = -yJ + s (xJ– xL)
s = (yJ – yK)/(xJ – xK), s is slope of the line through J and K.
```

### Point Doubling

- Geometrical Explanation:


### Point Doubling

Analytical Explanation:

- Consider a point J such that J = (xJ, yJ), where yJ ≠ 0
- Let L = 2J where L = (xL, yL), Then

```
xL = s^2 – 2xJ
yL = -yJ + s(xJ - xL)
s = (3xJ^2 + a) / (2yJ), s is the tangent at point J and a is one
of the parameters chosen with the ellipticcurve.
```

### Finite Fields

- The Elliptic curve operations shown were on real numbers
    - Issue: operations are slow and inaccurate due to round-off
       errors
- To make operations more efficient and accurate, the

curve is defined over two finite fields

- Prime field GF(p) and
- Binary field GF( 2 m)
- The field is chosen with finitely large number of points

suited for cryptographic operations


### EC on Prime field GF(p)

- Elliptic Curve equation:
    - **y**^2 **mod p = (x**^3 **+ ax + b) modp**
    - where **( 4 a**^3 **+ 27 b**^2 **) mod p ≠ 0**
- Elements of finite fields are integers between 0 and p- 1
- The prime number p is chosen such that there is finitely

```
large number of points on the elliptic curve to make the
cryptosystem secure.
```
- SEC (Standard for Efficient Cryptography) specifies curves

with p ranging between 112 - 521 bits


### EC on Binary field GF( 2 m)

- Elliptic Curve equation:

y^2 + xy = x^3 + ax^2 + b, where b ≠0

- Here the elements of the finite field are integers of length at
    most **m** bits.
- In binary polynomial the coefficients can only be 0 or 1.
- The **m** is chosen such that there is finitely large number of
    points on the elliptic curve to make the cryptosystem
    secure.
- SEC specifies curves with **m** ranging between 113 - 571 bits.


### ECC Diffie-Hellman Key Exchange


### Elliptic Curve Encryption/Decryption

- As with the key exchange system, an encryption/decryption

```
system requires a point G and an elliptic group Eq(a, b ) as
parameters. Each user A selects a private key 𝑛𝐴 and
generates a public key 𝑃𝐴 = 𝑛𝐴 × 𝐺
```
- To encrypt and send a message 𝑃𝑚 to B, A chooses a random

```
positive integer k and produces the ciphertext 𝐶𝑚, consisting
of the pair of points:
𝐶𝑚 = { kG , 𝑃𝑚 + k 𝑃𝐵}
```
- Note that A has used B's public key 𝑃𝐵. To decrypt the

```
ciphertext, B multiplies the first point in the pair by B's secret
key and subtracts the result from the second point:
𝑃𝑚+ k 𝑃𝐵 - 𝑛𝐵( kG ) = 𝑃𝑚 + k (𝑛𝐵 G ) - 𝑛𝐵( kG ) = 𝑃𝑚
```

### Comparable Key Sizes in Terms of

### Computational Effect for Cryptanalysis


### Conclusion

- Elliptic Curve Cryptography
    (ECC)
- Discrete Logarithm Problem
    (DLP)
- Elliptic Curve
    Encryption/Decryption


### References

- Handbook of Applied Cryptography1996 Edition Paul C. van Oorschot,
    Scott A. Vanstone A. J. Menezes



`


## ` Module 03:

## Blockchain History &

## Generations

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Blockchain History
- Blockchain Generations
- Blockchain Initiatives



### Blockchain History (continued)


### Blockchain Generations

```
Blockchain
1.0
```
```
Blockchain
2.0 Blockchain 3.0 Blockchain 4.0
```
```
Currency Smart Contract DApps Industry
```
Digital Currency
Distributed Ledger
Merkel Tree
Blockchain Data
POW

```
Smart Contract
Virtual
Machine
Decentralized
Distributed
Application
```
```
Scalable
Good user
Interface
User Experience
Inter Operability
Efficient
```
```
Industry
Infrastructure
based
Blockchain
Ecosystem
```

## Generation of Blockchains

- Bitcoin Blockchain – Blockchain 1.0 – 2009
    - Proof of Work (POW)
- Ethereum Blockchain – Blockchain 2.0 – 2015
    - Initial implementation with Proof of Work (POW)
    - Turning Application Layer into Ethereum Virtual Machine. EVM can
       process programs called smart contracts that any developer could
       deploy to the Ethereum blockchain in a permissionless fashion.
    - Converted to Proof of Stake system on 15/09/2022.
    - Casper the Friendly Finality Gadget (CFFG) is a POS overlay on top of
       the existing Ethereum POW proposal mechanism—a hybrid POW /
       POS implementation.


### Generation of Blockchains (continued)

- Cosmos – Blockchain 3.0 – 2019
    - Proof of Stake (POS)
    - Internet of Blockchains, a network of blockchains able to
       communicate with each other in a decentralized way.
    - Bitcoin, Ethereum or any other cryptocurrency can be part of a Zone
       in the Cosmos Internet of Blockchains.


### Leading Blockchain Consortiums and

### Collaborative Projects

```
The very nascent Blockchain market is already
seeing massive consolidation with around four
major mining service companies gaining
prominence globally over independent miners
and small companies. Future years might see
multiple interoperable blockchains coming into
existence
```

###### Crypto Regulations by Country

- How different countries around the world approach crypto-

regulation?


### Blockchain Technology

- Behind the success of Bitcoin:

```
IoT Supply Chain EHR ProtectionCopyright KYC Land Registry
```
```
Data Sharing
```
```
E-Commerce
```
Postal System

```
Cryptocurrency
```
```
E-Governance
```
```
E-Voting
```
```
Smart Grid
```
```
Social
Networking
```
```
Data
Provenance
```
```
Insurance
```
```
Education
Certificate
```
```
Finance
```
```
Many More....
```
```
File Sharing
```
```
Smart
Agriculture
```
```
Asset Transfer
```
```
Crowd Funding
```
```
Smart Homes
```
```
Criminal
Record Sharing
```

### Hype Cycle for Blockchain Business, 2019


### Practical Blockchain

- Blockchain is a type of distributed ledger, an expanding chronologically
    orders list of cryptographically signed, irrevocable transactional records
    shared by all participants in a network. This enables two (or more) parties
    who don’t know each other to exchange value without a need for a
    centralized authority.
- Complete blockchain includes five elements: Distribution, Immutability,
    Decentralization, Encryption and Tokenization.
- By 2023, blockchain will be scalable technology, and will support trusted
    private transactions with the necessary data confidentiality.


### One year ago: 117 Initiatives in 26 Countries


### Now, 202 Blockchain Initiatives in 45 Countries



### Summary

- Blockchain History
- Blockchain Generations
- Blockchain Initiatives


### References



`


`

## Module 03:

## Types of Blockchain

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- About Blockchain
- Mining Process
- Types of Blockchain
- When to Use What Type of

Blockchain?


### Blockchain


## Hashing

- No matter the size of the input string, the output is always 64 characters
- A completely different hash result though the change in text string “The world is
    a balloon!” is minute i.e., removal of “!” or replacing “The” with “the”. Provides
    security from tampering during transmission.


### Mining Process


### Immutability

Immutable Transactions


### Types of Blockchain (continued)


### When to Use What Type of Blockchain?


### Types of Blockchain


### Types of Blockchain (continued)


### Bitcoin and Ethereum


### Summary

- About Blockchain
- Mining Process
- Types of Blockchain
- When to Use What Type of

Blockchain?


### References

- Blockchain Technology by Chandramouli Subramanian, Asha

A George, Abhilash K A and Meena Karthikeyan



`


## ` Module 03:

## Blockchain Consensus

## Algorithms

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Blockchain Consensus

Algorithms

- Objectives of Consensus

Algorithms

- Properties of Consensus

Algorithms


### Blockchain Consensus Algorithms

- A consensus algorithm is a fault-tolerant mechanism that is used in computer
    and blockchain systems to achieve the necessary agreement among the
    processes on a single data value or a single state of the network.
- In the distributed computing and multi-agent systems like cryptocurrencies,
    solving the problem of consensus mechanism is essential to build a healthy
    network.
- The Blockchain consensus protocol consists of some specific objectives such
    as coming to an agreement, collaboration, cooperation, equal rights to every
    node, and mandatory participation of each node in the consensus process.


### Blockchain Consensus Algorithms (continued)

- Google’s Page Rank, load balancing, smart grids, clock
    synchronization and drone control are some of the examples of
    consensus algorithms.
- The consensus algorithms used by private blockchains and public
    blockchains are different as there are different kinds of consensus
    algorithms which work on different principles.


### Objectives of Consensus Algorithms

- **Agreement Seeking:** A consensus algorithm should be able to bring about
    as much agreements as possible from the nodes.
- **Collaborative:** All the members should try to work together to achieve an
    outcome that shows the groups best interest first.
- **Cooperative:** Each of the nodes should not put their own interests first rather
    they should work as a team than individuals.
- **Egalitarian:** It should be as egalitarian as possible for a group of nodes
    seeking to build a consensus. It means that each and every vote have equal
    weight. The vote of one node cannot be more significant than of another.


### Objectives of Consensus Algorithms (continued)

- **Inclusive:** In the process of consensus, many nodes should be involved. It
    shouldn’t be like regular voting, where people don’t really feel like voting
    because they think their vote in the long run won’t have any weight.
- **Participatory:** The process of consensus should be active where every node
    should participate in the overall process.


### Properties of Consensus Algorithms

- Structural properties
- Security Properties
- Performance properties



### Summary

- Blockchain Consensus

Algorithms

- Objectives of Consensus

Algorithms

- Properties of Consensus

Algorithms


### References

- https://www.investopedia.com/terms/c/consensus-mechanism-

```
cryptocurrency.asp
```
- https://www.geeksforgeeks.org/consensus-algorithms-in-blockchain/



`


`

## Module 03:

## Proof of Work (POW)

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Proof of Work (POW)

Consensus

- Advantages and

Disadvantages of POW

- Electricity Consumption

using POW


### Proof of Work (POW)

- POW is a standard consensus algorithm used by Bitcoin and Litecoin, the
    most popular cryptocurrency networks.
- Cynthia Dwork and Moni Naor originally published the POW concept in 1993,
    but Markus Jakobsson and Ari Juels coined the word ‘Proof of Work’ in a
    document published in 1999.
- A participant node is expected to show that the work they have completed
    and submitted that allows them to obtain the right to add new transactions to
    the blockchain.
- With POW, miners compete against each other in order to complete network
    transactions and gets rewarded.


### POW (continued)

- A complex mathematical puzzle and the ability to quickly prove the solution
    are the key working principles.
- The mathematical problem is a problem that requires a great deal of
    computing power to solve.
- There are mainly two characteristics that have led to this consensus protocol’s
    brand popularity and they are:
    - It is very difficult to solve the mathematical problem.
    - The correctness of the solution can be easily verified.


### POW (continued)

- Each block’s hash contains the previous blocks hash, which increase the
    security and prevents any violation of the block.
- The new block is created if a minor succeeds to solve the puzzle.
- The transactions are then placed in this block and thereafter considered as
    confirmed.


### Pros and Cons of POW

Advantages:

- Defense from DoS attacks
- Mining possibilities

```
Disadvantages:
```
- The 51% risk
- Time consuming
- Transaction Confirmation Time
- Useless calculations


### PoW

.



```
Place your
Webcam Video here
Size 38%
```
.


.


The Bitcoin POW mechanism is so costly that it consumes the same amount of electricity it takes to power
a country like Switzerland in one year. **Bitcoin’s current** estimated annual electricity consumption is 61.4
TWh, which is also equivalent to 1.5% of the electricity consumed in the UnitedStates.

```
.
```

### Applications of POW Algorithm

- Bitcoin is the most popular application of POW.
- Bitcoin based cryptocurrencies such as Litecoin, is based on similar

model.

- Ethereum is another big project with POW and recently changed

to POS on 15- 09 - 2022.

- It is fair enough to assume that the POW consensus model is used

by many of the Blockchain applications.


### Proof-of-X

Proof-of-X (POX) schemes is an umbrella term for systems that replace POW

with more useful and energy - efficient alternatives to Proof-of-Work (POW).


### Proof-of-X


### Summary

- Proof of Work (POW)

Consensus

- Advantages and

Disadvantages of POW

- Electricity Consumption

using POW


### References



`


`

## Module 03:

## Proof of Stake (POS)

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Proof of Stake (POS)

Consensus

- Advantages and

Disadvantages of POS

- POW vs POS


### Proof of Stake (POS)

- The principle of Proof of Stake (POS) states that, according to how many coins
    he or she owns, a person may mine or validate the block of the transactions.
- This means that the more a miner holds Bitcoin or Altcoin, the more mining
    power he has.
- The proof of stake was created as an alternative to POW, to handle its
    disadvantages.
- PPcoin was the first cryptocurrency to apply POS to the blockchain.
- In POS, there are validators instead of miners. Some of their ethers are locked
    by the validators as a stake in the ecosystem.

```
Miner/Mining Vs. Validator/Minting orforged
```

### POS (continued)

- POS requires people to prove the ownership of a certain amount ofcurrency
    - It is believed that people with more currencies would be less likely to attack the
       network.
    - If richest person attacks, currency value falls and it may be a loss for the attackers!
- Many blockchains adopt POW at the beginning and transform to POS
    gradually.
    - For instance, Ethereum is planning to move from Ethash (a kind of POW) (Wood,
       2014) to Casper (a kind of POS) (Zamfir,2015).
- POS alternatives consume less energyand reach higher transactions per
    second.


### POS (continued)

- But they have also still to prove theirattack-resistance in real open public
    settings like POW so far.
- Challenge for proof-of-stake systems isto keep track of the changing stakes of
    the stakeholders.
- Selection by account balance would result in undesirable centralization
    because the single richest member would have a permanent advantage as it
    getsricher.
- Different versions: random selection, age-based stake selection (number of
    coins stake multiply by the time they have been staked, when selected, time
    reset to0)...


### Proof of Stake: Randomization

- Blackcoin (Vasin, 2014) usesrandomization to predict the next
    generator.
- It uses a formula that looks for the lowest hash value in combination
    with the sizeof the stake.


### Proof of Stake: Coinage

- Peercoin (King and Nadal, 2012) favourscoin age-basedselection.
- In Peercoin, older and larger sets of coins havea greater probability of
    mining the next block.
- Once a user has forged a block, their coin ageis reset to zero and then
    they must wait at least 30 days again before they can sign another
    block.


### Pros and Cons of POS

Advantages:

- Higher speed as compared to
    POW
- Lower energy consumption as
    supercomputers are not
    required
- Lesser hardware requirements
    as users can participate even
    without setting up a
    supercomputer

```
Disadvantages:
```
- It is still vulnerable as any
    person with ample money to
    invest may buy an insane
    number of coins, thus reducing
    the systems decentralisation.
- The wealthy people get
    wealthier syndrome may be
    seen and the consensus may
    have influence only of the
    wealthiest.


### POS vs POW

- It handles the Accessibility, Centralization and Scalability.
- **Accessibility:** Running a validator node on a POS chain is a substantially
    lower barrier to entry for a user than running a mining node on a POW chain.
- **Centralization:** They have decreased entry barriers and absence of worries
    about minimising power costs. Only a non-zero quantity of crypto, an internet
    connection and a computing device (laptop, phone or tablet) are necessary
    for participation in a POS chain.
- **Scalability:** POS architecture allow the implementation of scalability solution
    known as sharding. Sharding is a scaling method for a database in which a
    blockchain is divided into several shard chains, each of which can process the
    blocks.




### Summary

- Proof of Stake (POS)

Consensus

- Advantages and

Disadvantages of POS

- POW vs POS


### References



`


`

## Module 03:

## DPOS and PBFT

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Delegated Proof of Stake

(DPOS) consensus

- Advantages and

Disadvantages of DPOS

- Practical Byzantine Fault

```
Tolerance (PBFT)
consensus
```
- Advantages and

Disadvantages of PBFT


### Delegated Proof of Stake (DPOS)

- Active DPOS based blockchain users vote for ‘witnesses’ and ‘delegates’ by
    putting their tokens on their candidate’s name (these tokens are not spent this
    way, they represent the stakeholder’s position and remain as his or her
    property).
- In different cryptocurrencies, the roles of witnesses and delegates differ and
    one role may absorb or even abolish the function of another role.
- Most DPOS based cryptocurrencies do not allow witnesses to avoid the
    occurrence of transactions and if a witness fails a block (for example, because
    his or her server has gone offline), it is automatically forwarded to the next
    active witness.


### DPOS (continued)

- Delegates are chosen to oversee the process and to propose key changes.
- Delegates are not in charge of block creation and confirmation of
    transactions, but they supervise the criteria such as transaction fees, block
    sizes, witness pay and network block intervals.



### DPOS (continued)

- In Delegated POS (DPOS), stake-holders don’t vote on the validity of the blocks
    themselves, but vote (proportionately weighted based on the stake) to elect
    delegates to do the validation on theirbehalf.
- The major difference between POS and DPOS is that POS is a direct democratic
    while DPOS is representative democratic.
- Users can also delegate their voting power to another user who will vote on their
    behalf.


### DPOS (continued)

- **Higher Throughput:** With significantly fewer nodes to validate the block, the
    block could be confirmed quickly, making the transactions confirmed quickly.
- Dishonest delegates could be voted out easily.
- Examples: Steem and BitShares


### Advantages of DPOS

- Scalability
- Speed
- Energy requirements
- Defence
- Decentralization
- Egalitarian


### Disadvantages of DPOS

- The efficient existence of the network involves the involvement and
    coordination of the truly concerned groups through voting in and out, for
    efficient control of panel of witnesses.
- The blockchain of DPOS is vulnerable to classic real life voting flaws. DPOS
    users with small stakes, for example, may decide that their vote does not
    matter in contrast to the votes of larger stakeholders.
- DPOS system are susceptible to centralization as there are small number of
    witnesses.


### Practical Byzantine Fault Tolerance (PBFT)


### PBFT (continued)

- PBFT aims to provide a realistic replication of the Byzantine state machine that
    can run even when malicious nodes are functioning in the system.
- Nodes are sequentially ordered in a PBFT enabled distributed system with
    one node being the main (or the leader node) and others referred to as
    secondary.
- The aim is that all honest nodes, using the majority rule help to find a
    consensus on the state of the system.
- A functional Byzantine Fault Tolerant system will operate as long as the
    maximum number of malicious nodes in the system must not be greater than
    or equal to one third of all nodes.


### PBFT (continued)

- PBFT consists of the following steps in normal case operation at a very high
    level:
    - **Request:** Transaction are sent to the primary by the user
    - **Pre-Prepare:** A proposal consisting of transactions is produced by the primary
       and it is then forwarded to all the replicas.
    - **Prepare:** Upon receiving a proposal, backups will verify it, and if it succeeds, they
       will broadcast prepare message to all other replicas. Backups do nothing if
       verification fails. This is the first round of voting.
    - **Commit:** Upon receiving prepare message from 2/3 of all backups, commit
       messages will now be broadcasted by the replicas. This is the second round of
       voting.
    - **Reply:** The client gets to see the result of consensus algorithm.


### Hyperledger Fabric – PBFT

- Practical Byzantine Fault Tolerance (PBFT) isa replication algorithm to
    tolerate byzantine faults (Miguel and Barbara, 1 999).
- Hyperledger Fabric (Hyperledger, 2015) utilises the PBFT as its consensus
    algorithm, since PBFT could handle up to 1/3malicious byzantine
    replicas.


### Pros and Cons PBFT

Advantages:

- Energy efficiency
- Transaction finality
- Low Reward Variance

Disadvantages:

- Sybil attacks
- Scaling


### Summary

- Delegated Proof of Stake

(DPOS) consensus

- Advantages and

Disadvantages of DPOS

- Practical Byzantine Fault

```
Tolerance (PBFT)
consensus
```
- Advantages and

Disadvantages of PBFT


### References

- Bitcoin and Cryptocurrency Technologies by Arvind Narayanan,

```
Joseph Bonneau, Edward Felten, Andrew Miller and Steven
Goldfeder
```


`


`

## Module 03:

## Other Consensus Part I

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Ripple Protocol Consensus

```
Algorithm (RPCA) or
Ripple Consensus
```
- Paxos, Multi-Paxos and

Epaxos Consensus

- RAFT Consensus
- Proof of Elapsed Time

(POET) consensus


### Ripple Protocol Consensus Algorithm (RPCA)

The terms associated with the Ripple Protocol Consensus Algorithm components
are described below:

- Server
- Ledger
- Last-Closed Ledger
- Open-Ledger
- Unique Node List (UNL)
- Proposers


### Ripple

### Consensus

- How

### does

### Ripple

### work?


### RPCA (continued)

- Ripple (Schwartz et al., 2014) is a consensus algorithm thatutilizes collectively-
    trusted subnetworks within the larger network.
- In the network, nodes are divided into two types: **server** for participating
    consensus process and **client** for onlytransferring funds.
- In contrast to that PBFT nodes must ask every node in the network, each
    Ripple server has a Unique Node List (UNL)to query.


### RPCA (continued)

- UNL is important to the server. Whendetermining whether to put a transaction
    into the ledger, the server would query the nodes inUNL.
- If the received agreements have reached 80%,the transaction would be
    packed into theledger.
- For a node, the ledger will remain correct if the percentage of faulty nodes in
    UNL is less than 20%.


### Paxos

- The replica nominates itself as a leader when a client executes a command on
    a given replica.
- This execution will be tagged with the highest number seen by this replica.
- A 2-phase commit protocol, which is detailed below, achieves consensus
    among replicas.
    - Prepare phase
    - Commit phase
- Disadvantages:
    - Dueling Leaders
    - Livelock


### Paxos

Two Phase Consensus


### Multi-Paxos

- The naive way to go about finding a sequence of numbers would be to run
    paxos several times, because one round of paxos results in a decision of one
    value.
- In this case, one optimization that can be done, assuming a single stable
    leader and skip the prepare phase.
- There is no need to continue sending out proposal numbers if we believe that
    the leadership will stay ‘sticky’.
- The first proposal sent out will never be ‘overridden’ because there is only one
    leader.


### Multi-Paxos (continued)

- Therefore, we have to perform the prepare step once.
- We can only send the ACCEPT messages in subsequent round of Paxos, with
    ‘n’ as the proposal number used in the original PREPARE request and an
    additional parameter indicating the sequence number (the current round in
    which we are).


# Multi-Paxos

```
Two Phase Consensus
```


### RAFT

- Raft is based on a model of consensus which is guided by a leader, where a
    distinguished leader is chosen and that leader is entirely responsible for the
    management of the cluster.
- A replicated log is maintained by the leader through all of the nodes
    comprising the Raft cluster.
- It involves Leader election, Commencing an Election, The Election Procedure,
    Log Replication and Safety.


### RAFT (continued)


### Advantages of RAFT

- Ease of Understanding
- Ease of Implementation
- Independently approachable Sub-problems
- Safety from Failures
- RPCs (remote procedure calls)
- Employs latest concepts
- Fairness
- Availability of Implementation


### Disadvantages of RAFT

- RAFT is strictly a single leader protocol and if traffic is more in the network it
    can choke the system. There are several paxos algorithm variants that tackle
    with this bottleneck.
- There are theories that are assumed to be acting, such as the non occurrence
    of byzantine errors, which decrease the applicability in real life.
- RAFT is a more specialised approach to a subset of issues that occur when
    reaching a consensus.


### Proof of Elapsed Time (POET)

- Each participant node in the blockchain network has to wait for a randomly
    chosen time period and the first node that completes the designated wait
    time wins the new block.
- For that specified duration, each node in the blockchain network generates a
    random wait time and goes to sleep.
- The one who wakes up first, has the shortest waiting time, will commits to the
    blockchain with a new block, transmitting the appropriate information to the
    entire peer network.


### POET (continued)

- For the discovery of the next block, the same cycle then repeats. Two
    significant factors need to be ensured by the POET network consensus
    algorithm.
       - First the system ensures that in order to win, the competing nodes actually
          choose a time that is genuinely random and not a shorter period which is not
          deliberately selected by participants.
       - Second the process establishes that the waiting period has already been met
          by the winner.


### POET (continued)

- Often used on the permissioned blockchain networks.
- Each node in the blockchain network generates a random wait time and goes
    to sleep for that specified duration.
- The one to wake up first –that is, the one with the shortest wait time – wakes up
    and commits a new block to the blockchain, broadcasting the necessary
    information to the whole peer network.
- The same process then repeats for the discovery of the nextblock.


### POET (continued)

- The POET network consensusmechanism needs to ensure two important
    factors:
    - First, that the participating nodes genuinely select a time that is indeed random
       and not a shorter duration chosen purposely by the participants in order to win,
       and
    - Second, the winner has indeed completed the waitingtime.


### POET (continued)

- The POET concept was inventedduring early 2016 by Intel.
- It offers a readymade high-tech tool tosolve the computing problem of
    "random leader election."


### Advantages of POET

- Low Power Consumption
- Higher Resource Efficiency
- Safety from external attack
- Transparency
- Cost Efficient


### Summary

- Ripple Protocol Consensus

```
Algorithm (RPCA) or
Ripple Consensus
```
- Paxos, Multi-Paxos and

Epaxos Consensus

- RAFT Consensus
- Proof of Elapsed Time

(POET) consensus


### References

- https://ripple.com/files/ripple_consensus_whitepaper.pdf
- How does Ripple Protocol Consensus Algorithm work? -GeeksforGeeks
- https://www.alibabacloud.com/blog/paxos-raft-epaxos-how-has-

```
distributed-consensus-technology-evolved_597127
```


`


`

## Module 03:

## Other Consensus Part II

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Proof of Burn (POB)
- Proof of Importance (POI)
- Proof of Capacity (POC)
- Proof of Deposit (POD)
- Proof of Activity
- Proof of Authority (POA)
- Proof of Retrievability

(POR)

- Proof of Luck (POL)
- Zero Knowledge Proof


### Proof of Burn (POB)

- The method of burning coins consists of sending them to a public address
    which is verifiable, where they are inaccessible and useless.
- Usually, these addresses also known as eater addresses are generated
    randomly without being associated with any private key.
- The coin burning method decrease the supply of the market and induces
    economic scarcity, leading to a possible rise in its value.
- But more than that, coin burning is another way to make investments to the
    network security.


### POB (continued)

- Method for distributed consensus and an alternative to Proof of Work and
    Proof of Stake.
- Miners prove that they have destroyed a quantity of coins, for example by
    sending them to a verifiably unspendable address.
- Slimcode implemented this approach in 2014 but has recently been
    discontinued.


### Pros and Cons of POB

Advantages:

- Increased sustainability and reduced
    power consumption
- Mining hardware is not required. Coin
    are virtual mining rigs.
- The circulating supply is reduced by the
    Coin Burns
- The miners are encouraged for long
    term commitment
- The circulation and mining of coins is
    less centralized

```
Disadvantages:
```
- Less transparent
- Lower speed
- Less Eco-Friendly
- Scalability



### Proof of Capacity (POC)

- Sometimes stake could be otherthings.
- For example, proof of capacity (burstcoin, 2014).
- In proof of capacity, participants vote on new blocks weighted by their capacity
    to allocate a non-trivial amount of diskspace.
- Other Examples: PermaCoin,SpaceMint


### POC (continued)

- A two step process involving plotting and mining in the proof of capacity
    protocol.
- First, the hard drive is plotted using a repeated data hashing, including a
    miners account, the list of all possible nonce values is generated.
- Each of these plots contains 8192 hashes, numbered from 0 to 8191.
- All of the hashes are paired into ‘scoops’, which suggests that they combine
    neighbouring hashes to form a pair of two.
- Hash 0 and 1 constitute scoop 0, hash 2 and 3 constitute scoop 1, and so on.


### POC (continued)

- The second stage includes the actual mining process, during which a scoop
    number is measured by a miner.
- If a miner starts the mining operation and produces a scoop number 38, the
    miner will then go to scoop number 38 of nonce 1 and calculate a deadline
    value using the data of that scoop.
- The method is repeated for calculating the deadline on the hard drive of the
    miner for each nonce held upon.


### POC (continued)

- PermaCoin repurposes Bitcoin’s POWwith a more broadly useful task: providing
    a robust, distributedstorage.
- SpaceMint employs a consensus protocol based on a non-interactive variant of
    proof-of-capacity (calledproof-of-space).

Applications of POC:

- SpaceMint
- PermaCoin
- BurstCoin


### Advantages of POC

- Lower energy consumption.
- Better than POS due to the availability and cheap price of disks,
    which imply lower barrier to entry.
- It is more eco-friendly. It’s apparently up to 30 times more energy
    efficient than the bitcoin cryptocurrency’s ASIC based mining.
- Users do not need specialized hardware or constant hard drive
    upgrades and can mine using their existing hardware. Any regular
    hard drive, including those with Android-based systems, can be used
    by POC.
- Data from mining can be quickly wiped off and drive can be reused
    for some other purpose of storing data.


### Disadvantages of POC

- The system has not been adapted by many developers. So, there is lack
    of experienced people.
- There is a possibility for the mining process to be affected by malware.
- A competition to produce higher capacity hard drives may arise by the
    widespread adoption of POC algorithm.


### Proof of Deposit (POD)

- Miner’s ‘lock’ a certain number of coins, which they cannot spend for the
    durationof their mining.
- One such system is Tendermint, where a miner’s voting power is proportional to
    the number of coins they havelocked.
- Deposit could be revoked ifthey misbehaved.


### Proof of Activity

- To combine the benefits of POW and POS, proof of activity (Bentov et al., 2014)
    isproposed.
- In proof of activity, a mined block (based on POW) needs to be signed by N
    validators (POS) to be valid.
- In that way, if some owner of 50% of all coins exists, he / she cannot control the
    creation of new blocks on his / her own.
- Since POA marries POW and POS, it draws criticism for its partial use of
    both.


### Proof of Authority (POA)

- leverage's identity instead of coins
- the POA consensus algorithm is usually reliant upon:
    - valid and trustworthy identities: validators needto confirm their real
       identities.
    - difficulty to become a validator: a candidate must be willing to invest money
       and put his reputation at stake. A tough process reduces the risks of
       selecting questionable validators and incentivize a long-term commitment.
    - a standard for validator approval: the method for selecting validators must
       be equal to allcandidates.


### POA (continued)

- Kovan and Rinkeby, the two Ethereum testnets, alsouse POA as a consensus
    mechanism.
- Microsoft Azure is another example where the POA is beingimplemented


### Proof of Retrievability (POR)

- POR offers standard functions for issuing and verifying file proofing on a
    remote host, i.e. a peer.
- This is implemented by the protocol through a challenge-response
    relationship called audit or heartbeat.
- This allows the file owner (client) to check the host (peer) for the integrity and
    availability of data.
- The client initially wants to store a file ‘F’ on the network ‘N’. First, the file is
    encoded and propagated across the network.
- The file is stored by several peers and by issuing challenges to the peers, the
    file owner / client can check the integrity of the file.
- To validate honesty, the client receives the answer to those challenges.


### Proof of Luck (POL)

- For each round, the protocol send the signals to all the participants to commit
    all uncommitted transactions to a new block and a numeric value is then given
    according to the version block.
- An election is then carried out where all the participants vote for a number
    randomly and the one with the highest vote wins (luckiest).
- The luckiest block is recognized as the next block in the chain by the ledger.
- As soon as they obtain the luckiest block, to minimize network congestion,
    other participants quit mining and broadcast their own block.


### Advantages of POL

- The confirmation of transaction is very fast and deterministic.
- This protocol is very effective in terms of energy and network
    communications.
- It is resistant to custom hardware that are not commonly available.
- The blockchain cannot be controlled by an attacker controlling under
    the threshold of TEEs.
- Without controlling most of the CPUs and without breaching the TEE
    platform, an attacker cannot control the blockchain.
- A synchronized clock is not required between the participants.



### Consensus: A Comparison


### Conclusion

- We have discussed various consensus algorithms and their significance
    in blockchains along with advantages and disadvantages of using them
    in Blockchain Applications.
- The algorithm must be chosen based on the best fit for the applications
    and its use cases.


### Proof of X: Attacks

- nothing-at-stake attack: All miners are incentivized to extend every potential

```
fork. Since it is computationally cheap to extend a chain, inthe case of forks, rational miners mine on top of
every chain to increase the likelihood of getting their block in the rightchain.
```
- grinding attack: A miner re-creates a block multiple times untilit is likely that the miner

```
can create a second block shortlyafterwards.
```
- long-range attack: An attacker can bribe miners to selltheir private keys. If these

```
keys had considerable value in the past, then the adversary can mine previous blocks and re-write the
entire history of the blockchain.
```

### Summary

- Proof of Burn (POB)
- Proof of Importance (POI)
- Proof of Capacity (POC)
- Proof of Deposit (POD)
- Proof of Activity
- Proof of Authority (POA)
- Proof of Retrievability

(POR)

- Proof of Luck (POL)
- Zero Knowledge Proof


### References

- Bitcoin and Cryptocurrency Technologies by Arvind Narayanan,

```
Joseph Bonneau, Edward Felten, Andrew Miller and Steven
Goldfeder
```


`


`

## Module 04:

## Cryptographic Primitives

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Cryptographic Identity
- Cryptographic Primitives
    1. Cryptographic Hash
       Functions
    2. Digital Signatures
- Optional Enhancements


## Setting the Agenda

- There are multiple blockchains and of multiple types
- Cryptography is used in each one of them
- But the usage is not uniform. Some primitives are used

in some blockchains but not in others

- Our goal is to have a look at some of the most common

cryptographic primitives used in blockchains


### The “identity”

- Bitcoin is the most well known blockchain
- Can be used to transfer “money” from one “account” to

another

- How do we bind a person’s “identity” with a bitcoin

“account”?

- Similar to binding a bank account number with a person
    - e.g. The KYC process used by your bank when you
       open an account
          4


### Cryptographic Identity

- Solution: Each user creates an identity for himself / herself.
- The identity consists of a 256 - bit random string.
- But then, how to protect the identity from being stolen?
- Have a secret random string which is needed whenever you
    wish to “use” the identity.
- Public key = known to everyone
- Private key = proof of ownership of public key = Only owner

knows


### Elliptic Curve Group

- Group operation is denoted by +
- Easy to compute P+Q
- Let Q = k P for a scalar k
- ECDLP: Find k

```
6
```

### Bitcoin’s use of EC

- Take a prime of about 256 bits
- p = 2256 – 232 – 29 – 28 – 27 – 26 – 24 – 1
- Consider the (discrete)curve
- 𝑦! = 𝑥" + 7 𝑚𝑜𝑑 𝑝
- Known as secp256k1 curve
- Take a fixed-point g =(x,y) on the curve,
    - easy to compute Q = (x’,y’) = kg
- Private key = k, public key = k g

```
7
```

### Bitcoin addresses

- A transformed version of the public key is the bitcoin address
- Anyone can send coins to an address
- To spend the coins, you require the private key

corresponding to that address

- If the private key is lost, then all the coins with the

corresponding public key are lost

- Address = RIPEMD160(SHA256(public key))


### Cryptographic Hash Functions

- The first cryptographic primitive is a cryptographic hash function.
- A hash function is a mathematical function with the
    following 3 properties:
       - Its input can be any string of any size.
       - It produces a fixed size output. For the purpose of making the
          discussion concrete,we will assume a 256 ‐bit output size. How-
          ever, our discussion holds true for any output size as long as it is
             sufficiently large.
       - It is efficiently computable. Intuitively this means that for a given
          input string,you can figure out what the output of the hash
          function is in a reasonable amount of time.


- Cryptographically secure hash functions require 3 additional
    properties.
       - collision‐resistance,
       - hiding and
       - puzzle‐friendliness.
- Bitcoin uses SHA-256 hash function. SHA-256 uses the
    Merkle-Damgard transform to turn a fixed-length collision-
    resistant compression function into a hash function that
    accepts arbitrary-length inputs. The input is ‘padded’ so that
    its length is a multiple of 512 bits.

### Cryptographic Hash Functions


### Cryptographic Hash functions

- A hash function is a function with the following syntax
- 𝐻: 0,1 ∗ → 0,1 $ 𝑛 is a few hundred bits
- Security property required from a Cryptographic hash

function:

- Preimage resistance
- That is, given x, finding H(x) is easy, but given y = H(x), it should
    be hard to find an x’ such that H(x’) =y
- This is crucial to have a “public ledger”
- Each block contains a list of“transactions”
- If even a single transaction changes in one block, all subsequent
    hashes will change
       11


### Hash Pointers & Data Structures

- A hash pointer is a pointer to where data is stored together

```
with a cryptographic hash of the value of that data at some
fixed point in time.
```
- Whereas a regular pointer gives you a way to retrieve the

```
information, a hash pointer also gives you a way to verify that
the information hasn’t changed.
```
- Use hash pointers to build all the kinds of data structures.

```
Intuitively, we can take a familiar data structure that uses
pointers such as a linked list or a binary search tree and
implement it with hash pointers.
```
- Linked list using hash pointers is called the **Blockchain**.


### Digital Signatures

- The second cryptographic primitive is digital signatures.
- Digital signature scheme:
- A digital signature scheme consists of the following three algo

rithms:

- (sk, pk) := generateKeys(keysize)
    The generateKeys method takes a key size and generates a
    key pair. The secret key
    sk is kept privately and used to sign messages. pk is the
    public verification key that you give to everybody. Anyone
    with this key can verify your signature.


- sig := sign(sk, message)

```
The sign method takes a message and a secret key, sk, as
input and outputs a signature for the message under sk.
```
- isValid := verify(pk, message, sig) The verify method takes

```
a message, a signature, and a public key as input. It returns
a Boolean value, isValid, that will be true if sig is a valid
signature for message under public key pk, and false
otherwise.
```
### Digital Signatures


## Validity of Transactions

- A transaction: Transfer x coins from A to B.
- Next transaction: B wishes to use x coins.
- B must prove that she has the private key corresponding to

the public key for address of B.

- This is done by a Digital signature
- Bitcoin uses ECDSA


### Digital Signatures

- These are analogous to paper signatures in the physical world
- But unlike paper signatures which are dependent on an

```
identity, digital signatures must depend on (identity,
document) pair
```
- Requirements:
    - Sig Gen: Only the rightful identity should be able to
       produce a valid signature
    - Sig Verify: Anyone should be able to verify
- And probability of a “forgery” should be negligible
- Syntax: Sig = SignAlgo(Hash(transaction), private key)
- ... where Sig is of the form (R,S)


## Digital Signatures

- They not only authorize the spending
- Also provide:
    - Undeniability: Can’t repudiate the transaction
       later
    - Integrity: Transaction can’t be modified AFTER it
       has been signed


### Hash Functions Again

- Required properties of hash functions:
    - Preimage resistance: for integrity of theblockchain
    - Collision resistance: for no forgery against digital signatures
    - Random oracle behavior: for generating puzzles for mining
    - ...
- Syntax: 𝐻: 0,1 ∗ → 0,1 $ 𝑛 is a few hundred bits

```
18
```

### MD Theorem and Hash Function Constructions

- [Crypto 1989] If f is collision resistant then so is the MD

construction.

- The problem of designing a good hash function reduces to

the design of a good compression function f.

- MD4, MD5, SHA1, SHA2 (SHA256, SHA224, SHA512,

SHA384) are all based on this principle

- MD4, MD5, SHA1 are all broken. Bitcoin uses SHA2 and

RIPEMD.

- SHA3 exists but not used widely.


### Recovering private key in ECDSA

- The ephemeral secret k should not be reused
- Reuse of k allows recovery of the private key
- Solution: Use a deterministic method to generate k
- Java “SecureRandom” library had a bug, producing colliding

k values

- Used in 2013 to steal bitcoins from Andoid implementations



### Story so far ...

- ECC
    - For addresses
    - For digital signatures
- Cryptographic Hash

functions

- For proof of work
- For digital signatures
- Hash functions also

provide

- Tamper-proofing
- Public verifiability


### Optional Enhancements

- Different types of signature

schemes

- Commitment schemes
- Accumulator
- zkProofs
- These enhace the privacy and anonymity of

blockchain


### Different types of Signature Schemes

- Group signatures: There is a leader and a set of

members

- Ring signatures: No leader. Anonymous signature from

the ring

- Multi signatures: Multiple people signing a transaction.
- More efficient (time and/or space) than individual parties

signing


### Commitment

- A commitment scheme allows a party to “commit” to a value without

revealing it immediately.

- Twophases:

```
com = Commit(m)
Verify(com, m) = {True,False}
```
- **Commit** : Output a “random looking”value
- **Reveal** : Verify a commitment
- Security notions:
- **Hiding** : Given com, an adversary should not be able to getm
- **Binding** : Given com (for a message m), the user should not be able to produce
another message m’ such that Commit(m’) = com


### Commitment Scheme

- Example use:
- Lottery
- Coin flipping on telephone
    - Alice and Bob wish to simulate a coin flip
    - Alice flips the coin, checks the result, and sends
       commit(result)
    - Bob flips the coin, reports the result to Alice
    - Alice reveals her coin-toss result, Bob verifies the same
    - If results are matching then Bob wins, else Alice wins


- Stateless blockchain – replace the blockchain storage with

commitments

- Algorand has a new construction of commitment scheme –

Pointproof

### Commitment Scheme


### Accumulator

- A problem with bitcoin is loss of privacy due to link

traceability.

- Zerocoin solves this problem by using “accumulators” to

eliminate traceability on transactions

- Accumulator: One way membership function to test if a

```
candidate is a member of a set, without revealing individual
members of the set
```
- The idea was originated by Benaloh and de Mare [Eurocrypt

1993]

- Zerocoin: Anonymous distributed eCash from bitcoin


### Zero Knowledge Proofs

- Argument which convinces a skeptical verifier to accept the

validity of some statement

- But does not let the verifier learn anything more
- e.g. To prove that a number is composite without revealing its

factors

- Used in Zcash to allow transactions to remain fully

```
encrypted while verifying that they follow consensus rules of
the system.
```

## ZKP

```
30
```

### Summary

- Cryptographic Identity
- Cryptographic Primitives
    1. Cryptographic Hash
       Functions
    2. Digital Signatures
- Optional Enhancements


### References

- Bitcoin and Cryptocurrency Technologies by Arvind

```
Narayanan, Joseph Bonneau, Edward Felten, Andrew Miller
and Steven Goldfeder
```


`


`

## Module 04:

## Bitcoin Block Structure

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Hash Pointers and Data

Structures

- Linked List with Hash

Pointers = “Blockchain”

- Binary Tree with Hash

Pointers = “Merkle Tree”


### Hash Pointers and Data Structures

- Hash pointer is:

```
* pointer to where some info is stored,
* (cryptographic) hash of the info
```
- If we have a hash pointer, we can

```
* ask to get the info back, and
* verify that it hasn’t changed
```

### Hash Pointers and Data Structures (continued)


## Key Idea:

- Build data structures with hash pointers


### Linked List with Hash Pointers = “Block Chain”


### Detecting Tampering


### Binary Tree with Hash Pointers = “Merkle tree”


### Merkle Tree with even number of transactions


### Merkle Tree with odd number of transactions


### Proving Membership in a Merkle Tree


### More generally ...

Can use hash pointers in any pointer-based data structure that

has no cycles


### Summary

- Hash Pointers and Data

Structures

- Linked List with Hash

Pointers = “Blockchain”

- Binary Tree with Hash

Pointers = “Merkle Tree”


### References

- Bitcoin and Cryptocurrency Technologies by Arvind Narayanan,

```
Joseph Bonneau, Edward Felten, Andrew Miller and Steven
Goldfeder
```
- Merkle Tree in Blockchain (Part 5- Blockchain Series) | by

Techskill Brew | Blockchain 101 by Techskill Brew | Medium



`


`

## Module 04:

## Double Spend Problem

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Simple Cryptocurrencies
    - Goofy Coin – double spend
       problem
    - Scrooge Coin – double
       spend problem & without
       centralized bank


Goofy Coin


## Simple Cryptocurrencies

Obvious Approach:

1: Use public keys as addresses

2: Sign to authorize transfer to new address

New coin created [somehow]


### Goofy can create new coins


### A coin’s owner can spend it


### The recipient can pass on the coin again

```
Bob owns it now
```

### Double-Spending Attack


### Double-Spending Attack

The main design challenge in digital currency


### Double Spends Must be Prevented


### Traditional Approach:- Talk to the Issuer


Scrooge Coin


### CreateCoins transaction creates new coins


- PayCoins transaction consumes (and destroys) some coins

and creates new coins of the same total value.


### Immutable coins

- Coins can’t be transferred, subdivided, or combined
- But you can get the same effect by using transactions to

subdivide:

- Create new trans
- Consume your coin
- pay out two new coins to yourself


- Scrooge publishes a history of all the transactions (a block

chain, signed by Scrooge)



### Forking

```
What if Scrooge is malicious?
```
Double –Spending Attack


Crucialquestion:

Can we descroogify the
currency, and operate
without any central,
trusted party?


### Summary

- Simple Cryptocurrencies
    - Goofy Coin – double spend
       problem
    - Scrooge Coin – double
       spend problem & without
       centralized bank


### References

- Bitcoin and Cryptocurrency Technologies by Arvind Narayanan,

```
Joseph Bonneau, Edward Felten, Andrew Miller and Steven
Goldfeder
```


`


`

## Module 04:

## Bitcoin’s Approach

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Bitcoin’s approach:

Global Ledger

- How to achieve

consistency?

- The Path to

```
Decentralization –
Technology & Incentive
Design
```


## How to achieve consistency?

```
Distributed P2P Network
```

### An Example of Public Ledger from Banking Sectors


### An Example of Public Ledger from Banking Sectors


### An Example of Public Ledger from Banking Sectors


### An Example of Public Ledger from Banking Sectors


###### The Path to Decentralization – Technology & Incentive

###### Design


### Summary

- Bitcoin’s approach:

Global Ledger

- How to achieve

consistency?

- The Path to

```
Decentralization –
Technology & Incentive
Design
```

### References

- Bitcoin and Cryptocurrency Technologies by Arvind Narayanan,

```
Joseph Bonneau, Edward Felten, Andrew Miller and Steven
Goldfeder
```


`


`

## Module 04:

## Bitcoin P2P Network

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Bitcoin P2P network
- Joining the Bitcoin P2P

network

- Transaction Propagation

(Flooding)


### Bitcoin P2P network

- Ad-hoc protocol (runs on TCP port8333)
- Ad-hoc network with randomtopology
- All nodes are equal
- New nodes can join at any time
    - Network Changes over time – dynamic
- No explicit way to leave network
    - Forget non-responding nodes after 3 hours


### Joining the Bitcoin P2P network


### Transaction Propagation (Flooding)


### Nodes may differ on transaction pool


### Summary

- Bitcoin P2P network
- Joining the Bitcoin P2P

network

- Transaction Propagation

(Flooding)


### References

- Bitcoin and Cryptocurrency Technologies by Arvind

```
Narayanan, Joseph Bonneau, Edward Felten, Andrew Miller
and Steven Goldfeder
```


`


`

## Module 04:

## Bitcoin Mining

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Blockchain Working

Principle

- Block Structure
- Mining Bitcoins in 6 easy

steps


### Blockchain Working Principle


## Blockchain Working Principle


### Block Structure


### Blockchain Working Principle


### Blockchain Working Principle


### Mining Bitcoins in 6 easy steps

1: Join the network, listen for transactions.

- Validate all proposedtransactions.
2: Miners will assemble them into newblocks and solve puzzle.
3: On success, broadcast the newblocks.
4: Listen for new blocks, maintainblockchain.
- When A new block is proposed, validate it.

5: Find the nonce to make your block valid.

6: Hope everybody accepts your new block.

Profits! Rewards and Transaction Fees!


### Summary

- Blockchain Working

Principle

- Block Structure
- Mining Bitcoins in 6 easy

steps


### References

- Bitcoin and Cryptocurrency Technologies by Arvind

```
Narayanan, Joseph Bonneau, Edward Felten, Andrew Miller
and Steven Goldfeder
```


`


`

## Module 04:

## Bitcoin Transactions

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- An account-based ledger

(not Bitcoin)

- Merging Value
- Joint Payment


### An account-based ledger ( not Bitcoin)


## An account-based ledger ( not Bitcoin)


### Merging Value


### Joint Payment




### Summary

- An account-based ledger

(not Bitcoin)

- Merging Value
- Joint Payment


### References

- Bitcoin and Cryptocurrency Technologies by Arvind

```
Narayanan, Joseph Bonneau, Edward Felten, Andrew Miller
and Steven Goldfeder
```


`


`

## Module 04:

## Bitcoin Blocks

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Bitcoin blocks
- The Real Deal: A Bitcoin

Block


### Bitcoin blocks

- Why bundle transactions together?
    - Single unit of work for miners
    - Limit length of hash-chain of blocks
       - Faster to verify history


## Bitcoin Block Structure


### Bitcoin Block Structure


### The Real Deal: A Bitcoin Block


### The Real Deal: A Bitcoin Block Header


### Blockchain Working Principle


### Summary

- Bitcoin blocks
- The Real Deal: A Bitcoin

Block


### References

- Bitcoin and Cryptocurrency Technologies by Arvind

```
Narayanan, Joseph Bonneau, Edward Felten, Andrew Miller
and Steven Goldfeder
```


`


`

## Module 04:

## Bitcoin Consensus

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Consensus Algorithm

(simplified)

- Hashcash: Proof of Work
- Bitcoin: Proof of Work
- Block Propagation


### Consensus Algorithm (Simplified)

1. New transactions are broadcast to all nodes
2. Follow Flooding/Gossip Protocol to broadcast
3. Some nodes collect new transactions into a block
4. In each round a random node gets to broadcast its
    block
5. Other nodes accept the block only if all transactions in it are

valid (unspent, valid signatures)

6. Nodes express their acceptance of the block by including its
hash in the next block they create

```
Mining
Process
```
```
Consensus
Agreement
```

## HashCash: Proof of Work

- Based on the idea of HashCash, a Proof of Work concept

```
invented by Adam Back in 1997
(http://www.hashcash.org/papers/hashcash.pdf)
```
- Originally proposed as an anti-spam throttlingmechanism
- The core idea is that before accepting a transaction, the

```
sender must first demonstrate a “cost” via a computationally
“hard” problem that can simultaneously be easilyverified.
```
- This generally referred to as a “Proof of Work”.


### HashCash: Proof of Work

- HashCash Cost Function: Interactive Vs. Non-interactive
- _s_ : service name


### HashCash: Proof of Work

- HashCash Cost Function: Interactive Vs. Non-interactive


### The real deal: a Bitcoin block


### Proof of Work


### Finding a Valid Block: Proof-of-Work


### Coinbase


### Block Propagation Nearly Identical


```
The relation between the block
size and the time it took to reach
25% (red), 50% (green), and75%
(blue) of monitorednodes
```
Source: Yonatan Sompolinsky and Aviv Zohar: “Accelerating Bitcoin’s Transaction Processing” 2014


### The real deal: a Bitcoin block


### Proof of Work


### Summary

- Consensus Algorithm

(simplified)

- Hashcash: Proof of Work
- Bitcoin: Proof of Work
- Block Propagation


### References

- Bitcoin and Cryptocurrency Technologies by Arvind

```
Narayanan, Joseph Bonneau, Edward Felten, Andrew Miller
and Steven Goldfeder
```


`


`

## Module 05:

## Information on Bitcoin

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- About Bitcoin
- Bitcoin Forks
- Alternate Coins (Altcoins)
- Fiat Currency


###### About Bitcoin

- Crypto Identifier: BTC
- Crypto Symbol:
- Bitcoin Explorer: https://www.blockchain.com/explorer
- Bitcoin Website: https://bitcoin.org/en/
- Bitcoin Core Software: https://bitcoin.org/en/bitcoin-core/
- Different software versions are available for:
- Bitcoin Apps: https://bitpay.com/wallet/
- Run Main (Live) Bitcoin network command: ./bitcoin-qt


### Bitcoin Testnet

- Testnet Bitcoin Symbol:
- Testnet Explorer:

https://www.blockchain.com/explorer/assets/btc-testnet

- Same software is used in main and test networks
- Run Test Bitcoin network command: ./bitcoin-qt -testnet


### Bitcoin Forks

```
Soft Forks
```
- Consensus rules become _more_
    restrictive after the fork.
- Legacy blocks are _incompatible_
    with soft fork rules.
- Soft fork blocks are _compatible_
    with legacy rules.
- Backwards- _compatible_ (i.e.,
    clients following old rules can
    follow the new rules as well).

```
Hard Forks
```
- Consensus rules become _less_
    restrictive after the fork.
- Legacy blocks are _compatible_ with
    hard fork rules.
- Hard fork blocks are _incompatible_
    with legacy rules.
- Backwards- _incompatible_ (i.e.,
    clients following old rules can’t
    follow the new rules as they find
    the new rules invalid in certain
    circumstances)


###### Bitcoin Forks (continued)


### Bitcoin Forks (continued)


###### Comparison of Forked Bitcoins


### New Cryptos due to Forking

1. Bitcoin (BTC) –(January 3rd, 2009)
    o Bitcoin XT –Fork of Bitcoin (June 10th, 2014)
    o Bitcoin Unlimited (BU) – Fork of Bitcoin (March 11th, 2016)
    o Bitcoin Classic –Fork of Bitcoin (November 2016)
2. Bitcoin Cash (BCH) – Fork of Bitcoin (August 1st, 2017)
    o Bitcoin SV (BSV) – Fork of Bitcoin Cash (November 15th, 2018)
3. Bitcoin Gold (BTG) –Fork of Bitcoin (November 12th, 2017)
4. Wrapped Bitcoin (WBTC)


###### Alternate Coins (Altcoins)

- Altcoin is not a real cryptocurrency.
- Every other cryptocurrency apart from Bitcoin is known Altcoin.
- Altcoins are referred to as Bitcoin alternatives because, at least to some
    extent, most altcoins hope to either replace or improve upon at least one
    Bitcoin component.
- [http://www.coingen.io](http://www.coingen.io) website is used to
    - Automate the process of minting any altcoin
    - Automate the process of launching a new altcoin for a small fee based on
       Bitcoin or Litecoin
    - Litecoin changed some hard-coded parameters of Bitcoin using the above
       principle and is the most successful one.


###### Fiat Currency

- Fiat currency is backed by a country's government instead of a physical
    commodity (tangible asset such as gold or silver) or financial instrument.
- Fiat currency is declared as legal tender by the government.
- It is printed or minted by the Central Bank. In India, Reserve Bank of
    India (RBI) is the Central Bank.
- Fiat Currency example: Indian Rupee, US Dollar, Euro, Yuan, Yen, etc.
- Central Bank Digital Currency (CBDC) is also a Fiat Currency.


### Summary

- About Bitcoin
- Bitcoin Forks
- Alternate Coins (Altcoins)
- Fiat Currency


### References

- Bitcoin and Cryptocurrency Technologies by Arvind Narayanan,

```
Joseph Bonneau, Edward Felten, Andrew Miller and Steven
Goldfeder
```
- https://changelly.com/blog/what-is-proof-of-authority-poa/
- https://www.bitcoinmarketjournal.com/bitcoin-forks/



`


## ` Module 05:

## Limitations and

## Improvements

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Hard-Coded Limits in

Bitcoin

- Throughput Limits in

Bitcoin


### Hard-Coded Limits in Bitcoin

● 10 min average creation time per block

● 1 MB of data per block

● 20,000 signature operations per block

● 100 M _satoshis_ per bitcoin

● 21 M total bitcoins maximum

● 50,25,12.5,6.25... bitcoin mining reward

halves every 4 years

```
These affect economic
balance of power too
much to changenow
```

### Throughput Limits in Bitcoin

```
● 1 MB / block (10 min)
● > 250 bytes / transaction
● 7 transactions / sec ☹
```
Compare to:

● VISA: 2,000-10,000 transactions / sec

● PayPal: 50- 100 transactions / sec


### Summary

- Hard-Coded Limits in

Bitcoin

- Throughput Limits in

Bitcoin


### References

- Bitcoin and Cryptocurrency Technologies by Arvind Narayanan,

```
Joseph Bonneau, Edward Felten, Andrew Miller and Steven
Goldfeder
```


`


`

## Module 05:

## Mining (Target) Difficulty

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Mining Difficulty
- CPU Mining
- Setting the Mining

Difficulty

- Mining Difficulty Over

Time


### Mining Difficulty (Max Target)


### Mining Pseudocode


### CPU Mining

**while (1) {**

```
HDR[kNoncePos]++;
IF (SHA256(SHA256(HDR)) < (65535 << 208) /DIFFICULTY)
return;
}
```
- Hashes are 256-bit integers. So, TOTAL output size:2^256.
- The current TARGET is “max_target / difficulty”, where max_target is
    (65535 *2^208).
- Therefore, fraction of output space is TARGET / TOTAL. Therefore,
    TOTAL / TARGET = (2^256 * difficulty / max_target) no. of hashes are
    needed on average to find a block.


### CPU Mining (continued)

- This is done over 600 sec, considering previous 2016blocks.
- Global Hashrate:
    - (2^256 * difficulty / max_target) / 600
    - = (2^256 * difficulty / 65535 *2^208) / 600
    - = (2^48 * difficulty / 65535) / 600
    - = difficulty *7158388.055



### Setting the Mining Difficulty

- Nodes automatically re-calculate the target every two weeks
- Goal: average time between blocks = 10 minutes

```
Prob (Alice wins next block) =
fraction of global hash power she controls
```
```
Alice with 0.1% of total hash power will find roughly one in
every 1000 blocks.
```

### Setting The Mining Difficulty

- Every two weeks,compute:

next_difficulty = current_difficulty * (2 weeks) / (time to mine last 2016 blocks)

```
Expected number of blocks in 2 weeks at 10minutes/block
```

### Mining Difficulty Over Time


### Time to find a block


### Summary

- Mining Difficulty
- CPU Mining
- Setting the Mining

Difficulty

- Mining Difficulty Over

Time


### References

- Bitcoin and Cryptocurrency Technologies by Arvind Narayanan,

```
Joseph Bonneau, Edward Felten, Andrew Miller and Steven
Goldfeder
```
- https://bitcoinwisdom.com/bitcoin-btc-price-prediction/



`


`

## Module 05:

## Keys and Address

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Public Key
- Private Key
- Address
- Comparison of Keys /

Address


### Public / Private Key Pairs

- Create a public / private key pair on your own, download a

```
program that randomly creates private keys or purchase a
hard wallet such as Trezor or Ledger, which generates private
keys based on a seed code.
```
- Private key uses the Elliptic Curve Digital Signature

Algorithm (ECDSA) to create a corresponding public key.


###### A Bitcoin transaction

- Once the public / private key pair is ready, you are ready to
    join the network and receive bitcoin provided you have a valid
    address.
- Public key is hashed into a pubkeyhash and converted to a
    base58check format, which generates the addresses you see
    today that start with a ‘1’ or ‘3’.

Private Key Public Key PubKeyHash AddressBitcoin

```
ECDSA Hashed base58check
```

### Comparison of Keys / Address

```
Keys /
Address
```
```
Creation
Process
```
```
Algorithm
used
```
```
Reverse
process No of Bytes
```
```
No of
Characters
```
Private Key

```
Random
Number
Generation
```
```
NA NA 32 64
```
```
Public Key From Private Key ECDSA No 64 128
```
```
Public Key
Hash
```
```
From Public
Key SHA256 No^3264
```
```
Address From Public Key Hash
```
```
RIPEMD160 &
base58check
encoding
```
```
Yes 20 40
```

### Summary

- Public Key
- Private Key
- Address
- Comparison of Keys /

Address


### References

- https://medium.com/@blairlmarshall/how-does-a-bitcoin-

transaction-actually-work-1c44818c3996



`


`

## Module 05:

## Storages and Wallets

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Hot Storage
    - Online Wallets aka Cloud
       Wallets
    - Desktop / Mobile Wallets
    - Multi-Signature Wallets
    - Pro, Cons and Risks
- Cold Storage
    - Hardware Wallets
    - Paper Wallets and Risks
    - Pros and Cons
- Private Keys and

Restoration methods


### What is a Cryptocurrency Wallet?

- Acryptocurrency wallet is a digital wallet that you can use to store, send
    and receive various cryptocurrencies.
- The wallet doesn’t exactly “store” your money as a real-world wallet
    does.
- Instead, it saves your public and private keys which in turn helps you
    send and receive money.
- The two basic methods of storage that you can use to store your cryptos
    are hot storage and cold storage.


### Hot Storage Vs Cold Storage

- Hot storage is like the wallets that you carry around in your

pocket.

- The Cold storage is somewhat akin to your savings bank

account.

- If you want to use your currency frequently then you must use

```
hot storage. On the other hand, if you want to store your
money for a long time then you must use cold storage.
```

### Hot Storage

- Hot storage, in simple terms, is when you keep your cryptocurrency in a
    device which is directly connected to the internet. This connection is
    what makes a device “hot”.
- Think of exchange wallets, desktop clients, and mobile wallets (any
    wallet that exists on a device that will ever connect to the internet) as a
    hot wallet.
- Your hot wallet should behave in the same way as a real-world wallet.
    You use it to carry a small amount of cash for ease of access.


### Hot Storage (continued)

- While transacting with hot wallets is very simple, there is a huge
    drawback when it comes to them - they are easily hackable. Recent
    ransomware attacks and previous compromises of large exchanges
    should be sufficient beacons to newcomers.
- Even though you’ll not be storing a great deal of value on your hot
    wallet, it’s vital that you follow the backup steps within the restoration
    section of your wallet to avoid losing funds through human error.
- With the private key, and seed phrase intact, one should be able to
    restore any wallet painlessly enough.


### Pros and Cons of Hot Storage

**PROS:**

- Quick to access funds.
- A wide number of options, and support for different devices.
- User-friendly UIs make sending and receiving simple.

**CONS:**

- Exposed to cybercrime. Sophisticated hackers, ransomware, and other
    malicious actors are a constant threat.
- Damaging the device could destroy the wallet. Without carefully
    backing up private keys, and seed words you could permanently lose
    your cryptocurrency investment.
- You could still lose / damage / have stolen the restoration details.


### Online Wallets aka Cloud Wallets

- These wallets are the easiest to use among all.
- The creation is super simple because it’s basically creating your own
    account on any of the exchange services.
- You can also access this wallet from any server or any device in the
    world, if it is connected to the net.
- One big problem when it comes to online wallets - your private key is
    going to be saved on another server.
- This is basically like serving up your key to hackers on a silver platter.
- Do NOT use online wallets to store huge amounts of your money. Store
    the bare minimum that you need for exchange purposes.


### Desktop / Mobile Wallets

- Desktop or mobile wallets are also popular choices for a hot wallet.
- Desktop wallets are downloaded and installed on a single PC or laptop,
    and they are only accessible from that one device where it was
    downloaded.
- While it is a safer alternative than an online wallet, it can still be very
    inconvenient because you will not get access to your money unless you
    are on the device from which you downloaded the wallet.
- MultiBit and Armory are great examples of desktop wallets.


### Desktop / Mobile Wallets (continued)

- In case of Mobile, you just need to download an app into your phone.
- A great example of this is _Guarda wallet_ has been around for couple of
    years –the cryptocurrency storage that started out as open-source
    single-currency wallets in the times of market needs has now turned into
    a flourishing ecosystem of products and crypto management services.
- The main idea was to make a convenient, fully decentralized and
    versatile crypto wallet suitable for both beginners and advanced users.


### Multi-Signature Wallets

- The easiest way of understanding how a multi-signature

```
(multi-sig) wallet works like is by thinking of a safe which
needs multiple keys to operate.
```
- A multi-signature wallet is great for 2 purposes:

```
1.To create more security for your wallet and save yourself from human
error.
2.To create a more democratic wallet which can be used by one or
more people.
```

**How does multi-signature wallet save you from human error?**

- Let’s take the example of BitGo, one of the premier multi-sig wallet
    service providers in the world.
- They issue 3 private keys. One is held by the company itself; one is held
    by the user and the third one is a backup that the user can keep for
    themselves or give to someone trustworthy for safe keeping.
- To do any sort of transaction in a BitGo wallet you will need at least 2/3
    keys to operate. So even if you have a hacker behind you, it will be
    super difficult for them to get their hands on 2 private keys.
- And on top of that, even if you lose your private key for whatever reason,
    you still have that backup key that you had given to your friend.


### Risks of Hot Storage

- Different hot wallets carry different security risks.
- The least secure are those hosted on Exchange sites.
- By leaving cryptos on an exchange is trusting an unlicensed entity with
    your money. They hold your private keys, and they ward off daily attacks.
    In the past, they’ve even succumbed to such threats.
- Exchanges are a huge target for criminals because they store a lot of
    value. If you’re day trading, this risk is part of the deal. If you’re holding
    long-term, you want to avoid it all together.
- The Bitfinex hack is a great example of the dangers of hot storage. In
    early August 2016, the folks at Bitfinex noticed that several of their
    security measures were being compromised. Before long, over $72
    million worth of BTC had been stolen by a hacker. It was so bad that the
    value of BTC fell 20% within a day.


### Cold Storage

- When you keep your currency in a device which is completely

offline it’s called cold storage.

- For those seeking the most secure form of storage, cold

```
wallets are the way to go. These are best suited to long-term
holders, who don’t require access to their coins for months, or
years at a time.
```
- They aren’t without their own set of risks but if you follow the

```
instructions correctly, and take every precaution possible,
these are greatly minimized
```

### Pros and Cons of Cold Storage

**Pros:**

- A great place to hold large amounts of coin for a long period of time.
- Provides a safety net against hackers and people with malicious intent
    since it is completely offline.

**Cons:**

- It is still susceptible to external damage, theft and general human
    carelessness.
- It is not ideal for quick and daily transactions.
- Setting it up can be a little intimidating for beginners.


### Hardware Wallets

- Hardware wallets are physical devices where you can store your
    cryptocurrency.
- They come in a few forms but the most common is the USB stick style
    typified by the Nano Ledger series.
- Hardware walletsare still prone to compromise.
- Firstly, you’re trusting that the company who made your wallet hasn’t
    logged all the private keys with a plan to raid wallets in the future. This
    applies to those bought from the company themselves, but particularly if
    a hardware wallet has been acquired second hand.
- _Under no circumstances should anyone ever use a pre-owned hardware_
    _wallet._


- Although loss or damage can spell disaster for the unprepared,
    hardware wallets can be restored.
- It is important to back up your hardware wallet, as it is your online hot
    wallets. You should keep restoration details in a safe place that only you,
    and anyone you plan to leave the money to know about.
- It’s also vitally important that you transfer all coins to a new wallet, should
    something unfortunate happen between you and anyone else who
    knows your private keys (spouse, etc.)

Hardware wallet examples: Ledger Nano S, Trezor, Keepkey.

### Hardware Wallets (continued)


### Paper Wallets

- Paper wallets are an offline cold storage method of saving cryptocurrency.
- It includes printing out your public and private keys on a piece of paper which
    you then store and save in a secure place.
- The keys are printed in the form of QR codes which you can scan in the future
    for all your transactions.
- The reason why it is so safe is that it gives complete control to you, the user.
    You do not need to worry about the well-being of a piece of hardware, nor do
    you have to worry about hackers or any piece of malware. You just need to take
    care of a piece of paper.


### Paper Wallet Risks

- **Coercion:** There are always going to be people willing to break the law
    to get at something valuable. They don’t know what’s in there but
    presumably, it’s valuable. So, don’t go bragging about your crypto
    investments. It doesn’t matter if it’s online, or in person, it’s never a
    clever idea. Don’t make yourself a target.
- **Fragility:** Paper can be easily damaged, or it can get worn out over
    time. This is why you should always make multiple backups.
- **Stealing:** Since it is written on a piece of paper, anyone who can read it
    or take a photograph of it can steal your money.


- **Not immune to disasters:** It is just a piece of paper; it is not
    immune to natural disasters and can easily be destroyed if you
    have not taken any backups.
- **Type of printer used:** The quality of printer used can also
    have a detrimental effect. Non-laser printers may cause the
    ink to run if the paper gets wet.
- **Human Errors:** Humans are prone to mistakes, and you can
    simply forget the location of your paper or accidentally tear it.

### Paper Wallet Risks (continued)


### Importance of Private Keys and Restoration

### Methods

- Under lock and key: Some prefer to store their private keys in a physical
    location, like a safe. Only those who have ownership of the coins stored
    on the paper wallet must know the combination to the lock.
- Cloud-Based Storage: Like exchanges, existing cloud-based storage
    services are hackable, and can fall victim to malicious attacks. However,
    it’s possible to encrypt the data yourself and store it online. By
    encrypting it, you limit the number of people who can view a document
    in its raw state. Uploading an encrypted version of a private key to the
    web is a suitable option for some.


- Engraving Into Metal: You may also choose to engrave the keys to a
    metal and keep it safe somewhere. The quality of the metal that you
    choose will be paramount here because over time a low-quality metal
    may deteriorate very fast.
- Memory: Things to remember when considering storing private keys
    - Only those that have access to the funds stored must have access to
       the private keys.
    - Most ways of practically recording private keys are potentially lost.
       Think of fire, theft and water damage. If you can engrave metals
       yourself and can store it in a high-quality safe, this is ideal.
    - Multiple safe locations are better than one. Additional locations must
       not compromise security.
- All storage has risks. Minimize them.

### Importance of Private Keys and Restoration

### Methods


### Summary

- Hot Storage
    - Online Wallets aka Cloud
       Wallets
    - Desktop / Mobile Wallets
    - Multi-Signature Wallets
    - Pro, Cons and Risks
- Cold Storage
    - Hardware Wallets
    - Paper Wallets and Risks
    - Pros and Cons
- Private Keys and

Restoration methods


### References

- https://blockgeeks.com/guides/paper-wallet-guide/



`


`

## Module 05:

## Full Nodes & Light Clients

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- How big is the Bitcoin

network?

- Full Nodes
- Thin Clients


### Bitcoin is Bootstrapped


###### What can a “51% attacker” do?


###### How big is the network?

● Impossible to measure exactly

● Estimates up to 1M IP addresses / month

● Only about 5-10k “full nodes”

```
○ Permanently connected
○ Fully-validate
```
● This number may be dropping!


### Fully-Validating Nodes

● Permanently connected

● Store entire block chain

● Hear and forward every node / transaction


### Storage Costs (Size of Blockchain)


### Tracking the UTXO Set

● **U** nspent **T** ransaction **O** utput
○ Everything else can be stored on disk

● Currently ~12 M UTXOs

○ Out of 44 M transactions

● Can easily fit into RAM


### Thin / SPV Clients (Not Fully-Validating)

Idea: don’t store everything

- Store block headers only
- Request transactions as needed
    - To verify incoming payment
- Trust fully-validating nodes
- 1000 x cost savings! (20GB -> 23MB)


### Summary

- How big is the Bitcoin

network?

- Full Nodes
- Thin Clients


### References

- Bitcoin and Cryptocurrency Technologies by Arvind Narayanan,

```
Joseph Bonneau, Edward Felten, Andrew Miller and Steven
Goldfeder
```
- https://www.blockchain.com/en/



`


`

## Module 05:

## Mining Infrastructure

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Evolution of Mining

Infrastructure

- Throughput in CPU Mining


### Evolution of Mining Infrastructure


### Throughput in CPU Mining


### Mining Difficulty “Target”

### (as of March 2015 )


### Mining Bitcoins in 6 Easy Steps


### Summary

- Evolution of Mining

Infrastructure

- Throughput in CPU Mining


### References

- Bitcoin and Cryptocurrency Technologies by Arvind Narayanan,

```
Joseph Bonneau, Edward Felten, Andrew Miller and Steven
Goldfeder
```


`


`

## Module 05:

## Mining Rewards

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Block Reward
- Transaction Fees


### What Can A Malicious Node Do?

Honest nodes will extend the longest valid branch


### From Bob The Merchant’s Point Of View


### Key Security Assumption

Attacks infeasible, if majority of miners weighted by hash power

follow the protocol.


### Security

- Protection against invalid transactions is cryptographic, but enforced by
    consensus
- Denial of Service
- Protection against double-spending is purely by consensus
- You’re never 100% sure a transaction is in consensus branch. Guarantee
    is probabilistic


### Assumption of Honesty is Problematic


### Incentive in Coinbase Transaction


### Incentive 1: Block Reward

- Creator of block gets to
    - include special coin-creation transaction in the block
    - choose recipient address of this transaction
- Value is fixed: currently 6.25 BTC, halves every 4 years
- Block creator gets to “collect” the reward only if the block

ends up on long-term consensus branch!


### There’s a Finite Supply of Bitcoins


### Incentive 2: Transaction Fees

- Creator of transaction can choose to make output value less

than input value

- Remainder is a transaction fee and goes to block creator
- Purely voluntary, like a tip


### Transaction: Information About a Bitcoin Transaction


- Recall:
    - transaction fee = value of inputs – value of outputs
    - fee goes to miner who records the transaction
- Costs resources for
    - peers to relay your transaction & miner to
       record your transaction
- Transaction fee compensates for (some of) these costs


- How are transaction fees set today?
- No fee if
    - transaction less than 1000 bytes in size,
    - all outputs are 0.01 BTC or larger, and
    - priority is large enough
- Priority = (sum of inputAge*inputValue) / (trans size)
- Otherwise, fee is 0.0001 BTC per 1000 bytes Approx

transaction size: 148 Ninputs+ 34 Noutputs + 10


### A Second Look at Transaction Fees


- Generally, higher fee means transaction will be forwarded and

recorded faster.

- If you don’t pay the consensus fee, your transaction will take

longer to be recorded.

- Miners prioritize transactions based on fees and the

priority formula.


### Transaction Fees Will Matter More


### The Real Deal: Coinbase Transaction


### Mining Economics


### Summary

- Block Reward
- Transaction Fees


### References

- Bitcoin and Cryptocurrency Technologies by Arvind Narayanan,

```
Joseph Bonneau, Edward Felten, Andrew Miller and Steven
Goldfeder
```


`


## ` Module 05:

## Bitcoin Improvement

## Proposal (BIP)

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Bitcoin Improvement

Proposal (BIP)

- Different Kinds of BIP
- BIP Process
- BIP Repository


### Bitcoin Improvement Proposal (BIP)

- Bitcoin Improvement Proposals are design documents

```
providing information to the Bitcoin community or describing
a new feature for Bitcoin or its processes or environment.
```

### Different Kinds of BIP

As per BIP0001 BIP Purpose and Guidelines, there are three kinds of
BIP:

1:- A Standards Track BIP describes any change that affects most or
all Bitcoin implementations, such as a change to the network
protocol, a change in block or transaction validity rules, or any
change or addition that affects the interoperability of applications
using Bitcoin.

2:- An Informational BIP describes a Bitcoin design issue or provides
general guidelines or information to the Bitcoin community but does
not propose a new feature.

- Informational BIPs do not necessarily represent a Bitcoin
    community consensus or recommendation, so users and
    implementors are free to ignore Informational BIPs or follow their
    advice


3:- A Process BIP describes a process surrounding Bitcoin or
proposes a change to (or an event in) a process.

- Process BIPs are like Standards Track BIPs but apply to areas other
    than the Bitcoin protocol itself.
- They may propose an implementation, but not to Bitcoin’s
    codebase; they often require community consensus; unlike
    Informational BIPs, they are more than recommendations, and
    users are typically not free to ignore them.
- Examples include procedures, guidelines, changes to the decision-
    making process, and changes to the tools or environment used in
    Bitcoin development. Any meta-BIP is also considered a Process
    BIP.

### Different Kinds of BIP (continued)


### BIP Process


### BIP Repository

- Bitcoin Improvement Proposals are recorded in a versioned

repository on Github at https://github.com/bitcoin/bips.

- Consult the authoritative repository for up-to-date information

on existing BIPs and their contents.


### Summary

- Bitcoin Improvement

Proposal (BIP)

- Different Kinds of BIP
- BIP Process
- BIP Repository


### References

- https://river.com/learn/what-is-a-bitcoin-improvement-

proposal-bip/

- https://github.com/bitcoin/bips



`


`

## Module 06:

## Bitcoin Scripting Language

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Bitcoin Scripting

Language

- Bitcoin Script Instructions
- Transaction Script

```
Language Operators,
Constants and Symbols
```

### Bitcoin Scripting Language (“Script”)


### List of Common Script Instructions and Their

### Functionality


### Bitcoin Script Instructions

- 256 opcodes total (15 disabled, 75 reserved)

```
▪ Simple Arithmetic
▪ Conditional Execution (If / then)
▪ Logic / data handling
▪ No Looping ( not Turing Complete )
▪ Recursion
▪ Crypto!
○ Hashes
○ Signature verification
○ Multi-signature verification
```

### Proof-of-Burn


### Should Senders Specify Scripts?


### Idea: Use The Hash of Redemption Script


### Pay To Script Hash


### Push Value onto Stack


### Conditional Flow Control


### Stack Operations


### String Splicer Operation


### Binary Arithmetic and Conditionals


### Cryptographic and Hash Operations


### Summary

- Bitcoin Scripting

Language

- Bitcoin Script Instructions
- Transaction Script

```
Language Operators,
Constants and Symbols
```

### References

- Bitcoin and Cryptocurrency Technologies by Arvind Narayanan,

```
Joseph Bonneau, Edward Felten, Andrew Miller and Steven
Goldfeder
```
- Appendix B of Mastering Bitcoin by Andreas M. Antonopoulos



`


`

## Module 06:

## Transaction Validity

## Checking Using Bitcoin

## Scripts

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- The Real Deal:
    - A Bitcoin transaction
    - Transaction Metadata
    - Transaction Input
    - Transaction Output
- Bitcoin Explorer


### The Real Deal: A Bitcoin Transaction



Input “addresses” are also Scripts


### Bitcoin Script Execution: Example


### The Real Deal: A Bitcoin Transaction


### The Real Deal: Transaction Metadata


### The Real Deal: Transaction Input


### The Real Deal: Transaction Output


###### See For Yourself!

blockchain.info (and many other sites...)



### Summary

- The Real Deal:
    - A Bitcoin transaction
    - Transaction Metadata
    - Transaction Input
    - Transaction Output
- Bitcoin Explorer


### References

- Bitcoin and Cryptocurrency Technologies by Arvind Narayanan,

```
Joseph Bonneau, Edward Felten, Andrew Miller and Steven
Goldfeder
```
- https://www.blockchain.com/explorer



`


## ` Module 06:

## Applications of Bitcoin

## Scripts

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Escrow transactions
- Green Addresses
- Efficient micro-payments
- Bitcoin Scripts in Practice
- More Advanced Scripts


### Example 1: Escrow transactions


### Example 2: Green Addresses

```
InstaWallet, Mt.Gox
Collapsed!
```

### Example 3: Efficient micro-payments


```
Alice Bob
```
```
I’llpublish!
```
all of thesecould
be double-
spends!

```
What if Bob neversigns??
```
```
I’m Done!
```
```
Input: x; Pay 42 to Bob, 58 to Alice
SIGNED(ALICE)SIGNED(BOB)
```
```
Input: x; Pay 03 to Bob, 97 to Alice
SIGNED(ALICE)
```
```
Alice demands a timed refund transaction before starting
```
```
Input: x; Pay 100 to Alice, LOCK until time t
SIGNED(ALICE)SIGNED(BOB)
```
```
Input: x; Pay 02 to Bob, 98 to Alice
SIGNED(ALICE)
Input: x; Pay 01 to Bob, 99 to Alice
SIGNED(ALICE)
Input: x; Pay 100 to Bob/Alice (MULTISIG)
SIGNED(ALICE)
```
```
Input: x; Pay 04 to Bob, 96 to Alice
SIGNED(ALICE)
```

### lock_time


### OP_CHECKMULTISIG


### Bitcoin Scripts in Practice (as of 2014)

- Most nodes whitelist known scripts
- 99.9% are simple signature checks
- ~0.01% are MULTISIG
- ~0.01% are Pay-to-Script-Hash
- Remainder are errors,proof-of-burn


### More Advanced Scripts

- Multiplayer lotteries
- Hash pre-image challenges
- Coin-swapping protocols

**“Smart contracts”**


### Summary

- Escrow transactions
- Green Addresses
- Efficient micro-payments
- Bitcoin Scripts in Practice
- More Advanced Scripts


### References

- Bitcoin and Cryptocurrency Technologies by Arvind Narayanan,

```
Joseph Bonneau, Edward Felten, Andrew Miller and Steven
Goldfeder
```


`


`

## Module 06:

## How does a Bitcoin

## transaction actually work?

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Digital Signatures
- A Bitcoin transaction
- Unspent Transaction

Outputs (UTXOs)

- Transaction with a Third

Person

- The PubKey Script


### Digital Signatures

- Bitcoin uses Digital Signatures to validate authenticity of a

transaction and the sender of that transaction.


###### A Bitcoin transaction

- To send bitcoin, a transaction output is created using receiver address.
- Outputs consist of an index / location to help the network find this
    transaction when the owner of the provided address (receiver) is ready
    to spend the bitcoin, the amount of bitcoin being sent in satoshis, and
    a locking script called the PubKey Script.
- The PubKey Script locks the satoshis in the pubkeyhash (receiver
    address) provided to the sender.
- Receiver is the only one with the private key to feed to the PubKey Script
    and unlock the satoshis in the address provided.


### Unspent Transaction Outputs (UTXOs)

- Once the transaction is validated and mined by the miners, the receiver’s
    wallet, which corresponds to the receiver’s address, shows the bitcoin
    owned.
- Wallet just tracks the outputs that correspond to the address.
- These outputs are called Unspent Transaction Outputs (UTXOs).
- UTXOs stay idle until somebody can come along and provide the
    information needed to unlock the output and send the bitcoin to
    another address creating another UTXO.
- The Bitcoin network is just a web of UTXOs that wait to be unlocked and
    sent somewhere else as a new UTXO.


- Bitcoin is not an account-based system, meaning users don’t have one
    account that accumulates bitcoin like with a bank account.
- Users hold private keys that unlock UTXOs on the network. This also
    means that you cannot send a partial amount of satoshis from one
    UTXO.
- Every time you create a new transaction you are sending all the satoshis
    locked in the UTXO.
- If you don’t want to send all the satoshis to one person, then you must
    also include an address for the remaining satoshis that you want to keep
    and those satoshis are just sent right back to you.
- You can reuse the same address to send back your remaining satoshis.
    Ideally, you should create a new address that you own to send the
    remaining satoshis for increased privacy.

### UTXOs (continued)


### Transaction with a Third Person

- Suppose you have access to the UTXO that you (receiver) and Tom
    (sender) created with 10 bitcoin locked in it, your friend Sarah also
    wants to join the network and use bitcoin. For you to send your 10
    bitcoin, you must create a new transaction consisting of an input
    and an output.


### The Input

- First, you use the transaction ID and index from Tom’s output to
    correctly find the right UTXO and corresponding PubKey Script
    that somebody must satisfy in order to be able to spend the locked
    bitcoin.
- Next, you create a Signature Script, which will be used to satisfy the
    PubKey Script.
- A Signature Script contains a signature and your public key.
- The signature is a Digital Signature, where the ‘data’ corresponds to
    essentially the entire transaction you are creating for Sarah.


### The Input (continued)

- Specifically, the data refers to the transaction ID, index, Tom’s
    PubKey Script, your new PubKey Script for Sarah and the amount of
    satoshis you are sending Sarah.
- All this data is hashed twice using the SHA256 hash algorithm.
- Then, you sign 256-bit number with your private key to create the
    signature. This combined with your public key makes up the
    Signature Script.


### The Output

- Just like Tom’s output, your output consists of:
    - a new index to locate this transaction,
    - amount of satoshis, and
    - a new PubKey Script using the address Sarah provides you, which
       locks the bitcoin in Sarah’s address.
- Now only the person (Sarah) who has the private key that
    corresponds to the address can send those bitcoin on to
    somebody else.


### The PubKey Script

- Once the transaction is created, you will broadcast it to the network
    of miners.
- The miners grab your Signature Script and run it through the
    PubKey Script.
- If the result of the PubKey Script is true, then your transaction will
    be added to a block and validated on the network.

The PubKey scripting example:


### The PubKey Script (continued)

- Bitcoin is a scripting stack-based language. The way this operation
    is interpreted is as follows:


- Step 1:
    - Add your Signature Script. First add your signature then add your
       public key.
- Step 2:
    - OP_DUP duplicates whatever is on top of the stack, in this case the
       public key.
- Step 3:
    - OP_HASH160 hashes the top of the stack, in this case the duplicated
       public key. Now you have the signature, the public key, and the hash
       of the public key.

###### The PubKey Script (continued)


- Step 4:
    - The PubKey Script adds the PubKey Hash that you gave Tom in the
       first transaction.
- Step 5:
    - OP_EQUALVERIFY checks the top two components on top of the
       stack, which is currently the PubKey Hash you gave Tom in the first
       transaction and the hash of the public key you provided for the
       Signature Script.
    - These two should be the same. If no, the transaction fails, and
       nothing happens. If yes, the PubKey Script will pop these two
       components off the stack so that you are left with the signature plus
       the public key.

###### The PubKey Script (continued)


- Step 6:
    - OP_CHECKSIG uses the public key to decrypt the signature. Then
       the function checks to see if the decrypted signature equals the twice
       hashed output of all the data that you signed to create the signature.
       If no, the transaction fails. If yes, the public key and signature are
       popped off and you are just left with True.
    - If True, miners can add it to a block and validate on the network.

###### The PubKey Script (continued)


### Summary

- Digital Signatures
- A Bitcoin transaction
- Unspent Transaction

Outputs (UTXOs)

- Transaction with a Third

Person

- The PubKey Script


### References

- https://developer.bitcoin.org/devguide/
- https://en.bitcoin.it/wiki/Main_Page
- https://www.youtube.com/channel/UCbXiy1W_1HSMawmBDfo

_TOA/featured

- https://medium.com/@blairlmarshall/how-does-a-bitcoin-

transaction-actually-work-1c44818c3996



`


`

## Module 06:

## Bitcoin Forks

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Forks and Attacks
- Hard Forks
- Soft Forks


### Forks and Attacks



### Soft Forks

- We can add new features which only _limit_ the set of valid

transactions

- Soft fork possibilities
    - New signature schemes
    - Changes to size limits (decreasing)
    - Extra per-block metadata
       - Shove in the Coinbase parameter
       - Commit to UTXO tree in each block



### Summary

- Forks and Attacks
- Hard Forks
- Soft Forks


### References

- Bitcoin and Cryptocurrency Technologies by Arvind Narayanan,

```
Joseph Bonneau, Edward Felten, Andrew Miller and Steven
Goldfeder
```


`


## ` Module 06:

## Energy Consumption and

## Ecology

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Thermodynamic Limits
- Energy Aspects of Bitcoin

Mining

- Estimating Energy Usage:
    - Top-Down
    - Bottom-Up


### Thermodynamic Limits


### Energy Aspects of Bitcoin Mining

● **Embodied energy:** used to manufacture mining chips &

```
other equipment
○ should decrease over time
○ returns to scale
```
● **Electricity:** used to perform computation

```
○ should increase over time
○ returns to scale
```
● **Cooling:** required to protect equipment

○ costs more with increased scale!


### Estimating Energy Usage: Top-Down

● Each block worth approximately **US$6,500**

● Approximately **$11/s** generated

● Industrial electricity (US):

- **$0.03/megajoule or $0.10/kilowatt-hour**


### Estimating Energy Usage: Bottom-Up

● Best claimed efficiency: **1 giga hashes/sec/watt**

● Network hash rate: **150,000,000 giga hashes/sec**

(excludes cooling, embodied energy)


### Summary

- Thermodynamic Limits
- Energy Aspects of Bitcoin

Mining

- Estimating Energy Usage:
    - Top-Down
    - Bottom-Up


### References

- Bitcoin and Cryptocurrency Technologies by Arvind Narayanan,

```
Joseph Bonneau, Edward Felten, Andrew Miller and Steven
Goldfeder
```


`


`

## Module 06:

## Mining Pools

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Economics of being a

Small Miner

- Mining Pool(s):
    - Process
    - Shares
    - Variations
    - Protocols
    - History
    - Hash Power
    - Pros and Cons


### Economics of being a Small Miner


### Mining Uncertainty


### Mining Pools

- **Goal:** Pool participants all attempt to mine a block with the

same Coinbase recipient

- send money to key owned by pool manager
- Distribute revenues to members based on how much work

they have performed

- minus a cut for pool manager


### Mining Shares

**Idea:** Prove work with “near-valid blocks” (shares)


### Mining Pools


### Mining Pool Variations

- **Pay per share:** Flat reward per share
    - Typically, minus a significant fee
    - What if miners never send valid blocks?
- **Proportional:** Typically, since last block
    - Lower risk for pool manager
    - More work to verify and distribute rewards
- Many others....


### Mining Pool Protocols

- API for fetching blocks, submitting shares

```
○ Stratum
○ Getwork
○ Getblockshare
```
- Proposed for standardization with a BIP (Bitcoin

Improvement Proposal)

- Increasingly important; some hardware support


### Mining Pool History

- First pools appear in late 2010
    o Back in the GPU era!
- By 2014: around 90% of mining is pool-based
- June 2014: GHash.io exceeds 50%


### Mining Pools Hash Power

```
(as of June 2014,August2014)
```

### Are Mining Pools a Good Thing?

- Pros

```
○ Make mining more predictable
○ Allow small miners to participate
○ More miners using updated validation software
```
- Cons

```
○ Lead to centralization
○ Discourage miners from running full nodes (offload the
validation tasks to pool managers)
```

### Summary

- Economics of being a

Small Miner

- Mining Pool(s):
    - Process
    - Shares
    - Variations
    - Protocols
    - History
    - Hash Power
    - Pros and Cons


### References

- Bitcoin and Cryptocurrency Technologies by Arvind Narayanan,

```
Joseph Bonneau, Edward Felten, Andrew Miller and Steven
Goldfeder
```


`


## ` Module 06:

## Mining Incentives and

## Strategies

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Bitcoin nodes – identities
- Game-Theoretic Analysis

of Mining

- Forking Attacks
- Block-Withholding Attacks


### Why Identity?

- Pragmatic: some protocols need node IDs
- Security: assume less than 50% malicious


### Why Don’t Bitcoin Nodes Have Identities?

- No Central Authority
- Identity is hard in a P2P system — Sybilattack
- Pseudonymity is a goal of Bitcoin


### Weaker Assumption: Select Random Node

- Analogy: lottery or raffle
- When tracking & verifying identities ishard, we give people

tokens, tickets,etc.

- Now we can pick a random ID & select that node


### Key Idea: Implicit Consensus

- In each round, random node is picked
- This node proposes the next block in the chain
- Other nodes implicitly accept / reject this block
    - by either extending it
    - or ignoring it and extending chain from earlier block
- Every block contains hash of the block it extends


### Game-Theoretic Analysis of Mining

Several strategic decisions:

- Which transactions to include in a block
    ○ Default: any above minimum transaction fee
- Which block to mine on topof
    ○ Default: longest valid chain
- How to choose between colliding blocks
    ○ Default: first block heard
- When to announce new blocks
    ○ Default: immediately after finding them


- Assume you control 0 < α < 1 of miningpower
- Can you profit from a non-default strategy?

### Game-Theoretic Analysis of Mining


### Forking Attacks


### Forking Attacks

- Certainly, possible if α > 0.5

```
○ may be possible with less
○ avoid block collisions
```
- Attack is detectable
- Might be reversed
- Might crash exchangerate


### Forking Attacks via Bribery

- **Idea:** building α > 0.5 is expensive. Why not rent it instead?
- Payment techniques:

```
○ Out-of-band bribery
○ Run a mining pool at a loss
○ Insert large “tips” in the block chain
```

### Block-Withholding Attacks


### Block-Withholding Attacks, Take 2

- What happens if a block is announced when you’re ahead by

1?


### Block-Withholding Attacks

- Improved strategy for any **α** if you can win every race

```
○ Ideal network position
○ Bribery?
```
- With a 50% chance of winning races, improved strategy

for **α > 0.25**

- Not yet observed in practice!


### Summary

- Bitcoin nodes – identities
- Game-Theoretic Analysis

of Mining

- Forking Attacks
- Block-Withholding Attacks


### References

- Bitcoin and Cryptocurrency Technologies by Arvind Narayanan,

```
Joseph Bonneau, Edward Felten, Andrew Miller and Steven
Goldfeder
```


`


`

## Module 07:

## Ethereum Introduction

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Introduction to Ethereum
- Ethereum Forks
- How they Relate: ETH1x,

ETH2, & Rollups

- Additional Features of

Ethereum


### Introduction to Ethereum (ETH)

- Ethereum was proposed in the late 2013 by Vitalik Buterin, a
    cryptocurrency researcher and programmer.
- Ethereum is an open source, public blockchain platform which has
    successfully implemented the functionality of “Smart Contracts”.
- Ether is a token that is used for transactions on the Ethereum
    Blockchain. It can be transferred between accounts and can also
    be used to incentivize miners.
- Ethereum provides a decentralized virtual machine known as EVM
    which is used to execute the scripts using an international network
    of public nodes.


### Features of Ethereum


### Cofounders of Ethereum

**Vitalik Buterin Dr. Gavin Wood**


### Ethereum (ETH)

- From developer's viewpoint:
    - a global, open-source, publicly available, distributed platform for
       decentralized applications
- From researchers'perspective:
    - set of consensus rules & algorithms, P2P network and
       communication protocols, EVM, Data structures, interoperable
       clients, security protocols and many more including original
       specification and EIPs
- For a layman:
    - It is a blockchain


### Four Types of Forks

- Forks are common practice in the software industry and happen for
    one of two reasons:
       - split opinions within the community and
       - required changes to the blockchain code.
- When either reason is discussed, four major types of forks can
    occur:
1. Codebase Forks: Copy of the original code, to allow for minor
    tweaks without developing the whole blockchain code from
    scratch.


2. Blockchain Forks: Branching or splitting a blockchain’s whole
    transaction history, causing the new network to develop a distinct
    identity.
3. Soft Forks: Gradual software upgrades — bug fixes, security
    checks, and new features.
4. Hard Forks: A permanent division of the blockchain.

### Four Types of Forks (continued)


### Hard Forks

- There are currently three types of hard forks:
1. Planned: Scheduled upgrades to the network, often
    abandoning the old chain.
2. Contentious: Community disagreements cause major code
    changes, forming a new chain.
3. Spin-off Coins: Minor changes to the blockchain’s code that
    create new coins.


An overview of Every Ethereum Fork on a Scale of Date and Block Number


https://www.visualcapitalist.com/mapping-major-ethereum-forks/





### How they Relate: ETH1x, ETH2, & Rollups

```
Phases not shown to scale –graphics by @trent_vanepps
```


### Recent Fork went Live

- Ethereum Serenity is the last big step in Ethereum’s development.
    Serenity is dedicated to one goal, and one goal only - to transition
    the Ethereum blockchain from POW to POS.
- Ethereum’s 4th and projected final stage of development is
    Serenity. Out of 4 phases of Serenity, last phase went live on
    September 15th, 2022.


- Proof of Work (POW): “Miners” are rewarded with cryptocurrency
    for solving puzzles that process and post blocks of data to the
    network.
- Proof of Stake (POS): Miners are chosen from a pool of miners,
    based on the stake of cryptocurrency they bid; no puzzle = no
    reward
- Proof of Stake means that there is less competition for completing
    blocks of data, significantly reducing the energy required to
    process data.

### Recent Fork went Live (continued)


###### Hard Forks of Ethereum

- Ethereum Classic (ETC) or DAO Fork (Jul 20, 2016):
    - Hackers stole money from Ethereum network. Community
       disagreements split the coins into two, ETH and ETC.
- Ethereum Zero (ETZ):
    - Planned upgrade aimed towards improvement rather than a
       revolution. Ether Zero aims to improve the transaction rate
       speeds that occur within the Ethereum network.
- Metropolis:
    - Metropolis has two phases – Byzantium (Oct 12, 2017) and
       Constantinople (Feb 28, 2019). Planned upgrade of new features
       guarantee greater privacy during transactions.
- Serenity (Sep 15, 2022):
    - Planned upgrade transitioned the Ethereum blockchain from POW to
       POS.





### Summary

- Introduction to Ethereum
- Ethereum Forks
- How they Relate: ETH1x,

ETH2, & Rollups

- Additional Features of

Ethereum


### References

- https://medium.com/mycrypto/the-history-of-ethereum-hard-

forks-6a6dae76d56f

- https://www.visualcapitalist.com/mapping-major-ethereum-

forks/

- How they relate: ETH1x, ETH2 and Rollups | by Trenton Van

Epps | Medium

- Vitalik Buterin – Wikipedia
- Gavin Wood - Wikipedia



`


`

## Module 07:

## Compared to Bitcoin

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Ethereum compared to

Bitcoin

- Common elements with

other blockchains


### Compared to Bitcoin

- Many people will come to Ethereum with some prior experience of
    cryptocurrencies, specifically Bitcoin.
- Ethereum shares many common elements with other open
    blockchains:
       - a peer-to-peer network connecting participants,
       - a Byzantine fault–tolerant consensus algorithm for
          synchronization of state updates (a proof-of-work blockchain),
       - the use of cryptographic primitives such as digital signatures
          and hashes, and
       - a digital currency (ether)


- Yet in many ways, both the purpose and construction of Ethereum
    are strikingly different from those of the open blockchains that
    preceded it, including Bitcoin.
- Ethereum’s purpose is not primarily to be a digital currency
    payment network.
- While the digital currency ether is both integral to and necessary
    for the operation of Ethereum, ether is intended as a utility
    currency to pay for use of the Ethereum platform as the world
    computer

### Compared to Bitcoin (continued)


- Unlike Bitcoin, which has a very limited scripting language,
    Ethereum is designed to be a general-purpose programmable
    blockchain that runs a virtual machine capable of executing code
    of arbitrary and unbounded complexity.
- Where Bitcoin’s Script language is, intentionally, constrained to
    simple true / false evaluation of spending conditions, Ethereum’s
    language is Turing complete, meaning that Ethereum can
    straightforwardly function as a general-purpose computer.

### Compared to Bitcoin (continued)


### Summary

- Ethereum compared to

Bitcoin

- Common elements with

other blockchains


### References

- Mastering Ethereum – Building Smart Contracts and Dapps by

Andreas M. Antonopoulos and Dr Gavin Wood



`


`

## Module 07:

## Components of Blockchain

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Components of

Blockchain

- Enquire on Blockchain


### Components of Blockchain

- The components of an open, public blockchain are (usually):
1. A peer-to-peer (P2P) network connecting participants and
    propagating transactions and blocks of verified transactions,
    based on a standardized “gossip” protocol
2. Messages, in the form of transactions, representing state
    transitions
3. A set of consensus rules, governing what constitutes a
    transaction and what makes for a valid state transition
4. A state machine that processes transactions according to the
    consensus rules


4. A chain of cryptographically secured blocks that acts as a journal
    of all the verified and accepted state transitions
5. A consensus algorithm that decentralizes control over the
    blockchain, by forcing participants to cooperate in the
    enforcement of the consensus rules
6. A game-theoretically sound incentivization scheme (e.g., proof-
    of-work costs plus block rewards) to economically secure the
    state machine in an open environment
7. One or more open-source software implementations of the
    above (“clients”)

### Components of Blockchain (continued)


- All or most of these components are usually combined in a single
    software client.
- For example, in Bitcoin, the reference implementation is developed
    by the Bitcoin Core open-source project and implemented as the
    _bitcoind_ client.
- In Ethereum, rather than a reference implementation there is a
    reference specification, a mathematical description of the system in
    the Yellow Paper.

### Components of Blockchain (continued)


### Enquire on Blockchain

- In the past, we used the term “blockchain” to represent all the
    components just listed, as a shorthand reference to the
    combination of technologies that encompass all the characteristics
    described.
- Today, however, there are a huge variety of blockchains with
    different properties.
- We need qualifiers to help us understand the characteristics of the
    blockchain in question, such as open, public, global, decentralized,
    neutral, and censorship-resistant, to identify the important
    emergent characteristics of a “blockchain” system that these
    components allow.


- Not all blockchains are created equal.
- When someone tells you that something is a blockchain, you have
    not received an answer; rather, you need to start asking a lot of
    questions to clarify what they mean when they use the word
    “blockchain.”
- Start by asking for a description of the components in the
    preceding list, then ask whether this “blockchain” exhibits the
    characteristics of being open, public, etc.

### Enquire on Blockchain (continued)


### Summary

- Components of

Blockchain

- Enquire on Blockchain


### References

- Mastering Ethereum – Building Smart Contracts and Dapps by

Andreas M. Antonopoulos and Dr Gavin Wood



`


`

## Module 07:

## The Third Age of The

## Internet

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- The Third Age of the

Internet

- Difference between Web

1.0, Web 2.0 and Web 3.0


### The Third Age of the Internet

- In 2004 the term “Web 2.0” came to prominence, describing an
    evolution of the web toward user-generated content, responsive
    interfaces, and interactivity.
- Web 2.0 is not a technical specification, but rather a term
    describing the new focus of web applications.
- The concept of dApps is meant to take the World Wide Web to its
    next natural evolutionary stage, introducing decentralization with
    peer-to-peer protocols into every aspect of a web application.


- The term used to describe this evolution is web3, meaning the
    third “version” of the web.
- First proposed by Dr. Gavin Wood, web3 represents a new vision
    and focus for web applications: from centrally owned and
    managed applications, to applications built on decentralized
    protocols.

### The Third Age of the Internet


### Dr. Gavin Wood

- Decentralized Internet

Pioneer

- Cofounder of Ethereum
- Creator of Polkadot and

Kusuma


#### Difference Between Web 1.0, Web 2.0, and Web 3.0

```
S. No. Web 1.0 Web 2.0 Web 3.0
```
1. Mostly Read-Only Wildly Read-Write Portable and Personal
2. Company Focus Community Focus Individual Focus
3. Home Pages Blogs / Wikis Live-streams / Waves
4. Owning Content Sharing Content Consolidating Content
5. WebForms Web Applications Smart Applications
6. Directories Tagging User behavior
7. Page Views Cost Per Click User Engagement
8. Banner Advertising Interactive Advertising Behavioral Advertising
9. Britannica Online Wikipedia The Semantic Web


#### Difference Between Web 1.0, Web 2.0, and Web 3.0

```
S. No. Web 1.0 Web 2.0 Web 3.0
```
10. HTML/Portals XML / RSS RDF / RDFS / OWL
11. Data was not Focused.

```
Data of many was
controlled by some
mediatory.
```
```
Data was personalized and no
use of mediatory.
```
12. Information sharing is the goal. Interaction is the goal. Immersion is the goal.
13. It connects information as its primary goal. It aims to connect people. Focuses on relating knowledge.
14. Static websites Introduction of web applications Intelligent webfunctions and apps-based
15. A simpler, more passive web. An enhanced social Web A semantic web exists.


#### Difference Between Web 1.0, Web 2.0, and Web 3.0

```
16.
```
```
Web and File Servers,
HTML, and Portals are
technologies connected
to Web 1.0.
```
```
AJAX, JavaScript, CSS, and
HTML5 are examples of
related technology.
```
```
Web 3.0 technologies
include blockchain, artificial
intelligence, and
decentralized protocols.
```
```
17.
```
```
Associated
Technologies
```
- Web and File Servers
- Search Engines
(including AltaVista and
Yahoo!)
- E-mail accounts (Yahoo!,
Hotmail)
- Peer-to-Peer File Sharing
(Napster, BitTorrent) and
others.

```
Associated Technologies
```
- Frameworks for Ajax and
JavaScript
- Microsoft.NET
- Blogs
- Wikis and others.

```
Associated Technologies
```
- Searching Using Semantics
- Databases of Information
- Ontologies
- Intelligent Digital Personal
Assistants and others.

```
S. No. Web 1.0 Web 2.0 Web 3.0
```

### What is the thing that is missing in the Web

### 3.0 umbrella?

**TRUST**


### Summary

- The Third Age of the

Internet

- Difference between Web

1.0, Web 2.0 and Web 3.0


### References

- Mastering Ethereum – Building Smart Contracts and Dapps by

Andreas M. Antonopoulos and Dr Gavin Wood

- Gavin Wood – Wikipedia
- Comparison Between Web 1.0, Web 2.0 and Web 3.0 -

GeeksforGeeks



`


`

## Module 07:

## Ether Currency Units

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Ethereum’s Currency Unit
- Ether
- Ether Denominations and

Unit Names


### Ethereum’s Currency Unit

- Ethereum’s currency unit is called ether, identified also as “ETH” or
    with the symbols Ξ (from the Greek letter “Xi” that looks like a
    stylized capital E) or, less often, ♦: for example, 1 ether, or 1 ETH, or
    Ξ1, or ♦ 1
- Use Unicode character U+039E for Ξ and U+2666 for ♦


### Ether

- Ether is subdivided into smaller units, down to the smallest unit
    possible, which is named as wei.
- One ether is 1 quintillion wei (1 * 10^18 or
    1,000,000,000,000,000,000).
- You may hear people refer to the currency “Ethereum” too, but this
    is a common beginner’s mistake. Ethereum is the system, ether is
    the currency.


### Ether (continued)

- The value of ether is always represented internally in Ethereum as
    an unsigned integer value denominated in wei.
- When you transact 1 ether, the transaction encodes
    1,000,000,000,000,000,000 wei as the value.
- Ether’s various denominations have both a scientific name using
    the International System of Units (SI) and a colloquial name that
    pays homage to many of the great minds of computing and
    cryptography.


### Ether Denominations and Unit Names

- The following table shows the various units, their colloquial (common)
    names, and their SI names. In keeping with the internal representation of
    value, the table shows all denominations in wei (first row), with ether
    shown as 10^18 wei in the 7th row.


### Summary

- Ethereum’s Currency Unit
- Ether
- Ether Denominations and

Unit Names


### References

- Mastering Ethereum – Building Smart Contracts and Dapps by

Andreas M. Antonopoulos and Dr Gavin Wood



`


`

## Module 07:

## The World Computer

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Introducing the World

Computer

- Ethereum Virtual Machine


### Introducing the World Computer

- Ethereum is much more than just a cryptocurrency.
- Ethereum aims to implement a globally decentralized, un-ownable,
    digital computer for executing peer-to-peer contracts. Put more
    simply, Ethereum is a world computer you can't shut down.
- The cryptocurrency function is subservient to Ethereum’s function
    as a decentralized world computer.
- Ether is meant to be used to pay for running smart contracts, which
    are computer programs that run on an emulated computer called
    the Ethereum Virtual Machine (EVM).


### Ethereum Virtual Machine

- The EVM is a global singleton, meaning that it operates as if it were
    a global, single instance computer, running everywhere.
- Each node on the Ethereum network runs a local copy of the EVM
    to validate contract execution, while the Ethereum blockchain
    records the changing state of this world computer as it processes
    transactions and smart contracts.


### Summary

- Introducing the World

Computer

- Ethereum Virtual Machine


### References

- Mastering Ethereum – Building Smart Contracts and Dapps by

Andreas M. Antonopoulos and Dr Gavin Wood



`


`

## Module 07:

## Ethereum Accounts

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Ethereum Accounts
- Externally Owned

Accounts

- Contract Accounts

(Internal)


### Ethereum Accounts

There are two types of accounts in Ethereum that share the same
address space:

- External accounts that are controlled by the public-private key pair.
- Contract accounts that are controlled by the code (smart contract
    code) stored together with the accounts.


### Transaction: External Accounts and Internal

### Accounts


### Externally Owned Accounts (EOAs) and

### Contracts

- The type of account you create in the MetaMask wallet is called an
    Externally Owned Account (EOA).
- Externally owned accounts are those that have a private key;
    having the private key means control over access to funds or
    contracts.
- Now there is another type of account - a contract account.


### Contract Account

- A contract account has smart contract code, which a simple EOA
    can’t have.
- Furthermore, a contract account does not have a private key.
    Instead, it is owned (and controlled) by the logic of its smart
    contract code: the software program recorded on the Ethereum
    blockchain at the contract account’s creation and executed by the
    EVM.
- Contracts have addresses, just like EOAs. Contracts can also send
    and receive ether, just like EOAs.


- However, when a transaction destination is a contract address, it
    causes that contract to run in the EVM, using the transaction, and
    the transaction’s data, as its input.
- In addition to ether, transactions can contain data indicating which
    specific function in the contract to run and what parameters to pass
    to that function.
- In this way, transactions can call functions within contracts.
- Because a contract account does not have a private key, it cannot
    initiate a transaction.

### Contract Account (continued)


- Only EOAs can initiate transactions, but contracts can react to
    transactions by calling other contracts, building complex execution
    paths.
- One typical use of this is an EOA sending a request transaction to a
    multi-signature smart contract wallet to send some ETH on to
    another address.
- A typical dAapp programming pattern is to have Contract A calling
    Contract B in order to maintain a shared state across users of
    Contract A.

### Contract Account (continued)


### Summary

- Ethereum Accounts
- Externally Owned

Accounts

- Contract Accounts

(Internal)


### References

- Mastering Ethereum – Building Smart Contracts and Dapps by

Andreas M. Antonopoulos and Dr Gavin Wood



`


`

## Module 07:

## Ethereum Networks

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Ethereum Networks
- Public Networks
- Private Networks
- Popular Test Networks


### Ethereum Networks

- Ethereum Networks are different Ethereum environments you can

```
access for development, testing, or production use cases.
```
- Ethereum is a protocol, there can be multiple independent

```
"networks" that conform to the protocol without interacting with
each other.
```
- Ethereum account will work across the different networks, but

```
account balance and transaction history won't carry over from the
main Ethereum network.
```
- For security considerations, it's not recommended to reuse

```
mainnet accounts on testnets or vice versa.
```
- Ethereum Networks are classified as Public Networks and Private

```
Networks.
```

### Ethereum Networks (continued)

- Public Networks:

```
➢Ethereum Mainnet
➢Ethereum Testnets
▪ Sepolia
▪ Holesovice (not operational yet), use Goerli instead until replaced
➢Layer 2 (L2) Testnets
▪ Arbitrum Goerli
▪ Optimistic Goerli
```
- Private Networks:

```
➢Development Networks
➢Consortium Networks
```

### Public Networks

Public networks are accessible to anyone in the world with an

internet connection. Anyone can read or create transactions on a

public blockchain and validate the transactions being executed.

- **Mainnet**
    - Mainnet is the primary public Ethereum production
       blockchain, where actual-value transactions occur on the
       distributed ledger.
    - When people and exchanges discuss ETH prices, they're
       talking about Mainnet ETH.


### Public Networks (continued)

- **Testnet**
    - These networks are used by protocol developers or smart
       contract developers to test both protocol upgrades as well as
       potential smart contracts in a production-like environment
       before deployment to Mainnet.
    - Most testnets started by using a permissioned proof-of-
       authority consensus mechanism. This means a small number
       of nodes are chosen to validate transactions and create new
       blocks –staking their identity in the process.
    - ETH on testnets has no real value and testers get it from
       faucets.


### Sepolia Test Network

- Sepolia is the recommended default testnet network for contract
    and application developers to test their applications.
       - Closed validator set, controlled by client & testing teams
       - New testnet, less applications deployed than other testnets
       - Fast to sync and running a node requires minimal disk space
       - Useful for users who want to quickly spin up a node and interact with
          the network directly
- Sepolia resources: https://sepolia.dev/


### Holesovice / Goerli Test Network

- Goerli network lets protocol developers test network protocol
    upgrades and lets stakers test running validators.
       - Open validator set, stakers can test network upgrades
       - Large state, useful for testing complex smart contract interactions
       - Longer to sync and requires more storage to run a node
- Goerli resources: https://goerli.net/
- Goerli launchpad: https://goerli.launchpad.ethstaker.cc/en/
- Goerli will be replaced by Holesovice in 2023.


### Layer 2 (L2) Test Network

- Arbitrum Goerli:
    - Testnet of Arbitrum
    - Arbitrum resources: https://arbitrum.io/
- Optimistic Goerli:
    - Testnet of Optimism
    - Optimism resources: https://www.optimism.io/


### Private Networks

- **Development Networks:**
    - When building an Ethereum application with smart contracts, you'll
       want to run it on a local network to see how it works before deploying
       it.
    - Use a development network to create a local blockchain instance to
       test your dapp.
    - Ethereum development networks provide features that allow for
       much faster iteration than a public testnet.
- Convenient features of Development Network:
    - Deterministically seeding your local blockchain with data (e.g.,
       accounts with ETH balances)
    - Instantly producing blocks with each transaction, it receives, in order
       and with no delay
    - Enhanced debugging and logging functionality


### Private Networks (continued)

- **Consortium Networks:**
    - The consensus process is controlled by a pre-defined set of nodes
       that are trusted.
    - A private network of known academic institutions that each govern a
       single node, and blocks are validated by a threshold of signatories
       within the network.
    - If a public Ethereum network is like the public internet, a consortium
       network is like a private intranet.


### Mainnet v/s Testnet v/s Devnet


### Evolution of Testnet


### Popular Test Networks


### Summary

- Ethereum Networks
- Public Networks
- Private Networks
- Popular Test Networks


### References

- Mastering Ethereum – Building Smart Contracts and Dapps by

Andreas M. Antonopoulos and Dr Gavin Wood

- https://ethereum.org/en/developers/docs/networks/
- https://ethereum.org/en/developers/docs/development-

networks/

- https://etherworld.co/2022/08/19/the-evolution-of-ethereum-

testnet/



`


`

## Module 07:

## Ethereum Nodes and

## Clients

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Nodes and Clients
- Client Diversity
- Tracking nodes in the

network

- Node Types
- Running your own node
- Alternatives / NaaS
- Execution Clients
- Consensus Clients
- Local Clients


### Nodes and Clients

- A "node" is any instance of Ethereum client software that is connected to
    other computers also running Ethereum software, forming a network.
- A client is an implementation of Ethereum that verifies data against the
    protocol rules and keeps the network secure.
- Post-Merge Ethereum consists of two parts: the execution layer and the
    consensus layer. Both layers are run by different client software. They
    are referred as the execution client and consensus client.
- The execution client (also known as the Execution Engine, EL client or
    formerly the Eth1 client) listens to new transactions broadcasted in the
    network, executes them in EVM, and holds the latest state and database
    of all current Ethereum data.


### Nodes and Clients (continued)

- The consensus client (also known as the Beacon Node, CL client or
    formerly the Eth2 client) implements the proof-of-stake consensus
    algorithm, which enables the network to achieve agreement based on
    validated data from the execution client.
- With the Merge, Ethereum transitions to proof-of-stake by connecting
    these networks. Execution and consensus clients work together to verify
    Ethereum's state.
- Modular design approach makes it easier to execute The Merge
    seamlessly and enables the reuse of individual clients, for example, in
    the Layer 2 Ecosystem.


```
Layer 2
Ecosystem:
Coupled
```
Execution and

```
Consensus
Clients
```

### Client Diversity

- Both execution clients and consensus clients exist in a variety of programming
    languages developed by different teams.
- Multiple client implementations can make the network stronger by reducing its
    dependency on a single codebase.
- The ideal goal is to achieve diversity without any client dominating the network,
    thereby eliminating a potential single point of failure.
- The variety of languages also invites a broader developer community and
    allows them to create integrations in their preferred language.
- Specifications dictate how the Ethereum network and blockchain functions.
    Every technical detail is defined, and specifications can be found in Yellow
    Paper, Execution Specs and Consensus Specs.


### Client Diversity (continued)


### Tracking nodes in the network

- Multiple trackers offer a real-time overview of nodes in the
    Ethereum network.
- Note that due to the nature of decentralized networks, these
    crawlers can only provide a limited view of the network and might
    report different results.
       - Map of Nodes (https://etherscan.io/nodetracker)
       - Ethernodes (https://ethernodes.org/)
       - Ethereum Node Crawler (https://crawler.ethereum.org/)
       - Nodewatch (https://nodewatch.io/)


### Node Types

- There are different types of node that consume data differently. In fact,
    clients can run three different types of nodes: light, full and archive.
- There are also options of different sync strategies which enable faster
    synchronization time. Synchronization refers to how quickly it can get
    the most up-to-date information on Ethereum's state.
- **Full Node:**
    - Stores full blockchain data (although this is periodically pruned so a full
       node does not store all state data back to genesis)
    - Participates in block validation, verifies all blocks and states.
    - All states can be derived from a full node (although very old states are
       reconstructed from requests made to archive nodes).
    - Serves the network and provides data on request.


### Node Types (continued)

- **Light Node:**
    - Light nodes download the block headers. These headers only contain summary
       information about the contents of the blocks.
    - Any other information required by the light node gets requested from a full
       node. The light node can verify the data they receive against the state roots in
       the block headers.
    - Light nodes enable users to participate in the Ethereum network without the
       powerful hardware or high bandwidth required to run full nodes. Eventually,
       light nodes might run on mobile phones or embedded devices.
    - The light nodes do not participate in consensus, but they can access the
       Ethereum blockchain with the same functionality and security guarantees as a full
       node.
    - The execution client Geth includes alight sync option. However, a light Geth
       node relies upon full nodes serving light node data. Few full nodes opt to serve
       light node data, meaning light nodes often fail to find peers.
    - In future expect to see new light clients for the consensus layer and execution
       layer soon. There are also potential routes to providing light client data over the
       gossip protocol. This is advantageous because the gossip network could
       support a network of light nodes without requiring full nodes to serve requests.
    - Light node support is an area expected to develop rapidly soon. Clients
       likeNimbus,Helios, andLodeStar are currently heavily focused on light nodes.


### Node Types (continued)

- **Archive Node:**
    - Stores everything kept in the full node and builds an archive of
       historical states. It is needed if you want to query something like an
       account balance at block #4,000,000, or simply and reliably test your
       own transactions set without mining them using tracing.
    - This data represents units of terabytes, which makes archive nodes
       less attractive for average users but can be handy for services like
       block explorers, wallet vendors, and chain analytics.
    - Syncing clients in any mode other than archive will result in pruned
       blockchain data. This means, there is no archive of all historical states,
       but the full node can build them on demand.


### Running your own node

- Running your own node enables you to use Ethereum in a private, self-
    sufficient and trustless manner.
- You don't need to trust the network because you can verify the data
    yourself with your client. "Don't trust, verify" is a popular blockchain
    mantra.
- Your node verifies all the transactions and blocks against consensus rules
    by itself. This means you don’t have to rely on any other nodes in the
    network or fully trust them.
- For a beginner-friendly introduction visit run a node page to learn more.


### Running your own node (continued)


### Alternatives / Nodes as a Service (NaaS)

- Setting up your own node can cost you time and resources, but you
    don’t always need to run your own instance. In this case, you can use a
    third-party API provider like Infura,Alchemy, Chainstack, QuikNode,
    Tenderly, Blast, orGetBlock.
- Alternatively, ArchiveNode is a community-funded Archive node that
    hopes to bring archive data on the Ethereum blockchain to independent
    developers who otherwise couldn't afford it.
- If somebody runs an Ethereum node with a public API in your
    community, you can point your light wallets (like MetaMask) to a
    community node and gain more privacy than with some random trusted
    third party.
- On the other hand, if you run a client, you can share it with your friends
    who might need it


### Execution Clients (Formerly ETH1 Clients)

Client Language Operating systems Networks Sync strategies State pruning

Geth Go

```
Linux,
Windows,
macOS
```
```
Mainnet,
Sepolia, Goerli Snap, Full
```
```
Archive,
Pruned
```
Nethermind C#, .NET

```
Linux,
Windows,
macOS
```
```
Mainnet,
Sepolia, Goerli,
and more
```
```
Snap (without
serving), Fast,
Full
```
```
Archive,
Pruned
```
Besu Java

```
Linux,
Windows,
macOS
```
```
Mainnet,
Sepolia, Goerli,
and more
```
```
Snap, Fast,
Full
```
```
Archive,
Pruned
```
Erigon Go

```
Linux,
Windows,
macOS
```
```
Mainnet,
Sepolia, Goerli,
and more
```
```
Full Archive, Pruned
```
Akula Rust Linux Mainnet, Sepolia, Goerli Full Archive, Pruned


### Consensus Clients (Formerly ETH2 Clients)

Client Language Operating systems Networks

Lighthouse Rust Linux, Windows, macOS

```
Beacon Chain, Goerli,
Pyrmont, Sepolia,
Ropsten, and more
```
Lodestar TypeScript Linux, Windows, macOS

```
Beacon Chain, Goerli,
Sepolia, Ropsten, and
more
```
Nimbus Nim Linux, Windows, macOS

```
Beacon Chain, Goerli,
Sepolia, Ropsten, and
more
```
Prysm Go Linux, Windows, macOS

```
Beacon Chain, Gnosis,
Goerli, Pyrmont,
Sepolia, Ropsten, and
more
```
Teku Java Linux, Windows, macOS

```
Beacon Chain, Gnosis,
Goerli, Sepolia,
Ropsten, and more
```

### Synchronization Modes

- To follow and verify current data in the network, the Ethereum client
    needs to sync with the latest network state.
- This is done by downloading data from peers, cryptographically
    verifying their integrity, and building a local blockchain database.
- Synchronization modes represent different approaches to this process
    with various trade-offs. Clients also vary in their implementation of sync
    algorithms.
- **Execution layer sync nodes:** Full sync, Fast Sync, Light Sync, & Snap
    Sync
- **Consensus layer sync nodes:** Optimistic Sync, Checkpoint Sync


### Local / Development Clients

- Ganache:
    - Ganache fire up a personal Ethereum blockchain which you can use
       to run tests, execute commands, and inspect state while controlling
       how the chain operates
    - Ganache provides both a desktop application (Ganache UI), as well
       as a command-line tool (ganache-cli). It is part of Truffle suite of
       tools.
- Hardhat Network:
    - Hardhat Network comes built-in with Hardhat, an Ethereum
       development environment for professionals.
- Local Beacon Chains:
    - Some consensus clients have built-in tools for spinning up local
       beacon chains for testing purposes. Instructions for Lighthouse,
       Nimbus and Lodestar are available.


### Running A Full Node

- The health, resilience, and censorship resistance of blockchains
    depend on them having many independently operated and
    geographically dispersed full nodes.
- Each full node can help other new nodes obtain the block data to
    bootstrap their operation, as well as offering the operator an
    authoritative and independent verification of all transactions and
    contracts.
- Choosing to run a full node helps with the operation of the
    networks you connect it to, but also incurs some mild to moderate
    costs for you.


### Full Node Advantages and Disadvantages

**Advantages:**

- Supports the resilience and censorship resistance of Ethereum-
    based networks
- Authoritatively validates all transactions
- Can interact with any contract on the public blockchain without an
    intermediary
- Can directly deploy contracts into the public blockchain without an
    intermediary
- Can query (read-only) the blockchain status (accounts, contracts,
    etc.) offline
- Can query the blockchain without letting a third party know the
    information you’re reading


**Disadvantages:**

- Requires significant and growing hardware and bandwidth
    resources
- May require several days to fully sync when first started
- Must be maintained, upgraded, and kept online to remain synced

### Full Node Advantages and Disadvantages


###### Public Testnet Node: Advantages and Disadvantages

- Whether or not you choose to run a full node, you will probably
    want to run a public testnet node.

```
Advantages:
```
- A testnet node needs to sync and store much less data — about 10
    GB depending on the network (as of April 2018).
- A testnet node can sync fully in a few hours.
- Deploying contracts or making transactions requires test ether,
    which has no value and can be acquired for free from several
    “faucets.”
- Testnets are public blockchains with many other users and
    contracts, running “live.”


```
Disadvantages:
```
- You can’t use “real” money on a testnet; it runs on test ether.
    Consequently, you can’t test security against real adversaries, as
    there is nothing at stake.
- There are some aspects of a public blockchain that you cannot test
    realistically on a testnet. For example, transaction fees, although
    necessary to send transactions, are not a consideration on a
    testnet, since gas is free. Further, the testnets do not experience
    network congestion like the public mainnet sometimes does.

###### Public Testnet Node: Advantages and Disadvantages


### Summary

- Nodes and Clients
- Client Diversity
- Tracking nodes in the

network

- Node Types
- Running your own node
- Alternatives / NaaS
- Execution Clients
- Consensus Clients
- Local Clients


### References

- Mastering Ethereum – Building Smart Contracts and Dapps by

Andreas M. Antonopoulos and Dr Gavin Wood

- https://ethereum.org/en/developers/docs/nodes-and-clients/
- https://ethereum.org/en/developers/docs/nodes-and-

clients/client-diversity/



`


`

## Module 08:

## Integrated Development

## Environments (IDEs)

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Integrated Development

Environment (IDE)

- Web-based IDEs
- Desktop IDEs
- Remix IDE


### Integrated Development Environment (IDE)

- When it comes to setting up an integrated development
    environment, programming applications on Ethereum is like
    programming any other software project.
- There are many options to choose from, so at the end of the day,
    pick the IDE or code editor that best suits your preferences.
- Most likely the best IDE choice for your Ethereum development is
    the IDE you already use for traditional software development.


### Web-based IDEs

If you're looking to fiddle with code before you set up a local
development environment, these web apps are custom-built for
Ethereum smart contract development.

- **Remix** - Web-based IDE with built in static analysis, and a test
    blockchain virtual machine
       - Docs
       - Gitter
- **ChainIDE** - A cloud-based multi-chain IDE
    - Docs
    - Help forum


### Web-based IDEs (continued)

- **Replit (Solidity Starter - Beta)** - A customizable development
    environment for Ethereum with hot reloading, error checking, and
    first-class testnet support
       - Docs
- **Tenderly Sandbox** - A fast prototyping environment where you
    can write, execute, and debug smart contracts in the browser using
    Solidity and JavaScript
- **EthFiddle** - Web-based IDE that lets you write, compile, and debug
    your smart contract
       - Gitter


### Desktop IDEs

- Most established IDEs have built plugins to enhance the Ethereum
    development experience. At a minimum, they provide syntax
    highlighting for smart contract languages.
- **Visual Studio Code** - Professional cross-platform IDE with official
    Ethereum support
       - Visual Studio Code
       - Azure Blockchain Workbench
       - Code samples
       - GitHub
- **Atom** - A hackable text editor for the 21st Century
    - Atom
    - GitHub
    - Ethereum packages


### Desktop IDEs (continued)

- **JetBrains IDEs (IntelliJ IDEA, etc.)** - Essential tools for software
    developers and teams
       - JetBrains
       - GitHub
       - IntelliJ Solidity
- **Remix Desktop** - Experience Remix IDE on your local machine
    - Download
    - GitHub


### Plugins and Extensions

- Solidity - Ethereum Solidity Language for Visual Studio Code
- Solidity + Hardhat for VS Code - Solidity and Hardhat support by
    the Hardhat team
- Prettier Solidity - Code formatter using prettier


### Remix IDE

- Remix IDE, is a no-setup tool with a GUI for developing smart
    contracts.
- Remix plays well with other tools and allows for a simple
    deployment process to the chain of your choice.
- In Remix, everything is a plugin. Core plugins are preloaded for
    essential operations. Additional plugins offer an expanded palette
    of tools.
- The Remix Plugin Engine manages the communication between
    plugins.


### Remix IDE (continued)


### Remix IDE (continued)

- Remix Online IDE – Web-based Dev Environment
    - Remix Online IDE is a powerful toolset for developing, deploying,
       debugging, and testing Ethereum and EVM-compatible smart contracts. It
       requires no setup and has a flexible, intuitive user interface.
- Remix Desktop IDE – Electron App
    - For users who prefer the performance or security of their own hard drive,
       Remix has a desktop app. Your files are saved directly in your computer’s
       filesystem.
- Ethereum Remix – VSCode Extension
    - Plugin Remix in VSCode, offering access to Remix tools in an environment
       many users already know.
- Remixd – CLI Tool
    - Remixd connects Remix Online IDE to a folder on your hard drive, offering
       all the advantages of file storage on your computer’s filesystem.


### Summary

- Integrated Development

Environment (IDE)

- Web-based IDEs
- Desktop IDEs
- Remix IDE


### References

- https://ethereum.org/en/developers/docs/ides/
- https://remix-project.org/



`


`

## Module 08:

## Package Managers

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Ethereum Package

Manager (ethPM)

- Node Package Manager

(npm)


### Ethereum Package Manager (ethPM)

- ethPM (v3 in 2020) is the immutable package manager to
    consume, distribute, or manage any EVM smart contract system.
    ethPM helps in reusable smart contract packages.
- An ethPM package represents the idea of a smart contract; from a
    single smart contract file, to a deployed contract instance, to a
    complex system of smart contracts, and everything in between.
- ethPM has similar goals to most package managers found in any
    given programming language.
       - Easily import and build upon core ideas written by others.
       - Distribute the ideas that you've written / deployed, making them easily
          consumable for tooling and the community at large.


### ethPM Architecture


### ethPM Registry

- A registry is an on-chain datastore containing the data for released
    ethPM packages. Unlike traditional package managers which maintain a
    single, centralized package registry (e.g., NPM, pypi) ethPM uses a
    federated model where everybody is required to deploy and maintain
    their own, permissioned package registry (or registries).
- In a world of trustless computation, trust is critical when it comes to
    consuming smart contract packages. A single line of malicious code in a
    wallet package could be the difference between a successful dapp or a
    successful hack. That is why you should NEVER import a package from a
    registry with an unknown or untrusted owner.
- That last sentence is important, it's worth repeating.
- ONLY USE PACKAGES FROM TRUSTED REGISTRIES!


### ethPM Package

- An ethPM package is a combination of 3 elements that represent an
    immutable smart contract idea:
       - Package Name
       - Package Version
       - Content-Addressed URI
- These three elements are stored on-chain in an ethPM registry.
    ERC1319, which defines the registry API, enforces that once a package is
    released, it can never be re-released. The immutability of the blockchain
    and content-addressed URIs provide absolute certainty that once you
    interact with a <wallet==1.2.0> package from a certain registry, there is
    100% certainty that it can never be modified.


### ethPM Manifest

- A manifest is the actual JSON file that contains the JSON object which
    defines an ethPM package. The JSON file is stored at the content-
    addressed URI defined in each package release.
- The bare minimum ethPM manifest defines three fields.
- Of course, this manifest does not represent a very useful package, so it is
    up to the creator of each manifest to include whatever contractTypes,
    sources, deployments, compilers, meta (data) or buildDependencies that
    are necessary to compose the desired smart contract idea.
- Manifests may live on disk but are intended to be produced and
    consumed programmatically and uploaded directly to a content-
    addressable storage network (e.g., IPFS).


### Why ethPM?

- No more copy & pasting abis or source code
- Native integration with your favorite compilers
- Versioned and secure way to manage smart contract systems
- Easily interact with deployed contracts
- Safely deploy verified contract types
- Compatibility across mainnet & testnets
- Securely manage your own package registry
- Support for multiple storage networks (e.g., IPFS, Swarm, Github)


### Node Package Manager (npm)

- npm is committed to making JavaScript development elegant,
    productive, and safe.
- The free npm Registry has become the center of JavaScript code
    sharing, and with more than one million packages, the largest
    software registry in the world.
- Other tools and services take the Registry, and the work you do
    around it, to the next level.
- npm is more of centralized registry compared to ethPM. Some of
    the Ethereum tools are using npm. npm Pro and npm Teams are
    like ethPM.


### Summary

- Ethereum Package

Manager (ethPM)

- Node Package Manager

(npm)


### References

- https://docs.ethpm.com/
- https://docs.ethpm.com/ethpm-spec
- https://medium.com/coinmonks/ethpm-smart-contract-

packages-for-developers-81c77481c491

- https://www.npmjs.com/



`


`

## Module 08:

## Runtime Environment and

## NodeJS Packages

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Runtime Environment –

node.js

- NodeJS Packages
    - Web3.js
    - Ethers.js


### Runtime Environment – node.js

- Node.js is an open-source, cross-platform JavaScript runtime
    environment and library for running web applications outside the
    client's browser.
- Ryan Dahl developed it in 2009, and its latest iteration, version
    15.14, was released in April 2021.
- Developers use Node.js to create server-side web applications,
    and it is perfect for data-intensive applications since it uses an
    asynchronous, event-driven model.
- Node.js is referred in multiple terminology like NodeJS or NodeJs
    in different websites or books.


### Usage of NodeJS

- NodeJS is built on Google Chrome’s V8 engine, and for this reason its
    execution time is very fast, and it runs very quickly.
- As NodeJS do not need to wait for an API to return data, so for building
    real time and data intensive web applications, it is very useful. It is totally
    asynchronous in nature that means it is totally non-blocking.
- The loading time for an audio or video is reduced by NodeJS because
    there is better synchronization of the code between the client and server
    for having the same code base.
- As NodeJS is open-source and it is nothing but a JavaScript framework,
    so for the developers who are already used to JavaScript, for them
    starting on developing their projects with NodeJS is very easy.


### Features of NodeJS

- Asynchronous in Nature and Event driven
- Single Threaded Architecture
- Scalable
- Quick Execution time for code
- Compatibility on the cross platforms
- Uses JavaScript
- Fast Data Streaming
- No Buffering


### NodeJS Packages

- Two libraries which are the most important NodeJS packages

```
that offer different ways of interacting with your smart contract
and processing transaction in an EVM-compatible blockchain
are:
```
```
➢Web3.js
```
```
➢Ethers.js
```

### Web3.js

- Web3.js is a collection of libraries that allow developers to interact
    with a remote or local Ethereum node using HTTP, IPC, or
    WebSocket.
- You can create websites or clients that communicate with the
    blockchain using this library. This can include, among other things,
    transmitting ether from one user to another, examining data from
    smart contracts, and designing smart contracts.


### Ethers.js

- Ethers.js library aims to be a complete and compact general-
    purpose library for interacting with the Ethereum Blockchain and
    its ecosystem.
       1. Keep your private keys in your client, safe and sound
       2. Import and export JSON wallets (Geth, Parity and crowdsale)
       3. Import and export BIP 39 mnemonic phrases (12-word backup
          phrases) and HD Wallets.
       4. Meta-classes create JavaScript objects from any contract ABI,
          including ABIv2 and Human-Readable ABI.
       5. Connect to Ethereum nodes over JSON-
          RPC, INFURA, Etherscan, Alchemy, Cloudflare or MetaMask
       6. ENS names are first-class citizens; they can be used anywhere an
          Ethereum addresses can be used.
       7. Tiny (~88kb compressed; 284kb uncompressed).
       8. Complete functionality for all your Ethereum needs.


### Ethers.js (continued)

9. Extensive documentation.

10.Large collection of test cases which are maintained and added to.

11.Fully TypeScript ready, with definition files and full TypeScript
source.

12.MIT License (including _ALL_ dependencies); completely open
source to do with as you please


### Distinction between Ethers.js and Web3.js

- Unlike web3.js, which provides a single instantiated web3 object
    with methods for interacting with the blockchain, ethers.js divides
    the API into two distinct roles.
- The provider is an anonymous connection to the Ethereum
    network, while the signer has access to the private key and can sign
    transactions.
- The ethers team intended for this separation of concerns to give
    developers more flexibility.


### Summary

- Runtime Environment –

node.js

- NodeJS Packages
    - Web3.js
    - Ethers.js


### References

- https://www.simplilearn.com/tutorials/nodejs-tutorial/what-is-

```
nodejs#:~:text=js%3F-
,Node.,was%20released%20in%20April%202021
```
- https://medium.com/coinmonks/the-distinctions-between-

```
ethers-js-and-web3-js-
8e51f60083ce#:~:text=Unlike%20web3.,key%20and%20can%2
0sign%20transactions
```


`


## ` Module 08:

## Ethereum Virtual Machine

## (EVM)

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Ethereum Virtual Machine

(EVM)

- EVM Instruction Set

(Bytecode Operations)

- EVM Opcodes
- Ethereum State
- Compiling Solidity to EVM

Bytecode


### Ethereum Virtual Machine (EVM)

- The EVM is part of Ethereum that handles smart contract deployment
    and execution.
- Simple value transfer transactions from one EOA to another don’t need
    to involve it, practically speaking, but everything else will involve a state
    update computed by the EVM.
- At a high level, the EVM running on the Ethereum blockchain can be
    thought of as a global decentralized computer containing millions of
    executable objects, each with its own permanent data store.
- The EVM is a quasi–Turing-complete state machine; “quasi” because all
    execution processes are limited to a finite number of computational
    steps by the amount of gas available for any given smart contract
    execution.


### EVM (continued)

- The EVM has a stack-based architecture, storing all in-memory
    values on a stack.
- It works with a word size of 256 bits (mainly to facilitate native
    hashing and elliptic curve operations) and has several addressable
    data components:
       - An immutable program code ROM, loaded with the bytecode of the smart
          contract to be executed
       - A volatile memory, with every location explicitly initialized to zero
       - A permanent storage that is part of the Ethereum state, also zero-initialized


### Components of EVM


### The EVM Instruction Set (Bytecode Operations)

The EVM instruction set offers most of the operations you might
expect, including:

- Arithmetic and bitwise logic operations
- Execution context inquiries
- Stack, memory, and storage access
- Control flow operations
- Logging, calling, and other operators
- In addition to the typical bytecode operations, the EVM also has access to
    account information (e.g., address and balance) and block information (e.g.,
    block number and current gas price).


### EVM Opcodes – Arithmetic operations

- **Arithmetic Opcode instructions:**
    - ADD //Add the top two stack items
    - MUL //Multiply the top two stack items
    - SUB //Subtract the top two stack items
    - DIV //Integer division
    - SDIV //Signed integer division
    - MOD //Modulo (remainder) operation
    - SMOD //Signed modulo operation
    - ADDMOD //Addition modulo any number
    - MULMOD //Multiplication modulo any number
    - EXP //Exponential operation
    - SIGNEXTEND //Extend the length of a two's complement signed integer
    - SHA3 //Compute the Keccak256 hash of a block of memory
- Note that all arithmetic is performed modulo 2^256 (unless otherwise noted), and that
    the zeroth power of zero, 0^0, is taken to be 1.


### EVM Opcodes – Stack operations

- **Stack, memory, and storage management instructions:**
    - POP //Remove the top item from the stack
    - MLOAD //Load a word from memory
    - MSTORE //Save a word to memory
    - MSTORE8 //Save a byte to memory
    - SLOAD //Load a word from storage
    - SSTORE //Save a word to storage
    - MSIZE //Get the size of the active memory in bytes
    - PUSHx //Place x byte item on the stack, where x can be any integer from
       1 to 32 (full word) inclusive
    - DUPx //Duplicate the x-thstack item, where x can be any integer from 1
       to 16 inclusive
    - SWAPx //Exchange 1st and (x+1)-thstack items, where x can be any
       integer from 1 to 16 inclusive


### EVM Opcodes – Process flow operations

- **Control flow instructions:**
    - STOP //Halt execution
    - JUMP //Set the program counter to any value
    - JUMPI //Conditionally alter the program counter
    - PC //Get the value of the program counter (prior to the increment
       //corresponding to this instruction)
    - JUMPDEST //Mark a valid destination for jumps


### EVM Opcodes – System operations

- **Opcodes for the system executing the program:**
    - LOGx //Append a log record with x topics, where x is any integer from 0
       //to 4 inclusive
    - CREATE //Create a new account with associated code
    - CALL //Message-call into another account, _i.e.,_ run another account’s
       //code
    - CALLCODE //Message-call into this account with another //account's code
    - RETURN //Halt execution and return output data
    - DELEGATECALL //Message-call into this account with an alternative account’s
       //code, but persisting the current values for //sender and value
    - STATICCALL //Static message-call into an account
    - REVERT //Halt execution, reverting state changes but returning data and
       // remaining gas
    - INVALID //The designated invalid instruction
    - SELFDESTRUCT //Halt execution and register account for deletion


### EVM Opcodes – Logic operations

- **Opcodes for comparisons and bitwise logic:**
    - LT //Less-than comparison
    - GT //Greater-than comparison
    - SLT //Signed less-than comparison
    - SGT //Signed greater-than comparison
    - EQ //Equality comparison
    - ISZERO //Simple NOT operator
    - AND //Bitwise AND operation
    - OR //Bitwise OR operation
    - XOR //Bitwise XOR operation
    - NOT //Bitwise NOT operation
    - BYTE //Retrieve a single byte from a full-width 256-bit


### EVM Opcodes – Environmental operations

- **Opcodes dealing with execution environment information:**
    - GAS //Get the amount of available gas (after the reduction for this instruction)
    - ADDRESS //Get the address of the currently executing account
    - BALANCE //Get the account balance of any given account
    - ORIGIN //Get the address of the EOA that initiated this EVM execution
    - CALLER //Get the address of the caller immediately responsible for this execution
    - CALLVALUE //Get the ether amount deposited by the caller responsible for this
       //execution
    - CALLDATALOAD //Get the input data sent by the caller responsible for this execution
    - CALLDATASIZE //Get the size of the input data
    - CALLDATACOPY //Copy the input data to memory
    - CODESIZE //Get the size of code running in the current environment
    - CODECOPY //Copy the code running in the current environment to memory
    - GASPRICE //Get the gas price specified by the originating transaction
    - EXTCODESIZE //Get the size of any account's code
    - EXTCODECOPY //Copy any account's code to memory
    - RETURNDATASIZE //Get the size of the output data from the previous call in the
       //current environment
    - RETURNDATACOPY //Copy data output from the previous call to memory


### EVM Opcodes – Block operations

- **Opcodes for accessing information on the current block:**
    - BLOCKHASH //Get the hash of one of the 256 most recently completed blocks
    - COINBASE //Get the block's beneficiary address for the block reward
    - TIMESTAMP //Get the block's timestamp
    - NUMBER //Get the block's number
    - DIFFICULTY //Get the block's difficulty
    - GASLIMIT //Get the block's gas limit


### Gas needed for EVM Operations


### Ethereum State

- The job of the EVM is to update the Ethereum state by computing valid
    state transitions as a result of smart contract code execution, as defined
    by the Ethereum protocol.
- This aspect leads to the description of Ethereum as a transaction-based
    state machine, which reflects the fact that external actors (i.e., account
    holders and miners) initiate state transitions by creating, accepting, and
    ordering transactions.
- It is useful at this point to consider what constitutes the Ethereum state.
- At the top level, we have the Ethereum world state. The world state is a
    mapping of Ethereum addresses (160-bit values) to accounts.


### Ethereum State (continued)

- At the lower level,
    - each Ethereum address represents an account comprising an ether balance (stored
       as the number of wei owned by the account),
    - a nonce (representing the number of transactions success fully sent from this
       account if it is an EOA, or the number of contracts created by it if it is a contract
       account),
    - the account’s storage (which is a permanent data store, only used by smart
       contracts), and
    - the account’s program code (again, only if the account is a smart contract account).
- An EOA will always have no code and an empty storage.


### Compiling Solidity to EVM Bytecode

- Compiling a Solidity source file to EVM bytecode can be accomplished
    via several methods.
- We can use the online Remix compiler or use the solc executable at the
    command line. For a list of options, run the following command:
       - $ solc –help
- Generating the raw opcode stream of a Solidity source file; but leaves
    some information:
       - $ solc –o BytecodeDir –-opcodes Example.sol
- Produces the full information with –asm option:
    - $solc –o BytecodeDir –-asm Example.sol


#### Compiling Solidity to EVM Bytecode (continued)

- Compiling the example with the --asm option produces a file named
    example.evm in the BytecodeDir directory.
- Produces the bytecode binary or deployment bytecode:
    - $solc –o BytecodeDir –-bin Example.sol
- Produces the subset of bytecode binary or runtime bytecode:
    - $solc –o BytecodeDir –-bin –runtime Example.sol
- Runtime bytecode is a subset of deployment bytecode or in other
    words, the runtime bytecode is entirely contained within the deployment
    bytecode.


### Contract Deployment Code

- The deployment bytecode:
    - is used for every aspect of the initialization of a new contract account and
       the code to initialize everything based on the contract’s constructor.
    - includes the bytecode that will end up being executed when transactions
       call this new contract (i.e., the runtime bytecode)
- The runtime bytecode is exactly the bytecode that ends up being
    executed when the new contract is called, and nothing more.


### Disassembling the Bytecode

- Disassembling EVM bytecode is a great way to understand how high-
    level Solidity acts in the EVM. There are a few disassemblers you can use
    to do this:
       - Porosity is a popular open source decompiler.
       - Ethersplay is an EVM plug-in for Binary Ninja, a disassembler.
       - IDA-Evmis an EVM plugin for IDA, another disassembler.


### Additional Standalone EVM Implementations

- Ethereum Execution Clients include an EVM implementation.
    Additionally, there are multiple standalone implementations,
    including:
       - Py-EVM - Python
       - evmone -C++
       - ethereumjs-vm - JavaScript
       - eEVM - C++


### Summary

- Ethereum Virtual Machine

(EVM)

- EVM Instruction Set

(Bytecode Operations)

- EVM Opcodes
- Ethereum State
- Compiling Solidity to EVM

Bytecode


### References

- Mastering Ethereum, Building Smart Contracts anddApps by

Andreas Antonopoulos and Dr. Gavin Wood

- https://ethereum.org/en/developers/docs/evm/



`


`

## Module 08: Gas

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Gas
- Block Size
- Base fee
- Priority fee (tips)
- Max fee & Calculating fee
- Why do Gas fees exist?
- What is Gas limits?
- Initiatives to reduce Gas

Costs

- Strategies for you to

reduce Gas Costs


### Gas

- Gas is essential to the Ethereum network. It is the fuel that allows it to
    operate, in the same way that a car needs gasoline to run.
- Gas refers to the unit that measures the amount of computational effort
    required to execute specific operations on the Ethereum network.
- Since each Ethereum transaction requires computational resources to
    execute, each transaction requires a fee. Gas refers to the fee required
    to execute a transaction on Ethereum, regardless of transaction success
    or failure.


### Gas (continued)

- Gas fees are paid in Ethereum's native currency, ether (ETH). Gas
    prices are denoted in gwei, which itself is a denomination of ETH -
    each gwei is equal to 0.000000001 ETH (10-^9 ETH).
- For example, instead of saying that your gas costs 0.000000001
    ether, you can say your gas costs 1 gwei. The word 'gwei' itself
    means 'giga-wei', and it is equal to 1,000,000,000 wei. Wei itself
    (named after Wei Dai, creator of b-money) is the smallest unit of
    ETH.


### Gas (continued)

- Let's say Jordan must pay Taylor 1 ETH. In the transaction, the gas limit is
    21,000 units and the base fee is 10 gwei. Jordan includes a tip of 2 gwei.
- **total fee = units of gas used * (base fee + priority fee)** , where the base feeis
    a value set by the protocol and the priority fee is a value set by the user as a tip
    to the validator.
       i.e., 21,000 * (10 + 2) = 252,000 gweior 0.000252 ETH.
- When Jordan sends the money, 1.000252 ETH will be deducted from Jordan's
    account. Taylor will be credited 1.0000 ETH. Validator receives the tip of
    0.000042 ETH. Base fee of 0.00021 ETH is burned.
- Additionally, Jordan can also set a max fee (maxFeePerGas) for the transaction.
    The difference between the max fee and the actual fee is refunded to Jordan,
    i.e.,refund = max fee -(base fee + priority fee). Jordan can set a maximum
    amount to pay for the transaction to execute and not worry about overpaying
    "beyond" the base fee when the transaction is executed.


### Block Size

- Recent upgrades introduced variable-sized blocks to Ethereum. Each
    block has a target size of 15 million gas, but the size of blocks will
    increase or decrease in accordance with network demand, up until the
    block limit of 30 million gas (2x the target block size).
- The protocol achieves an equilibrium block size of 15 million on average
    through the process of _tâtonnement_.
- This means if the block size is greater than the target block size, the
    protocol will increase the base fee for the following block. Similarly, the
    protocol will decrease the base fee if the block size is less than the target
    block size.
- The amount by which the base fee is adjusted is proportional to how far
    the current block size is from the target.


### Base fee

- Every block has a base fee which acts as a reserve price. To be eligible
    for inclusion in a block the offered price per gas must at least equal the
    base fee.
- The base fee is calculated independently of the current block and is
    instead determined by the blocks before it -making transaction fees
    more predictable for users. When the block is mined this base fee is
    "burned", removing it from circulation.
- The base fee is calculated by a formula that compares the size of the
    previous block (the amount of gas used for all the transactions) with the
    target size. The base fee will increase by a maximum of 12.5% per block
    if the target block size is exceeded. This exponential growth makes it
    economically non-viable for block size to remain high indefinitely.


Block
Number

```
Included
Gas
```
```
Fee
Increase
```
```
Current
Base Fee
1 15M 0% 100 gwei
2 30M 0% 100 gwei
3 30M 12.5% 112.5 gwei
4 30M 12.5% 126.6 gwei
5 30M 12.5% 142.4 gwei
6 30M 12.5% 160.2 gwei
7 30M 12.5% 180.2 gwei
8 30M 12.5% 202.7 gwei
```
### Base fee (continued)

```
Block
Number
```
```
Included
Gas
```
```
Fee
Increase
```
```
Current Base
Fee
30 30M 12.5% 2705.6 gwei
... ... 12.5% ...
50 30M 12.5% 28531.3 gwei
... ... 12.5% ...
100 30M 12.5% 10302608.6 gwei
```

### Priority fee (tips)

- With the new base fee getting burned, the recent upgrade introduced a
    priority fee (tip) to incentivize miners to include a transaction in the
    block.
- Without tips, miners would find it economically viable to mine empty
    blocks, as they would receive the same block reward.
- Under normal conditions, a small tip provides miners a minimal incentive
    to include a transaction.
- For transactions that need to get preferentially executed ahead of other
    transactions in the same block, a higher tip will be necessary to attempt
    to outbid competing transactions.


### Max fee and Calculating fee

- **Max fee:** To execute a transaction on the network, users can specify a
    maximum limit they are willing to pay for their transaction to be
    executed. This optional parameter is known as the maxFeePerGas.
- For a transaction to be executed, the max fee must exceed the sum of
    the base fee and the tip. The transaction sender is refunded the
    difference between the max fee and the sum of the base fee and tip.
- **Calculating fee:** One of the main benefits of the recent upgrade is
    improving the user's experience when setting transaction fees.
- For wallets that support the upgrade, instead of explicitly stating how
    much you are willing to pay to get your transaction through, wallet
    providers will automatically set a recommended transaction fee (base
    fee + recommended priority fee) to reduce the amount of complexity
    burdened onto their users.


### Why do Gas fees exist?

- The recent upgrade made the transaction fee mechanism more complex
    than the previous gas price auction, but it has the advantage of making
    gas fees more predictable, resulting in a more efficient transaction fee
    market.
- Users can submit transactions with a maxFeePerGas corresponding to
    how much they are willing to pay for the transaction to be executed,
    knowing that they will not pay more than the market price for gas
    (baseFeePerGas), and get any extra, minus their tip, refunded.
- In short, gas fees help keep the Ethereum network secure. By requiring a
    fee for every computation executed on the network, we prevent bad
    actors from spamming the network.
- In order to avoid accidental or hostile infinite loops or other
    computational wastage in code, each transaction is required to set a limit
    to how many computational steps of code execution it can use. The
    fundamental unit of computation is "gas".


### Why do Gas fees exist? (continued)

- Although a transaction includes a limit, any gas not used in a
    transaction is returned to the user (i.e., max fee – (base fee + tip) is
    returned).


### What is Gas Limit?

- Gas limit refers to the maximum amount of gas you are willing to
    consume on a transaction.
- More complicated transactions involving smart contracts require more
    computational work, so they require a higher gas limit than a simple
    payment. A standard ETH transfer requires a gas limit of 21,000 units of
    gas.
- For example, if you put a gas limit of 50,000 for a simple ETH transfer,
    the EVM would consume 21,000, and you would get back the remaining
    29,000.
- However, if you specify too little gas, for example, a gas limit of 20,000
    for a simple ETH transfer, the EVM will consume your 20,000 gas units
    attempting to fulfill the transaction, but it will not complete.
- The EVM then reverts any changes, but since the miner has already done
    20k gas units worth of work, that gas is consumed.


### Initiatives to reduce Gas Costs

- The Ethereum scalability upgrades should ultimately address

```
some of the gas fee issues, which will, in turn, enable the
platform to process thousands of transactions per second and
scale globally.
```
- Layer 2 scaling is a primary initiative to greatly improve gas

costs, user experience and scalability.


### Strategies for you to reduce Gas Costs

- If you are looking to reduce gas costs for your transactions, you can set a
    tip to indicate the priority level of your transaction.
- Evaluators will 'work on' and execute transactions that offer a higher tip
    per gas, as they get to keep the tips that you pay and will be less inclined
    to execute transactions with lower tips set.
- If you want to monitor gas prices, so you can send your ETH for less, you
    can use many different tools such as:
       - Etherscan-Transaction gas price estimator
       - Blocknative ETH Gas Estimator - Gas estimating Chrome extension
          supporting both Type 0 legacy transactions and Type 2 EIP- 1559
          transactions.
       - ETH Gas Station - Consumer oriented metrics for the Ethereum gas market
       - Cryptoneur Gas Fees Calculator - Calculate gas fees in your local currency
          for different transaction types on Mainnet, Arbitrum, and Polygon.


### Summary

- Gas
- Block Size
- Base fee
- Priority fee (tips)
- Max fee & Calculating fee
- Why do Gas fees exist?
- What is Gas limits?
- Initiatives to reduce Gas

Costs

- Strategies for you to

reduce Gas Costs


### References

- https://ethereum.org/en/developers/docs/gas/
- https://ethereum.org/en/developers/docs/evm/opcodes/



`


`

## Module 08:

## Advanced Wallets

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Non-Deterministic Wallets
- Deterministic Wallets
- Hierarchical Deterministic

(HD) Wallets

- MetaMask


### Non-Deterministic Wallets

There are two primary types of wallets, distinguished by whether the
keys they contain are related to each other or not.

**Non-Deterministic Wallet:**

- The first type is a non-deterministic wallet, where each key is
    independently generated from a different random number.
- The keys are not related to each other.
- This type of wallet is also known as a JBOK wallet, from the phrase
    “Just a Bunch of Keys.”


- The second type of wallet is a deterministic wallet, where all the
    keys are derived from a single master key, known as the seed.
- All the keys in this type of wallet are related to each other and can
    be generated again if one has the original seed.
- There are several different key derivation methods used in
    deterministic wallets.
- The most used derivation method uses a tree-like structure, as
    described in Hierarchical Deterministic Wallets.

### Deterministic Wallets


### Hierarchical Deterministic Wallets (BIP-32/BIP-44)

- Deterministic wallets were developed to make it easy to derive
    many keys from a single seed.
- Currently, the most advanced form of deterministic wallet is the
    Hierarchical Deterministic (HD) wallet defined by Bitcoin’s BIP- 32
    standard.
- HD wallets contain keys derived in a tree structure, such that a
    parent key can derive a sequence of child keys, each of which can
    derive a sequence of grandchild keys, and so on.


### HD Wallet: A Tree of Keys Generated from a

### Single Seed


### HD Wallet Advantages

HD wallets offer a few key advantages over simpler deterministic
wallets.

1. The tree structure can be used to express additional
    organizational meaning, such as when a specific branch of
    subkeys is used to receive incoming payments and a different
    branch is used to receive change from outgoing payments.
- Branches of keys can also be used in corporate settings, allocating
different branches to departments, subsidiaries, specific functions, or
accounting categories.


2. Users can create a sequence of public keys without having access
    to the corresponding private keys.
- This allows HD wallets to be used on an insecure server or in a watch-
only or receive-only capacity, where the wallet doesn’t have the
private keys that can spend the funds.

### HD Wallet Advantages (continued)


### MetaMask

- MetaMask is a versatile browser-based HD wallet, RPC client, and
    basic contract explorer.
- It is available on Chrome, Firefox, Opera, and Brave Browser.
- Unlike other browser wallets, MetaMask injects a web3 instance
    into the browser JavaScript context, acting as an RPC client that
    connects to a variety of Ethereum blockchains (mainnet, all active
    testnets, local RPC node, etc.).


- The ability to inject a web3 instance and act as a gateway to
    external RPC services makes MetaMask a very powerful tool for
    developers and users alike.
- It can be combined, for example, with MyEtherWallet or MyCrypto,
    acting as a web3 provider and RPC gateway for those tools.

### MetaMask (continued)


### Getting Started with MetaMask

- Open the Google Chrome browser and navigate to
    https://chrome.google.com/webstore/category/extensions.
- Search for “MetaMask” and click on the logo of a fox.


- It’s important to verify that you are downloading the real MetaMask
    extension, as sometimes people can sneak malicious extensions past
    Google’s filters.
- The real one:
    - Shows the ID **nkbihfbeogaeaoehlefnkodbefgpgknn** in the address
       bar
    - Is offered by https://metamask.io
    - Has more than 1,400 reviews
    - Has more than 1,000,000 users
- Once you confirm you are looking at the correct extension, click “Add to
    Chrome” to install it.

### Getting Started with MetaMask (continued)


### Creating a Wallet (continued)

- Once MetaMask is installed you should see a new icon (the head of
    a fox) in your browser’s toolbar. Click on it to get started.
- You will be asked to accept the terms and conditions and then to
    create your new Ethereum wallet by entering a password.
- The password controls access to MetaMask, so that it can’t be used
    by anyone with access to your browser.
- NOTE: Your MetaMask wallet uses the same private key and
    Ethereum address on all the networks it connects to. However,
    your Ethereum address balance on each Ethereum network will be
    different. Your keys may control ether and contracts on Goerli, for
    example, but not on the main network.



- Once you’ve set a password, MetaMask will generate a wallet for
    you and show you a mnemonic backup consisting of 12 English
    words.
- These words can be used in any compatible wallet to recover
    access to your funds should something happen to MetaMask or
    your computer. You do not need the password for this recovery;
    the 12 words are sufficient.
- Back up your mnemonic (12 words) on paper, twice. Store the two
    paper backups in two separate secure locations, such as a fire-
    resistant safe, a locked drawer, or a safe deposit box.
- Treat the paper backups like cash of equivalent value to what you
    store in your Ethereum wallet.
- Anyone with access to these words can gain access and steal your
    money.

### Creating a Wallet (continued)



- Once you have confirmed that you have stored the mnemonic securely,
    you’ll be able to see the details of your Ethereum account.
       - Your account page shows the
          name of your account
          (“Account 1” by default), an
          Ethereum address (0x9E713...
          in the example), and a colorful
          icon to help you visually
          distinguish this account from
          other accounts. At the top of
          the account page, you can see
          which Ethereum network you
          are currently working on
          (“Main Network” in the
          example).


### Getting Some Test Ether

- Your first task is to get your wallet funded.
- You won’t be doing that on the main network because real ether
    costs money and handling it requires a bit more experience.
- For now, you’ll load your wallet with some testnet ether.
- Switch MetaMask to the Goerli Test Network.
- Click Buy, then click Goerli Test Faucet.
- MetaMask will open a new web page.



- The web page already contains your MetaMask wallet’s Ethereum
    address.
- MetaMask integrates Ethereum-enabled web pages with your
    MetaMask wallet and can “see” Ethereum addresses on the web
    page, allowing you, for example, to send a payment to an online
    shop displaying an Ethereum address.
- MetaMask can also populate the web page with your own wallet’s
    address as a recipient address if the web page requests it.
- In this page, the faucet application is asking MetaMask for a wallet
    address to send test ether to.

### Getting Some Test Ether (continued)


- Click the green “request 1 ether from faucet” button.
- You will see a transaction ID appear in the lower part of the page.
- The faucet app has created a transaction - a payment to you. The
    transaction ID looks like this:
    **0x7c7ad5aaea6474adccf6f5c5d6abed11b70a350fbc6f9590109e0**
    **99568090c57**
- In a few seconds, the new transaction will be mined by the Ropsten
    miners and your MetaMask wallet will show a balance of 1 ETH.
- Click on the transaction ID and your browser will take you to a block
    explorer, which is a website that allows you to visualize and explore
    blocks, addresses, and transactions.

### Getting Some Test Ether (continued)


- MetaMask uses the Etherscan block explorer, one of the more popular
    Ethereum block explorers. The transaction containing the payment from
    the Ropsten Test Faucet is shown below.
       - The transaction has
          been recorded on the
          Ropsten blockchain
          and can be viewed at
          any time by anyone,
          simply by searching
          for the transaction ID.
          Try entering the
          transaction hash into
          the
          ropsten.etherscan.io
          website, to see it for
          yourself.


### Sending Ether from MetaMask

- Once you’ve received your first test ether from the Ropsten Test Faucet, you
    can experiment with sending ether by trying to send some back to the
    faucet.
- As you can see on the Ropsten Test Faucet page, there is an option to
    “donate” 1 ETH to the faucet. This option is available so that once you’re
    done testing, you can return the remainder of your test ether, so that
    someone else can use it next.
- Even though test ether has no value, some people hoard it, making it
    difficult for everyone else to use the test networks.
- Click the orange “1 ether” button to tell MetaMask to create a transaction
    paying the faucet 1 ether.
- MetaMask will prepare a transaction and pop up a window with the
    confirmation, as shown.


### Sending Ether from MetaMask (continued)

- MetaMask will prepare a transaction and
    pop up a window with the confirmation,
    as shown.
- You can’t complete the transaction—
    MetaMask says you have an insufficient
    balance, because of the cost of gas.
- Every Ethereum transaction requires
    payment of a fee, which is collected by
    the evaluators to validate the transaction.
- The fees in Ethereum are charged in a
    virtual currency called gas.
- You pay for the gas with ether, as part of
    the transaction.


NOTE:

- Fees are required on the test networks too.
- Without fees, a test network would behave differently from the main
    network, making it an inadequate testing platform.
- Fees also protect the test networks from DoS attacks and poorly
    constructed contracts (e.g., infinite loops), much like they protect the
    main network

### Sending Ether from MetaMask (continued)


### Exploring the Transaction History of an Address

- You can view all your transactions using the
    ropsten.etherscan.io block explorer.
- You can either copy your wallet address
    and paste it into the block explorer’s
    search box or have MetaMask open the
    page for you.
- Next to your account icon in MetaMask,
    you will see a button showing three dots.
- Click on it to show a menu of account
    related options.


- Select “View account on Etherscan” to open a web page in the
    block explorer showing your account’s transaction history.


### Summary

- Non-Deterministic Wallets
- Deterministic Wallets
- Hierarchical Deterministic

(HD) Wallets

- MetaMask


### References

- Mastering Ethereum, Building Smart Contracts anddApps by

Andreas Antonopoulos and Dr. Gavin Wood

- https://metamask.io/
- https://docs.metamask.io/guide/#why-metamask



`


`

## Module 08:

## Development Client

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Development Client –

Ganache

- Ganache UI
- Ganache CLI


### Development Client – Ganache

- Ganache can be referred as a local or personal or a development client.
- Ganache is a personal blockchain for rapid Ethereum and Corda
    distributed application development which you can use to run tests,
    execute commands, and inspect state while controlling how the chain
    operates.
- You can use Ganache across the entire development cycle; enabling you
    to develop, deploy, and test your dApps in a safe and deterministic
    environment.
- Ganache comes in two flavors: a UI and CLI.


### Ganache (continued)

- Ganache UI is a desktop application supporting both Ethereum
    and Corda technology.
- The more robust command-line tool,ganache, is available for
    Ethereum development.
- It offers:
    - console.log in Solidity
    - Zero-config Mainnet and testnet forking
    - Fork any Ethereum network without waiting to sync
    - Ethereum JSON-RPC support


- Snapshot / revert state
- Mine blocks instantly, on demand, or at an interval
- Fast-forward time
- Impersonate any account (no private keys required!)
- Listens for JSON-RPC 2.0 requests over HTTP / Web Sockets
- Programmatic use in Node.js
- Pending Transactions

### Ganache (continued)


### Ganache UI

- After installing Ganache UI, create a workspace.
- Workspace Configuration:
- Parameters at the time of creation and can be changed.
- The screen will show some details about the server, and list 10
    accounts. Each account is given 100 ethers. Having ether
    automatically in all accounts allows you to focus on developing
    your application.


### Ganache UI – Accounts


### Ganache UI (continued)

- There are six pages available:
    - **Accounts** shows the accounts generated and their balances. This is the
       default view.
    - **Blocks** shows each block as mined on the blockchain, along with gas used
       and transactions.
    - **Transactions** lists all transactions run against the blockchain.
    - **Contracts** lists the contracts contained in your workspace's Truffle projects.
       For more information on how Ganache handles contracts, see Contracts
       Page documentation.
    - **Events** lists all events that have been triggered since this workspace's
       creation. Ganache will attempt to decode events triggered by contracts in
       your Truffle project. For more information on events, see Events Page
       documentation.
    - **Logs** shows the logs for the server, which is useful for debugging.
- Also note that you can search for block numbers or transaction
    hashes from a search box at the top.


### Ganache CLI

- Ganache can be used from the command
    line, programmatically via Node.js, or in the browser.

**Command line use:**

- You must first install Node.js >= v14.0.0 and npm >= 6.12.0.
- To install Ganache globally, run:
    - $ npm install ganache --global
- Once installed globally, you can start ganache right from your
    command line:
- ganache


### Ganache CLI (Continued)


**NPM project use:**

- If you want to install Ganache into npm project, run:

$ npm install ganache

- You can then add Ganache to your package.json scripts:

```
"scripts": {
"ganache": "ganache --wallet.seed myCustomSeed"
}
```
- Then start it:

$ npm run ganache

### Ganache CLI (Continued)


**Programmatic Use:**

- You can use Ganache programmatically from Node.js. Install
    Ganache into your npm package:
       $ npm install ganache
- Then you can use ganache as an EIP-1193 provider only, an EIP-
    1193 provider and JSON-RPC web server, as a Web3 provider, or
    an ethers provider.

**As an EIP-1193 provider only:**
const ganache = require("ganache");
const options = {};
const provider = ganache.provider(options);
const accounts = await provider.request({ method:
"eth_accounts", params: [] });

### Ganache CLI (Continued)


**As an EIP-1193 provider and JSON-RPC web server:**

### Ganache CLI (Continued)


**As a web3.js provider:**

- To use ganache as a Web3 provider:

```
const Web3 = require("web3");
const ganache = require("ganache");
const web3 = new Web3(ganache.provider());
```
- Depending on your web3 version, you may need to set a number
    of confirmation blocks
       const web3 = new Web3(ganache.provider(), null, {
       transactionConfirmationBlocks: 1 });

### Ganache CLI (Continued)


**As an ethers.js provider:**

```
const ganache = require("ganache");
const provider = new
ethers.providers.Web3Provider(ganache.provider());
```
**Browser Use:**

- You can also use Ganache in the browser by adding the following
    script to your HTML:
       <script
       src="https://cdn.jsdelivr.net/npm/ganache@{VERSION}/dist/web/
       ganache.min.js"></script>
- The {VERSION} in the above path needs to be replaced with a
    version number or tag that is listed in npm.

### Ganache CLI (Continued)


- **From there, Ganache is available in your browser for use:**
    - const options = {};
    - const provider = Ganache.provider(options);

### Ganache CLI (Continued)


### Startup Options

- The startup options are grouped in the chain, database, fork,
    logging, miner, wallet, and server namespaces, and should be used
    as such on startup, i.e.
- for CLI use

```
ganache --namespace.option="value"
```
- and for programmatic use

```
const options = { namespace: { option: "value"}};
const provider = ganache.provider(options);
```

### Detached Instances

- Ganache can be started as a background instance via the CLI by providing
    the following argument (along with any valid combination of the Ganache
    startup arguments):
       - -D, --detach, --😈 Run Ganache in detached (daemon) mode.
          [boolean]
- This will start Ganache as a background process and return to the console
    as soon as Ganache has started and is ready to receive requests
- A friendly name will be returned to STDOUT which can then be used to
    interact with the instance via the ganache instances command with the
    following arguments:


- Commands:
    - ganache instances list List instances running in detached
       mode
    - ganache instances stop <name> Stop the instance specified by
       <name>
- E.g., start Ganache on port 8544, with a block time of 10 seconds, and
    then stop the instance.

###### Detached Instances (continued)


- With the following command, you can start Ganache, run your
    tests, and stop Ganache when you are finished.
       GANACHE=$(ganache --detach) && npm run test; ganache
       instances stop $GANACHE
- Or if you are running PowerShell on Windows, you can do:

```
$GANACHE=ganache --detach; npm run test; ganache instances
stop $GANACHE
```
### Detached Instances (continued)


### Ganache Provider Events

- In addition to EIP-1193's "message" event and the legacy "data"
    event, Ganache emits 4 additional events:
       - "ganache:vm:tx:before"
       - "ganache:vm:tx:step"
       - "ganache:vm:tx:after"
       - "ganache:vm:tx:console.log"
- These events can be used to observe the lifecycle of any
    transaction executed via *sendTransaction, eth_call,
    debug_traceTransaction, or debug_storageRangeAt.
- These share the event paradigm that Truffle uses, but without any
    of the wildcard handling, i.e., no "vm:*" support (for now).


- Each of these events will emit a context object which is a unique
    object that can be used to identify a transaction over the course of
    its lifecycle.
- The reason this context is necessary is that Ganache may run
    multiple transactions simultaneously, so "ganache:vm:tx:step"
    events from different transactions could be intermingled.
- The above events will be emitted for eth_call, *sendTransaction,
    debug_traceTransaction, and debug_storageRangeAt.
- Currently, we do not await the event listener's return value,
    however, it will likely be enabled in the future.

### Ganache Provider Events (continued)


### Summary

- Development Client –

Ganache

- Ganache UI
- Ganache CLI


### References

- https://trufflesuite.com/docs/ganache/
- https://trufflesuite.com/docs/ganache/quickstart/
- https://trufflesuite.com/docs/ganache/reference/workspace-

default-configuration/

- https://trufflesuite.com/docs/ganache/concepts/ethereum-

workspace/overview/

- https://github.com/trufflesuite/ganache#readme



`


`

## Module 09:

## Introduction to Smart

## Contracts

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Smart Contract Languages
- Solidity
- Understand the Smart

Contract Basics


### Smart Contract Languages

- Programmer experienced with Python or any curly-bracket
    language, can find a language with familiar syntax.
- The two most active and maintained languages are:
    - Solidity, Ethereum’s native programming language
    - Vyper
- More experienced developers also might want to use
    - Yul, an intermediate language for the EVM
    - Yul+, a low-level, highly efficient extension to Yul
    - FE, statically typed language for the EVM


### Solidity

- Solidity is an object-oriented, high-level language for
    implementing smart contracts. Smart contracts are programs
    which govern the behavior of accounts within the Ethereum state.
- Solidity is a curly-bracket language designed to target the
    Ethereum Virtual Machine (EVM). It is influenced by C++, Python
    and JavaScript.
- Solidity is statically typed, supports inheritance, libraries and
    complex user-defined types among other features.


- With Solidity you can create contracts for uses such as voting,
    crowdfunding, blind auctions, and multi-signature wallets.
- When deploying contracts, you should use the latest released
    version of Solidity.
- Apart from exceptional cases, only the latest version
    receives security fixes. Furthermore, breaking changes as well as
    new features are introduced regularly. We currently use a 0.y.z
    version number to indicate this fast pace of change.

### Solidity (continued)


### Understand the Smart Contract Basics

- Storage Example


- The first line tells you that the source code is licensed under the
    GPL version 3.0. Machine-readable license specifiers are important
    in a setting where publishing the source code is the default.
- The next line specifies that the source code is written for Solidity
    version 0.4.16, or a newer version of the language up to, but not
    including version 0.9.0. This is to ensure that the contract is not
    compilable with a new (breaking) compiler version, where it could
    behave differently.
- Pragmas are common instructions for compilers about how to treat
    the source code (e.g., pragma once).

###### Understand the Smart Contract Basics (continued)


- A contract in the sense of Solidity is a collection of code
    (its _functions_ ) and data (its _state_ ) that resides at a specific address
    on the Ethereum blockchain.
- This contract does not do much yet apart from (due to the
    infrastructure built by Ethereum) allowing anyone to store a single
    number that is accessible by anyone in the world without a
    (feasible) way to prevent you from publishing this number.
- Anyone could call set again with a different value and overwrite
    your number, but the number is still stored in the history of the
    blockchain.

###### Understand the Smart Contract Basics (continued)


### Summary

- Smart Contract Languages
- Solidity
- Understand the Smart

Contract Basics


### References

- Smart contract languages | ethereum.org
- Introduction to Smart Contracts — Solidity 0.8.20

documentation (soliditylang.org)

- Installing the Solidity Compiler — Solidity 0.8.20 documentation

(soliditylang.org)



`


`

## Module 09:

## Layout of the Solidity

## Source File

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Layout of the Solidity

Source File

- SPDX License Identifier
- Pragmas
- Importing other Source

Files


### Layout of the Solidity Source File

- Source files can contain an arbitrary number of contract definitions,
    import, pragma and using for directives and struct, enum, function,
    error and constant variable definitions.


### SPDX License Identifier

- Trust in smart contracts can be better established if their source code is
    available.
- Since making source code available always touches on legal problems
    with regards to copyright, the Solidity compiler encourages the use of
    machine-readable SPDX license identifiers.
- Every source file should start with a comment indicating its license:

```
// SPDX-License-Identifier: MIT
```
- The compiler does not validate that the license is part of the list allowed
    by SPDX, but it does include the supplied string in the bytecode
    metadata.


- If you do not want to specify a license or if the source code is not
    open-source, please use the special value UNLICENSED
- **Note:** UNLICENSED (no usage allowed, not present in SPDX
    license list) is different from UNLICENSE (grants all rights to
    everyone). Solidity follows the npm recommendation.
- Supplying this comment of course does not free you from other
    obligations related to licensing like having to mention a specific
    license header in each source file or the original copyright holder.
- The comment is recognized by the compiler anywhere in the file at
    the file level, but it is recommended to put it at the top of the file.

### SPDX License Identifier (continued)


### Pragmas

- The pragma keyword is used to enable certain compiler features or
    checks.
- A pragma directive is always local to a source file, so you have to
    add the pragma to all your files if you want to enable it in your
    whole project.
- If you import another file, the pragma from that file does not
    automatically apply to the importing file.


### Version Pragma

- Source files can (and should) be annotated with a version pragma to
    reject compilation with future compiler versions that might introduce
    incompatible changes.
- Because of this, it is always a good idea to read through the changelog
    at least for releases that contain breaking changes. These releases always
    have versions of the form 0.x.0 or x.0.0.
- The version pragma is used as pragma solidity ^0.5.2;

**NOTE:** Using the version pragma _does not_ change the version of the
compiler. It also does not enable or disable features of the compiler. It
just instructs the compiler to check whether its version matches the one
required by the pragma. If it does not match, the compiler issues an error.


### ABI Coder Pragma

- By using pragma abicoder v1 or pragma abicoder v2 you can
    select between the two implementations of the ABI encoder and
    decoder.
- The new ABI coder (v2) can encode and decode arbitrarily nested
    arrays and structs.
- Apart from supporting more types, it involves more extensive
    validation and safety checks, which may result in higher gas costs,
    but also heightened security.
- It is considered non-experimental as of Solidity 0.6.0 and it is
    enabled by default starting with Solidity 0.8.0.


- The set of types supported by the new encoder is a strict superset
    of the ones supported by the old one.
- Contracts that use it can interact with ones that do not without
    limitations.
- The reverse is possible only as long as the non-abicoder v2
    contract does not try to make calls that would require decoding
    types only supported by the new encoder.
- The compiler can detect this and will issue an error. Simply
    enabling abicoder v2 for your contract is enough to make the error
    go away.
- This pragma applies to all the code defined in the file where it is
    activated, regardless of where that code ends up eventually.

### ABI Coder Pragma (continued)


### Experimental Pragma

- The second pragma is the experimental pragma. It can be used to
    enable features of the compiler or language that are not yet
    enabled by default. The following experimental pragmas are
    currently supported:
       - **ABIEncoderV2 -** Because the ABI coder v2 is not considered
          experimental anymore, it can be selected via pragma abicoder v2
          since Solidity 0.7.4.
       - **SMTChecker -** It is activated for the Ubuntu PPA releases in most
          versions, but not for the Docker images, Windows binaries or the
          statically-built Linux binaries.


### Importing other Source Files

- **Syntax and Semantics:** Solidity supports import statements to
    help modularize your code that are like those available in
    JavaScript (from ES6 on). However, Solidity does not support the
    concept of a default export.
- At a global level, you can use import statements of the following
    form:
       Import “filename”;
- If you add new top-level items inside “filename”, they automatically
    appear in all files that import like this from “filename”. It is better to
    import specific symbols explicitly.


- The following example creates a new global symbol symbolName
    whose members are all the global symbols from "filename“:
       Import * as symbolName from “filename”;
       which results in all global symbols being available in the
       format symbolName.symbol
- If there is a naming collision, you can rename symbols while
    importing.
       Import {symbol1 as alias, symbol2} from “filename”;

### Importing other Source Files (continued)


### Summary

- Layout of the Solidity

Source File

- SPDX License Identifier
- Pragmas
- Importing other Source

Files


### References

- Layout of a Solidity Source File — Solidity 0.8.20 documentation

(soliditylang.org)



`


`

## Module 09:

## Structure of a Contract

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Solidity Contract
- State Variables
- Functions
- Function Modifiers
- Events
- Errors
- Struct Types
- Enum Types


### Solidity Contract

- Contracts in Solidity are similar to classes in object-oriented
    languages.
- Each contract can contain declarations of State Variables,
    Functions, Function Modifiers,Events,Errors, Struct Types and
    Enum Types. Furthermore, contracts can inherit from other
    contracts.
- There are also special kinds of contracts called libraries and
    interfaces.


### State Variables

- State variables are variables whose values are permanently stored
    in contract storage.


### Functions

- Functions are the executable units of code. Functions are usually
    defined inside a contract, but they can also be defined outside of
    contracts.
       - Function Calls can happen
          internally or externally and
          have different levels
          of visibility towards other
          contracts.
       - Functions accept parameters
          and return variables to pass
          parameters and values
          between them.


### Function Modifiers

- Function modifiers can be
    used to amend the
    semantics of functions in a
    declarative way.
- Overloading, that is, having
    the same modifier name with
    different parameters, is not
    possible.
- Like functions, modifiers can
    be overridden.


### Events

- Events are convenience interfaces with the EVM logging facilities.


### Errors

- Errors allow you to define
    descriptive names and data for
    failure situations.
- Errors can be used in revert
    statements.
- In comparison to string
    descriptions, errors are much
    cheaper and allow you to
    encode additional data.
- You can use NatSpec to
    describe the error to the user.


### Struct Types

- Structs are custom defined types that can group several variables


### Enum Types

- Enums can be used to create custom types with a finite set of
    ‘constant values.


### Summary

- Solidity Contract
- State Variables
- Functions
- Function Modifiers
- Events
- Errors
- Struct Types
- Enum Types


### References

- Structure of a Contract — Solidity 0.8.20 documentation

(soliditylang.org)



`


`

## Module 09:

## Types

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Value Types
- Reference Types
- Mapping Types
- Operators
- Conversions between

Elementary Types

- Conversions between

```
Literals and Elementary
Types
```

### Types

- Solidity is a statically typed language, which means that the type of
    each variable (state and local) needs to be specified.
- Solidity provides several elementary types which can be combined
    to form complex types.
- In addition, types can interact with each other in expressions
    containing operators.
- The concept of “undefined” or “null” values does not exist in
    Solidity, but newly declared variables always have a default value
    dependent on its type.
- To handle any unexpected values, you should use the revert
    function to revert the whole transaction or return a tuple with a
    second bool value denoting success.


### Value Types

- **Booleans**
    - bool -The possible values are constants true and false
- **Integers**
    - int **/** uint - Signed and unsigned integers of various sizes.
    - Keywords uint8 to uint256 in steps of 8 (unsigned of 8 up to 256 bits)
       and int8 to int256.
    - uint and int are aliases for uint256 and int256, respectively.
- **Comparisons**
    - The value of a comparison is the one obtained by comparing the
       integer value.
- **Bit operations**
    - Bit operations are performed on the two’s complement
       representation of the number.


- **Shifts:**
    - The result of a shift operation has the type of the left operand, truncating
       the result to match the type.
    - The right operand must be of unsigned type, trying to shift by a signed type
       will produce a compilation error.
    - Shifts can be “simulated” using multiplication by powers of two.
    - Note that the truncation to the type of the left operand is always performed
       at the end, but not mentioned explicitly.
- **Addition, Subtraction and Multiplication:**
    - Addition, subtraction and multiplication have the usual semantics, with two
       different modes regarding over and underflow.
- **Division:**
    - Division on integers always results in an integer.
    - In Solidity, division rounds towards zero.

### Value Types (continued)


- Note: Division by zero causes a Panic error. This check cannot be
    disabled through unchecked { ... }.
- **Modulo:**
    - The modulo operation a % n yields the remainder r after the division
       of the operand a by the operand n, where q = int(a /n) and r= a -
          (n * q).
    - This means that modulo results in the same sign as its left operand (or
       zero) and a % n == -(-a % n) holds for negative a.
- Note: Modulo with zero causes a Panic error. This check cannot be
    disabled through unchecked { ... }

### Value Types (continued)


- **Exponentiation:**
    - Exponentiation is only available for unsigned types in the exponent.
       The resulting type of an exponentiation is always equal to the type of
       the base. Please take care that it is large enough to hold the result
       and prepare for potential assertion failures or wrapping behavior.
- **Fixed Point Numbers:**
    - Fixed point numbers are not fully supported by Solidity yet. They can
       be declared but cannot be assigned to or from.

### Value Types (continued)


**Address:**

- The address type comes in two largely identical flavors:
    - address: Holds a 20-byte value (size of an Ethereum address).
    - address payable: Same as address, but with the additional members
       transfer and send.
- Type conversions:
    - Implicit conversions from address payable to address are allowed,
       whereas conversions from address to addresspayable must be
       explicit via payable(<address>).
    - Explicit conversions to and from address are allowed foruint160,
       integer literals, bytes20 and contract types.

### Value Types (continued)


### Reference Types

- Values of reference type can be modified through multiple
    different names.
- Because of that, reference types must be handled more carefully
    than value types.
- Currently, reference types comprise structs, arrays and mappings.
- If you use a reference type, you always must explicitly provide the
    data area where the type is stored:
       - memory (whose lifetime is limited to an external function
          call), storage (the location where the state variables are stored, where
          the lifetime is limited to the lifetime of a contract) or calldata (special
          data location that contains the function arguments).


- An assignment or type conversion that changes the data location
    will always incur an automatic copy operation, while assignments
    inside the same data location only copy in some cases for storage
    types.
- **Data location:**
    - Every reference type has an additional annotation, the “data location”,
       about where it is stored.
    - There are three data locations: memory, storage and calldata.
    - Call data is a non-modifiable, non-persistent area where function
       arguments are stored, and behaves mostly like memory.

### Reference Types (continued)


### Mapping Types

- Mapping types use the syntax
    mapping(KeyType KeyName? =>ValueType ValueName?) and
    variables of mapping type are declared using the syntax
    mapping(KeyType KeyName? =>ValueType ValueName?) Variable
    Name.
- The KeyType can be any built-in value type, bytes,string or any
    contract or enum type.
- Other user-defined or complex types, such as mappings, structs or
    array types are not allowed.
- ValueType can be any type, including mappings, arrays and structs.
    KeyName and ValueName are optional and can be any valid
    identifier that is not a type.


- You can think of mappings as hash tables, which are virtually
    initialized such that every possible key exists and is mapped to a
    value whose byte-representation is all zeros, a type’s default value.
- The similarity ends there, the key data is not stored in a mapping,
    only its keccak256 hash is used to look up the value.
- Because of this, mappings do not have a length, or a concept of a
    key or value being set, and therefore cannot be erased without
    extra information regarding the assigned keys.

### Mapping Types (continued)


- Mappings can only have a data location of storage and thus

```
are allowed for state variables, as storage reference types in
functions, or as parameters for library functions.
```
- They cannot be used as parameters or return parameters of

contract functions that are publicly visible.

- These restrictions are also true for arrays and structs that

contain mappings.

- Iterable Mappings:
    - You cannot iterate over mappings, i.e., you cannot enumerate
       their keys. It is possible, though, to implement a data structure
       on top of them and iterate over that.

### Mapping Types (continued)


### Operators

- Arithmetic and bit operators can be applied even if the two
    operands do not have the same type.
- The following mechanism will be used to determine the type in
    which the operation is computed (this is important in case of
    overflow) and the type of the operator’s result:
       - If the type of the right operand can be implicitly converted to the
          type of the left operand, use the type of the left operand,
       - If the type of the left operand can be implicitly converted to the type
          of the right operand, use the type of the right operand,
       - otherwise, the operation is not allowed.


### Conversions between Elementary Types

- **Implicit Conversions:**
    - An implicit type conversion is automatically applied by the compiler
       in some cases during assignments, when passing arguments to
       functions and when applying operators.
    - In general, an implicit conversion between value-types is possible if it
       makes sense semantically and no information is lost.
    - If an operator is applied to different types, the compiler tries to
       implicitly convert one of the operands to the type of the other (the
       same is true for assignments).
    - This means that operations are always performed in the type of one
       of the operands.


- **Explicit Conversions:**
    - If the compiler does not allow implicit conversion but you are
       confident a conversion will work, an explicit type conversion is
       sometimes possible.
    - This may result in unexpected behavior and allows you to bypass
       some security features of the compiler, so be sure to test that the
       result is what you want and expect.

### Conversions between Elementary Types

### (continued)


### Conversions between Literals & Elementary Types

- **Integer Types**
    - Decimal and hexadecimal number literals can be implicitly converted
       to any integer type that is large enough to represent it without
       truncation:


- **Fixed-Size Byte Arrays**
    - Decimal number literals cannot be
       implicitly converted to fixed-size byte
       arrays.
    - Hexadecimal number literals can be,
       but only if the number of hex digits
       exactly fits the size of the bytes type.
    - As an exception both decimal and
       hexadecimal literals which have a
       value of zero can be converted to any
       fixed-size bytes type:

### Conversions between Literals & Elementary Types

### (continued)


- String literals and hex string literals can be implicitly converted to
    fixed-size byte arrays, if their number of characters matches the
    size of the bytes type:

### Conversions between Literals & Elementary Types

### (continued)


- **Addresses:**
    - Hex literals of the correct size that pass the checksum test are of
       address type.
    - No other literals can be implicitly converted to the address type.
    - Explicit conversions to address are allowed only from bytes20 and
       uint160.
    - An address acan be converted explicitly to address payable via
       payable(a)

### Conversions between Literals & Elementary Types

### (continued)


### Summary

- Value Types
- Reference Types
- Mapping Types
- Operators
- Conversions between

Elementary Types

- Conversions between

```
Literals and Elementary
Types
```

### References

- https://docs.soliditylang.org/en/latest/types.html



`


`

## Module 09:

## Units and Globally

## Available Variables

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Ether Units
- Time Units
- Special Variables and

Functions

- Globally Available

Variables


### Ether Units

- A literal number can take a suffix of wei, gwei, or ether to specify a
    sub-denomination of Ether, where Ether numbers without a postfix
    are assumed to be Wei
- The only effect of the sub-denomination suffix is a multiplication by
    a power of ten.


### Time Units

- Suffixes like seconds, minutes,hours,days, and weeks after literal
    numbers can be used to specify units of time where seconds are
    the base unit and units are considered naively in the following way:
       - 1 == 1 seconds
       - 1 minutes == 60 seconds
       - 1 hours == 60 minutes
- The suffix years has been removed in version 0.5.0 because not
    every year equals 365 days and not even every day has 24 hours
    because of leap seconds.
- Since leap seconds cannot be predicted, an exact calendar library
    must be updated by an external oracle.
       - 1 days == 24 hours
       - 1 weeks == 7 days


- These suffixes cannot be applied to variables. For example, if you
    want to interpret a function parameter in days, you can in the
    following way:

### Time Units (continued)


### Special Variables and Functions

- There are special variables and functions which always exist in the
    global namespace and are mainly used to provide information
    about the blockchain or are general-use utility functions.


### Block and Transaction Properties


### ABI Encoding and Decoding Functions


- These encoding functions can be used to craft data for external
    function calls without calling an external function.
- Furthermore, _keccak256(abi.encodePacked(a, b))_ is a way to
    compute the hash of structured data (although be aware that it is
    possible to craft a “hash collision” using different function
    parameter types).

###### ABI Encoding and Decoding Functions (continued)


### Error Handling

- **assert(bool condition)** - causes a Panic error and thus state change
    reversion if the condition is not met - to be used for internal errors.
- **require(bool condition)** - reverts if the condition is not met - to be used
    for errors in inputs or external components.
- **require(bool condition,string memorymessage)** - reverts if the
    condition is not met -to be used for errors in inputs or external
    components. Also provides an error message.
- **revert()** - abort execution and revert state changes.
- **revert(string memory reason)** - abort execution and revert state
    changes, providing an explanatory string.


### Mathematical and Cryptographic Functions

- **addmod(uint x, uint y, uint k) returns (uint)** - compute(x + y) % k
    where the addition is performed with arbitrary precision and does
    not wrap around at 2**256. Assert that k != 0 starting from version
    0.5.0.
- **mulmod(uint x, uint y, uint k) returns (uint)** – compute (x * y) % k
    where the multiplication is performed with arbitrary precision and
    does not wrap around at 2**256. Assert that k != 0 starting from
    version 0.5.0.
- **keccak256(bytes memory) returns (bytes32)** - compute the
    Keccak-256 hash of the input.
- NOTE: There used to be an alias for keccak256 called SHA3, which
    was removed in version 0.5.0.


- **SHA256(bytes memory) returns (bytes32)** - compute the
    SHA256 hash of the input
- **RIPEMD160(bytes memory) returns (bytes20)** - compute
    RIPEMD160 hash of the input
- **ecrecover(bytes32 hash,uint8 v, bytes32 r, bytes32 s) returns (**
    **address)** - recover the address associated with the public key from
    elliptic curve signature or return zero on error. The function
    parameters correspond to ECDSA values of the signature:
       - r= first 32 bytes of signature
       - s = second 32 bytes of signature
       - v = final 1 byte of signature

###### Mathematical and Cryptographic Functions

###### (continued)


### Members of Address

### Types


### Contract Related

- **this** (current contract’s type) - the current contract, explicitly
    convertible to Address
- **selfdestruct(address payable recipient)** - Destroy the current
    contract, sending its funds to the given Address and end
    execution.
- Note that selfdestruct has some peculiarities inherited from the
    EVM:
       - the receiving contract’s receive function is not executed.
       - the contract is only really destroyed at the end of the transaction and
          revert s might “undo” the destruction.
- Furthermore, all functions of the current contract are callable
    directly including the current function.


### Type Information

- The expression type(X) can be used to retrieve information about
    the type X. Currently, there is limited support for this feature (X can
    be either a contract or an integer type) but it might be expanded in
    the future.
- The following properties are available for a contract type C:
    - **type(C).name** - The name of the contract.
    - **type(C).creationCode** - Memory byte array that contains the creation
       bytecode of the contract.
          - This can be used in inline assembly to build custom creation
             routines, especially by using the create2 opcode.
          - This property can **not** be accessed in the contract itself or any
             derived contract.


- **type(C).runtimeCode -** Memory byte array that contains the
    runtime bytecode of the contract.
       - This is the code that is usually deployed by the constructor of C. If C
          has a constructor that uses inline assembly, this might be different
          from the deployed bytecode.
       - The same restrictions as with .creationCode also apply for this
          property.
- In addition to the properties above, the following properties are
    available for an interface type I:
       - **type(I).interfaceId** – A bytes4 value containing the EIP- 165 interface
          identifier of the given interface I
             - This identifier is defined as the XORof all function selectors
                defined within the interface itself -excluding all inherited
                functions.

### Type Information (continued)


- The following properties are available for an integer type T:
    - **type(T).min** - The smallest value representable by type T
    - **type(T).max** - The largest value representable by typeT

### Type Information (continued)


### Reserved Keywords

These keywords are reserved in Solidity. They might become part of
the syntax in the future:

- after
- alias
- apply
- auto
- byte
- case
- copyof
- default
    - define
    - final
    - implements
    - in
    - inline
    - let
    - macro
    - match
       - mutable
       - null
       - of
       - partial
       - promise
       - reference
       - relocatable
       - sealed
          - sizeof
          - static
          - supports
             switch
          - typedef
          - typeof
          - var


### Summary

- Ether Units
- Time Units
- Special Variables and

Functions

- Globally Available

Variables


### References

- Units and Globally Available Variables — Solidity 0.8.20

documentation (soliditylang.org)



`


`

## Module 09:

## Expressions and Control

## Structures

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Control Structures
- Function Calls
- Creating Contracts via new
- Assignment
- Scoping and Declarations
- Checked or Unchecked

Arithmetic

- Error handling: Asset,

```
Require, Revert and
Exceptions
```

### Control Structures

- The control structures available in Solidity are if, else, while, do, for,
    break, continue,return with the usual semantics known from C or
    JavaScript.
- Solidity also supports exception handling in the form of try / catch-
    statements, but only for external function calls and contract creation
    calls.
- Errors can be created using the revert statement.
- Parentheses can _not_ be omitted for conditionals, but curly braces can be
    omitted around single-statement bodies.
- Note that there is no type conversion from non-boolean to boolean
    types as there is in C and JavaScript, so _if (1) { ...}_ is _not_ valid in Solidity.


### Function Calls

- **Internal Function Calls:**
    - Functions of the current contract can be called directly (“internally”),
       also recursively, as seen in this nonsensical example:
    - These function calls are translated into simple jumps inside the EVM.


- This has the effect that the current memory is not cleared, i.e.,
    passing memory references to internally-called functions is very
    efficient.
- Only functions of the same contract instance can be called
    internally.
- You should still avoid excessive recursion, as every internal function
    call uses up at least one stack slot and there are only 1024 slots
    available.

### Function Calls (continued)


- **External Function Calls:**
    - Functions can also be called using the this.g(8); and c.g(2); notation,
       where c is a contract instance and g is a function belonging to c
       Calling the function g via either way results in it being called
       “externally”, using a message call and not directly via jumps.
    - Please note that function calls on this cannot be used in the
       constructor, as the actual contract has not been created yet.
    - Functions of other contracts must be called externally.
    - For an external call, all function arguments must be copied to
       memory.

### Function Calls (continued)


- A function call from one contract to another does not create its own
    transaction, it is a message call as part of the overall transaction.
- When calling functions of other contracts, you can specify the
    amount of Wei or gas sent with the call with the special options
    {value: 10, gas: 10000}

### Function Calls (continued)


- **Function Calls with Named**
    **Parameters:**
       - Function call arguments can be
          given by name, in any order, if
          they are enclosed in { } as can be
          seen in the following example.
       - The argument list must coincide
          by name with the list of
          parameters from the function
          declaration but can be in arbitrary
          order.

### Function Calls (continued)


- **Omitted Names in Function Definitions:**
    - The names of parameters and return values in the function
       declaration can be omitted.
    - Those items with omitted names will still be present on the stack, but
       they are inaccessible by name.
    - An omitted return value name can still return a value to the caller by
       use of the return statement.

### Function Calls (continued)


### Creating Contracts via new

- A contract can create
    other contracts using the
    new keyword.
- The full code of the
    contract being created
    must be known when the
    creating contract is
    compiled so recursive
    creation-dependencies
    are not possible.


- Salted contract creations / create2:
    - When creating a contract, the address of the contract is
       computed from the address of the creating contract and a
       counter that is increased with each contract creation.
    - If you specify the option salt (a bytes32 value), then contract
       creation will use a different mechanism to produce the address
       of the new contract:
    - It will compute the address from the address of the creating
       contract, the given salt value, the (creation) bytecode of the
       created contract and the constructor arguments.

### Creating Contracts via new (continued)


- The main use-case
    here is contracts that
    act as judges for off-
    chain interactions,
    which only need to be
    created if there is a
    dispute.


- The evaluation order of expressions is not specified (more
    formally, the order in which the children of one node in the
    expression tree are evaluated is not specified, but they are of
    course evaluated before the node itself).
- It is only guaranteed that statements are executed in order and
    short-circuiting for boolean expressions is done.

### Order of Evaluation of Expressions


### Assignment

**Destructuring Assignments and Returning Multiple Values:**

- Solidity internally allows tuple types, i.e., a list of objects of potentially
    different types whose number is a constant at compile-time.
- Those tuples can be used to return multiple values at the same time.
- These can then either be assigned to newly declared variables or to pre-
    existing variables (or LValues in general).
- Tuples are not proper types in Solidity, they can only be used to form
    syntactic groupings of expressions.



### Assignment (continued)

**Complications for Arrays and
Structs:**

- The semantics of assignments
    are more complicated for non-
    value types like arrays and
    structs, including bytes and
    string
- In this e.g., the call to g(x) has no
    effect on x because it creates an
    independent copy of the
    storage value in memory.
- However, h(x) successfully
    modifies x because only a
    reference and not a copy is
    passed.


### Scoping and Declarations

- Scoping in Solidity follows the widespread scoping rules of C99
    (and many other languages):
       - Variables are visible from the point right after their declaration
          until the end of the smallest { } -block that contains the
          declaration.
       - As an exception to this rule, variables declared in the
          initialization part of a for-loop are only visible until the end of
          the for-loop.


- Variables that are parameter-like (function parameters, modifier
    parameters, catch parameters, ...) are visible inside the code block
    that follows - the body of the function / modifier for a function and
    modifier parameter and the catch block for a catch parameter.
- Variables and other items declared outside of a code block, for
    example functions, contracts, user-defined types, etc., are visible
    even before they were declared. This means you can use state
    variables before they are declared and call functions recursively.

### Scoping and Declarations (continued)


- This example will
    compile without
    warnings, since the two
    variables have the same
    name but disjoint
    scopes.

### Scoping and Declarations (continued)


### Checked or Unchecked Arithmetic

- An overflow or underflow is the situation where the resulting value
    of an arithmetic operation, when executed on an unrestricted
    integer, falls outside the range of the result type.
- Prior to Solidity 0.8.0, arithmetic operations would always wrap in
    case of under- or overflow leading to widespread use of libraries
    that introduce additional checks.
- Since Solidity 0.8.0, all arithmetic operations revert on over- and
    underflow by default, thus making the use of these libraries
    unnecessary.


- To obtain the previous behavior, an _unchecked_ block can be

```
used:
```
### Checked or Unchecked Arithmetic (continued)


### Error handling: Assert, Require, Revert and

### Exceptions

- Solidity uses state-reverting exceptions to handle errors.
- Such an exception undoes all changes made to the state in the
    current call (and all its sub-calls) and flags an error to the caller.
- When exceptions happen in a sub-call, they “bubble up” (i.e.,
    exceptions are rethrown) automatically unless they are caught in a
    try / catch statement.
- Exceptions to this rule are send and the low-level functions call,
    delegatecall and staticcall: they return falseas their first return
    value in case of an exception instead of “bubbling up”.


- The low-level functions call,delegatecall and staticcall return true
    as their first return value if the account called is non-existent, as
    part of the design of the EVM.
- Account existence must be checked prior to calling if needed.
- Exceptions can contain error data that is passed back to the caller
    in the form of error instances.
- The built-in errors Error(string) and Panic(uint256) are used by
    special functions, as explained below.
- Error is used for “regular” error conditions while Panic is used for
    errors that should not be present in bug-free code.

### Error handling: Assert, Require, Revert and

### Exceptions (continued)


**Panic via assert and Error via require:**

- The convenience functions assert and require can be used to check
    for conditions and throw an exception if the condition is not met.
- The assert function creates an error of type Panic(uint256).
- The same error is created by the compiler in certain situations.
- Assert should only be used to test for internal errors, and to check
    invariants.
- Properly functioning code should never create a Panic, not even on
    invalid external input.

### Error handling: Assert, Require, Revert and

### Exceptions (continued)


- If this happens, then there is a bug in your contract which you should
    fix.
- Language analysis tools can evaluate your contract to identify the
    conditions and function calls which will cause a Panic.
- A Panic exception is generated in the following situations. The error
    code supplied with the error data indicates the kind of panic.
       - 0x00: Used for generic compiler inserted panics.
       - 0x01: If you call assert with an argument that evaluates to false
       - 0x11: If an arithmetic operation results in underflow or overflow outside
          of an unchecked { ...} block.

### Error handling: Assert, Require, Revert and

### Exceptions (continued)


- 0x12: If you divide or modulo by zero (e.g.,5/0 or 23 % 0 ).
- 0x21: If you convert a value that is too big or negative into an enum type.
- 0x22: If you access a storage byte array that is incorrectly encoded.
- 0x31: If you call .pop() on an empty array.
- 0x32: If you access an array, bytesN or an array slice at an out-of-bounds
    or negative index (i.e.,x[i] where i >= x.length or i < 0 ).
- 0x41: If you allocate too much memory or create an array that is too
    large.
- 0x51: If you call a zero-initialized variable of internal function type.

### Error handling: Assert, Require, Revert and

### Exceptions (continued)


- The require function either creates an error without any data or an
    error of type Error(string)
- It should be used to ensure valid conditions that cannot be
    detected until execution time.
- This includes conditions on inputs or return values from calls to
    external contracts.
- If you do not provide a string argument to require, it will revert with
    empty error data, not even including the error selector.

### Error handling: Assert, Require, Revert and

### Exceptions (continued)


- This example shows how you can use require to check conditions
    on inputs and assert for internal error checking.

### Error handling (continued)


### revert

- A direct revert can be triggered using the revert statement and the
    revert function.
- The revert statement takes a custom error as direct argument
    without parentheses: revert CustomError(arg1, arg2);
- For backwards-compatibility reasons, there is also therevert()
    function, which uses parentheses and accepts a string: revert();
    revert(“description”);
- The error data will be passed back to the caller and can be caught
    there.
- Using a custom error instance will usually be much cheaper than a
    string description, because you can use the name of the error to
    describe it, which is encoded in only four bytes.


- This example shows how to use
    an error string and a custom
    error instance together with
    revert and the equivalent
    require:


### try / catch

- A failure in an external call can be caught using a try / catch
    statement, as shown in next slide:
- The try keyword must be followed by an expression representing
    an external function call or a contract creation new ContractName()



- Errors inside the expression are not caught (for example if it is a
    complex expression that also involves internal function calls), only a
    revert happening inside the external call itself.
- The returns part (which is optional) that follows declares return
    variables matching the types returned by the external call.
- In case there was no error, these variables are assigned, and the
    contract’s execution continues inside the first success block.
- If the end of the success block is reached, execution continues
    after the catch blocks.

### try / catch (continued)


### Summary

- Control Structures
- Function Calls
- Creating Contracts via new
- Assignment
- Scoping and Declarations
- Checked or Unchecked

Arithmetic

- Error handling: Asset,

```
Require, Revert and
Exceptions
```

### References

- https://docs.soliditylang.org/en/latest/control-structures.html#



`


`

## Module 09:

## Inline Assembly

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Inline Assembly
- Access to External

```
Variables, Functions and
Libraries
```
- Things to Avoid
- Conventions in Solidity


### Inline Assembly

- Inline assembly is a way to access the Ethereum Virtual Machine at
    a low level.
- This bypasses several important safety features and checks of
    Solidity.
- You can interleave Solidity statements with inline assembly in a
    language close to the one of the Ethereum Virtual Machine.
- This gives you more fine-grained control, which is especially useful
    when you are enhancing the language by writing libraries.
- The language used for inline assembly in Solidity is called **Yul**.


- An inline assembly block is marked by assembly { ...}, where the code
    inside the curly braces is code in the Yul language.
- The inline assembly code can access local Solidity variables as explained
    below.
- Different inline assembly blocks share no namespace, i.e., it is not
    possible to call a Yul function or access a Yul variable defined in a
    different inline assembly block.
- Inline assembly is also beneficial in cases where the optimizer fails to
    produce efficient code.
- The following e.g., provides library code to access the code of another
    contract and load it into a byte's variable.

### Inline Assembly (continued)



### Access to External Variables, Functions and

### Libraries

- You can access Solidity variables and other identifiers by using their name.
- Local variables of value type are directly usable in inline assembly. They
    can both be read and assigned to.
- Local variables that refer to memory evaluate to the address of the variable
    in memory, not the value itself.
- Local variables that refer to statically-sized calldata arrays or calldata
    structs evaluate to the address of the variable in calldata, not the value
    itself.


- The variable can also be assigned a new offset, but note that no
    validation is performed to ensure that the variable will not point
    beyond calldatasize()
- For external function pointers the address and the function selector
    can be accessed using x.address and x.selector.
- The selector consists of four right-aligned bytes.
- Both values can be assigned to.
- For external function pointers the address and the function selector
    can be accessed using x.address and x.selector.

### Access to External Variables, Functions and

### Libraries (continued)


- For dynamic calldata arrays, you can access their calldata offset (in
    bytes) and length (number of elements) using x.offset and x.length.
- Both expressions can also be assigned to, but as for the static case,
    no validation will be performed to ensure that the resulting data
    area is within the bounds of calldatasize().
- For local storage variables or state variables, a single Yul identifier
    is not sufficient, since they do not necessarily occupy a single full
    storage slot.
- Therefore, their “address” is composed of a slot and a byte-offset
    inside that slot.

### Access to External Variables, Functions and

### Libraries (continued)


- To retrieve the slot pointed to by the variable x, you use x.slot, and to
    retrieve the byte-offset you use x.offset.
- You can also assign to the .slot part of a local storage variable pointer.
- For these (structs, arrays or mappings), the .offset part is always zero.
- It is not possible to assign to the .slot or .offset part of a state variable,
    though.
- Local Solidity variables are available for assignments.

### Access to External Variables, Functions and

### Libraries (continued)


- **Example:**


### Things to Avoid

- Inline assembly might have a quite high-level look, but it actually is
    extremely low-level.
- Function calls, loops, ifs and switches are converted by simple
    rewriting rules and after that, the only thing the assembler does for
    you is re-arranging functional-style opcodes, counting stack height
    for variable access and removing stack slots for assembly-local
    variables when the end of their block is reached.


### Conventions in Solidity

**Values of Typed Variables:**

- In contrast to EVM assembly, Solidity has types which are narrower
    than 256 bits.
- For efficiency, most arithmetic operations ignore the fact that types
    can be shorter than 256 bits, and the higher-order bits are cleaned,
    when necessary, i.e., shortly before they are written to memory or
    before comparisons are performed.
- This means that if you access such a variable from within inline
    assembly, you might have to manually clean the higher-order bits
    first.


**Memory Management:**

- There is a “free memory pointer” at position 0x40 in memory.
- If you want to allocate memory, use the memory starting from where this
    pointer points at and update it.
- There is no guarantee that the memory has not been used before and
    thus you cannot assume that its contents are zero bytes.
- There is no built-in mechanism to release or free allocated memory.

### Conventions in Solidity (continued)


- The first 64 bytes of memory can be used as “scratch space” for short-
    term allocation.
- The 32 bytes after the free memory pointer (i.e., starting at 0x60) are
    meant to be zero permanently and is used as the initial value for empty
    dynamic memory arrays.
- This means that the allocatable memory starts at 0x80, which is the initial
    value of the free memory pointer.
- Elements in memory arrays in Solidity always occupy multiples of 32
    bytes.
- Multi-dimensional memory arrays are pointers to memory arrays.
- The length of a dynamic array is stored at the first slot of the array and
    followed by the array elements.

### Conventions in Solidity (continued)


**Memory Safety:**

- Without the use of inline assembly, the compiler can rely on memory to
    always remain in a well-defined state.
- This is especially relevant for the new code generation pipeline via Yul
    IR: this code generation path can move local variables from stack to
    memory to avoid stack-too-deep errors and perform additional memory
    optimizations, if it can rely on certain assumptions about memory use.
- Inline assembly allows you to use memory in an incompatible way.
- Moving stack variables to memory and additional memory optimizations
    are, by default, globally disabled in the presence of any inline assembly
    block that contains a memory operation or assigns to Solidity variables in
    memory.

### Conventions in Solidity (continued)


- A memory-safe assembly block may only access the following
    memory ranges:
       - Memory allocated by yourself using a mechanism like the allocate
          function described above.
       - Memory allocated by Solidity, e.g., memory within the bounds of a
          memory array you reference.
       - The scratch space between memory offset 0 and 64 mentioned
          above.
       - Temporary memory that is located _after_ the value of the free memory
          pointer at the beginning of the assembly block, i.e., memory that is
          “allocated” at the free memory pointer without updating the free
          memory pointer.

### Conventions in Solidity (continued)


### Cheatsheet

- https://docs.soliditylang.org/en/latest/cheatsheet.html
- Cheatsheet contains:
    - Order of Precedence of Operators
    - Global Variables
    - Function Visibility Specifiers
    - Modifiers


### Summary

- Inline Assembly
- Access to External

```
Variables, Functions and
Libraries
```
- Things to Avoid
- Conventions in Solidity


### References

- https://docs.soliditylang.org/en/latest/assembly.html#
- https://docs.soliditylang.org/en/latest/cheatsheet.html



`


`

## Module 10:

## Ethereum Transactions

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- What’s a Transaction?
- The Data Field
- Types of Transactions
- On Gas
- Transaction Lifecycle
- Typed Transaction

Envelope


### Ethereum Transactions

- Transactions are cryptographically signed instructions from
    accounts.
- An account will initiate a transaction to update the state of the
    Ethereum network.
- The simplest transaction is transferring ETH from one account to
    another.
- An Ethereum transaction refers to an action initiated by an
    externally-owned account, in other words an account managed by
    a human, not a contract.


### What’s a Transaction?

- For example, if Bob sends Alice 1 ETH, Bob's account must be
    debited, and Alice's must be credited. This state-changing action
    takes place within a transaction.


- Transactions, which change the state of the EVM, need to be
    broadcast to the whole network.
- Any node can broadcast a request for a transaction to be executed
    on the EVM; after this happens, a validator will execute the
    transaction and propagate the resulting state change to the rest of
    the network.
- Transactions require a fee and must be included in a validated
    block. To make this overview simpler we'll cover gas fees and
    validation elsewhere.

### What’s a Transaction? (continued)


A submitted transaction includes the following information:

- **from** – the address of the sender, that will be signing the
    transaction. This will be an externally-owned account as contract
    accounts cannot send transactions.
- **recipient** – the receiving address (if an externally-owned account,
    the transaction will transfer value. If a contract account, the
    transaction will execute the contract code)
- **signature** – the identifier of the sender. This is generated when the
    sender's private key signs the transaction and confirms the sender
    has authorized this transaction
- **nonce** - a sequentially incrementing counter which indicates the
    transaction number from the account

### What’s a Transaction? (continued)


- **value** – amount of ETH to transfer from sender to recipient
    (denominated in WEI, where 1ETH equals 1e+18wei)
- **data** – optional field to include arbitrary data
- **gasLimit** – the maximum amount of gas units that can be
    consumed by the transaction. The EVM specifies the units of gas
    required by each computational step
- **maxPriorityFeePerGas** - the maximum price of the consumed gas
    to be included as a tip to the validator
- **maxFeePerGas** - the maximum fee per unit of gas willing to be
    paid for the transaction (inclusive of baseFeePerGas and
    maxPriorityFeePerGas)

### What’s a Transaction? (continued)


- Gas is a reference to the computation required to process the
    transaction by a validator.
- Users must pay a fee for this computation.
- The gasLimit, and maxPriorityFeePerGas determine the maximum
    transaction fee paid to the validator.
- The transaction object will look a little like this:

### What’s a Transaction? (continued)


- But a transaction object needs to be signed using the sender's
    private key.
- This proves that the transaction could only have come from the
    sender and was not sent fraudulently.
- An Ethereum client like Geth will handle this signing process.
- With the signature hash, the transaction can be cryptographically
    proven that it came from the sender and submitted to the network.

### What’s a Transaction? (continued)


### The Data Field

- Most transactions access a contract from an externally-owned
    account.
- Most contracts are written in Solidity and interpret their data field in
    accordance with the application binary interface (ABI).
- The first four bytes specify which function to call, using the hash of
    the function's name and arguments.
- The rest of the calldata is the arguments, encoded as specified in
    the ABI specs.


### Types of Transactions

- On Ethereum there are a few different types of transactions:
    - **Regular transactions:** a transaction from one account to
       another.
    - **Contract deployment transactions:** a transaction without a 'to'
       address, where the data field is used for the contract code.
    - **Execution of a contract:** a transaction that interacts with a
       deployed smart contract. In this case, 'to' address is the smart
       contract address.


### On Gas

- Transactions cost _gas_ to execute. Simple transfer transactions
    require 21000 units of Gas.
- So, for Bob to send Alice 1 ETH at a baseFeePerGas of 190 gwei
    and maxPriorityFeePerGas of 10 gwei, Bob will need to pay the
    following fee:
       - (190 + 10) * 21000 = 4,200,000 gwei --or-- 0.0042 ETH
- Bob's account will be debited **- 1.0042 ETH** (1 ETH for Alice +
    0.0042 ETH in gas fees)
- Alice's account will be credited **+1.0 ETH**
- The base fee will be burned **- 0.00399 ETH**
- Validator keeps the tip **+0.000210 ETH**


- Gas is required for any smart contract interaction too.
- Any gas not used in a transaction is refunded to the user account.

### On Gas (continued)


### Transaction Lifecycle

- Once the transaction has been submitted the following happens:
1. A transaction hash is cryptographically generated:
    0x97d99bc7729211111a21b12c933c949d4f31684f1d6954ff477
    d0477538ff017
2. The transaction is then broadcasted to the network and added to
    a transaction pool consisting of all other pending network
    transactions.
3. A validator must pick your transaction and include it in a block in
    order to verify the transaction and consider it "successful".


4. As time passes the block containing your transaction will be
    upgraded to "justified" then "finalized".
- These upgrades make it much more certain that your
transaction was successful and will never be altered.
- Once a block is "finalized" it could only ever be changed by a
network level attack that would cost many billions of dollars.

### Transaction Lifecycle (continued)


### Typed Transaction Envelope

- Ethereum originally had one format for transactions.
- Each transaction contained a nonce, gas price, gas limit, to

address, value, data, v, r, and s.

- These fields are RLP-encoded, to look something like this:
    - RLP([nonce, gasPrice, gasLimit, to, value, data, v, r, s])
- Ethereum has evolved to support multiple types of

```
transactions to allow for new features such as access lists
and EIP- 1559 to be implemented without affecting legacy
transaction formats.
```
- _EIP- 2718_ is what allows for this behavior.


- Transactions are interpreted as:
    - TransactionType || TransactionPayload

```
where the fields are defined as:
```
- TransactionType - a number between 0 and 0x7f, for a total of
    128 possible transaction types.
- TransactionPayload - an arbitrary byte array defined by the
    transaction type

### Typed Transaction Envelope (continued)


### Summary

- What’s a Transaction?
- The Data Field
- Types of Transactions
- On Gas
- Transaction Lifecycle
- Typed Transaction

Envelope


### References

- https://ethereum.org/en/developers/docs/transactions/



`


`

## Module 10:

## Ethereum Blocks

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Why blocks?
- How blocks work?
- POS Protocol
- What’s in a block?
- Block time
- Block size


### Ethereum Blocks

- Blocks are batches of transactions with a hash of the previous block
    in the chain.
- This links blocks together (in a chain) because hashes are
    cryptographically derived from the block data.
- This prevents fraud, because one change in any block in history
    would invalidate all the following blocks as all subsequent hashes
    would change and everyone running the blockchain would notice.


### Why blocks?

- To ensure that all participants on the Ethereum network maintain a
    synchronized state and agree on the precise history of transactions, we
    batch transactions into blocks.
- This means dozens (or hundreds) of transactions are committed, agreed
    on, and synchronized all at once.


- By spacing out commits, we give all network participants enough
    time to come to consensus: even though transaction requests
    occur dozens of times per second, blocks are only created and
    committed on Ethereum once every twelve seconds.

### Why blocks? (Continued)


### How blocks work?

- To preserve the transaction history, blocks are strictly ordered
    (every new block created contains a reference to its parent block),
    and transactions within blocks are strictly ordered as well.
- Except in rare cases, at any given time, all participants on the
    network agree on the exact number and history of blocks and are
    working to batch the current live transaction requests into the next
    block.
- Once a block is put together by a randomly selected validator on
    the network, it is propagated to the rest of the network; all nodes
    add this block to the end of their blockchain, and a new validator is
    selected to create the next block.


- The exact block-assembly process and commitment / consensus
    process is currently specified by Ethereum’s “proof-of-stake”
    protocol.

### How blocks work? (continued)


### POS Protocol

- Validating nodes must stake 32 ETH into a deposit contract as
    collateral against bad behavior.
       - This helps protect the network because provably dishonest
          activity leads to some, or all that stake being destroyed.
- In every slot (spaced twelve seconds apart) a validator is randomly
    selected to be the block proposer.
       - They bundle transactions together, execute them and
          determine a new 'state’.
       - They wrap this information into a block and pass it around to
          other validators.


- Other validators who hear about the new block re-execute the
    transactions to ensure they agree with the proposed change to the
    global state.
       - Assuming the block is valid, they add it to their own database.
- If a validator hears about two conflicting blocks for the same slot
    they use their fork-choice algorithm to pick the one supported by
    the most staked ETH.

### POS Protocol (continued)


### What’s in a block?

**Field Description**

slot the slot the block belongs to

proposer_index the ID of the validator proposing the block

parent_root the hash of the preceding block

state_root the root hash of the state object

body an object containing several fields, as defined below

- At the highest level, a block contains the following fields:


### What’s in a block? (continued)

**Field Description**

randao_reveal a value used to select the next block proposer

eth1_data information about the deposit contract

graffiti arbitrary data used to tag blocks

proposer_slashings list of validators to be slashed

attester_slashings list of validators to be slashed

attestations list of attestations in favor of the current block

deposits list of new deposits to the deposit contract

voluntary_exits list of validators exiting the network

sync_aggregate subset of validators used to serve light clients

execution_payload transactions passed from the execution client

- The block body contains several fields of its own:


### What’s in a block? (continued)

- The attestations field contains a list of all the attestations in the

```
block.
```
- Attestations have their own data type that contains several pieces

```
of data.
```
- Each attestation contains:

**Field Description**

aggregation_bits a list of which validators participated in this attestation

data a container with multiple subfields

signature aggregate signature of all attesting validators


### What’s in a block? (continued)

**Field Description**

slot the slot the attestation relates to

index indices for attesting validators

beacon_block_root the root hash of the Beacon block containing this object

source the last justified checkpoint

target the latest epoch boundary block

- The data field in the attestation contains the following:


- Executing the transactions in the execution_payload updates the
    global state.
- All clients re-execute the transactions in the execution_payload to
    ensure the new state matches that in the new block state_root field.
- This is how clients can tell that a new block is valid and safe to add
    to their blockchain.
- The execution_payload itself is an object with several fields.
- There is also an execution_payload_header

### What’s in a block? (continued)


### What’s in a block? (continued)

**Field Description**
parent_hash hash of the parent block
fee_recipient account address for paying transaction fees to

state_root root hash for the global state after applying changes in this block

receipts_root hash of the transaction receipts trie
logs_bloom data structure containing event logs
prev_randao value used in random validator selection
block_number the number of the current block
gas_limit maximum gas allowed in this block
gas_used the actual amount of gas used in this block
timestamp the block time
extra_data arbitrary additional data as raw bytes
base_fee_per_gas the base fee value
block_hash Hash of execution block
transactions_root root hash of the transactions in the payload

- The execution_payload_header contains the following fields:


### What’s in a block? (continued)

**Field Description**
parent_hash hash of the parent block
fee_recipient account address for paying transaction fees to
state_root root hash for the global state after applying changes in this block
receipts_root hash of the transaction receipts trie
logs_bloom data structure containing event logs
prev_randao value used in random validator selection
block_number the number of the current block
gas_limit maximum gas allowed in this block
gas_used the actual amount of gas used in this block
timestamp the block time
extra_data arbitrary additional data as raw bytes
base_fee_per_gas the base fee value
block_hash Hash of execution block
transactions list of transactions to be executed

- The execution_payload contains the following fields:


### Block Time

- Block time refers to the time separating blocks.
- In Ethereum, time is divided up into twelve second units called 'slots’.
- In each slot a single validator is selected to propose a block.
- Assuming all validators are online and fully functional there will be a
    block in every slot, meaning the block time is 12s.
- However, occasionally validators might be offline when called to
    propose a block, meaning slots can sometimes go empty.
- This implementation differs from proof-of-work based systems where
    block times are probabilistic and tuned by the protocol's target mining
    difficulty.


### Block Size

- Blocks themselves are bounded in size.
- Each block has a target size of 15 million gas, but the size of blocks
    will increase or decrease in accordance with network demands, up
    until the block limit of 30 million gas (2x target block size).
- The total amount of gas expended by all transactions in the block
    must be less than the block gas limit.
- This is important because it ensures that blocks can’t be arbitrarily
    large.


- If blocks could be arbitrarily large, then less performant full nodes
    would gradually stop being able to keep up with the network due
    to space and speed requirements.
- The larger the block, the greater the computing power required to
    process them in time for the next slot.
- This is a centralizing force, which is resisted by capping block sizes.

### Block Size (continued)


### Summary

- Why blocks?
- How blocks work?
- POS Protocol
- What’s in a block?
- Block time
- Block size


### References

- Blocks | ethereum.org



`


`

## Module 10:

## Ethereum Node

## Architecture

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Ethereum Node

Architecture

- What does the Execution

Client do?

- What does the Consensus

Client do?

- Validators
- Components of a Node

Comparison


### Ethereum Node Architecture

- An Ethereum node is composed of two clients: an execution client and
    a consensus client.
- When Ethereum was using proof-of-work, an execution client was
    enough to run a full Ethereum node. However, since
    implementing proof-of-stake, the execution client needs to be used
    alongside another piece of software called a “consensus client”.
- The diagram in the next slide shows the relationship between the two
    Ethereum clients.
- The two clients connect to their own respective peer-to-peer (P2P)
    networks.


Separate P2P networks are
needed as the execution clients
gossip transactions over their P2P
network, enabling them to
manage their local transaction
pool, whilst the consensus clients
gossip blocks over their P2P
network, enabling consensus and
chain growth.

```
This image is borrowed from
geth.ethereum.org and uses the Geth logo to
represent execution clients -there are other
options for the execution client including
Erigon, Nethermind and Besu
```

- For this two-client structure to work, consensus clients must be able to
    pass bundles of transactions to the execution client.
- Executing the transactions locally is how the client validates that the
    transactions do not violate any Ethereum rules and that the proposed
    update to Ethereum’s state is correct.
- Likewise, when the node is selected to be a block producer the
    consensus client must be able to request bundles of transactions from
    Geth to include in the new block and execute them to update the global
    state.
- This inter-client communication is handled by a local RPC connection
    using the engine API.

### Ethereum Node Architecture (continued)


### What does the Execution Client do?

- The execution client is responsible for transaction handling,
    transaction gossip, state management and supporting the EVM.
- The execution client creates execution payloads - the list of
    transactions, updated state trie, and other execution-related data.
- The execution client is also responsible for re-executing
    transactions in new blocks to ensure they are valid. Executing
    transactions is done on the execution client's embedded
    computer, known as the EVM.


#### What does the Execution Client do? (continued)

- The execution client also offers a user interface to Ethereum
    through RPC methods that enable users to query the Ethereum
    blockchain, submit transactions and deploy smart contracts.
- The execution client is:
    - a user gateway to Ethereum.
    - home to the Ethereum Virtual Machine, Ethereum's state and
       transaction pool.


- The consensus client deals with all the logic that enables a node to stay
    in sync with the Ethereum network.
- This includes receiving blocks from peers and running a fork choice
    algorithm to ensure the node always follows the chain with the greatest
    accumulation of attestations.
- The consensus client does not participate in attesting to or proposing
    blocks -this is done by a validator, an optional add-on to a consensus
    client.
- A consensus client without a validator only keeps up with the head of the
    chain, allowing the node to stay synced.
- This enables a user to transact with Ethereum using their execution
    client, confident that they are on the correct chain.

### What does a Consensus Client do?


### Validators

- Node operators can add a validator to their consensus clients by
    depositing 32 ETH in the deposit contract.
- The validator client comes bundled with the consensus client and
    can be added to a node at any time.
- The validator handles attestations and block proposals.
- They enable a node to accrue rewards or lose ETH via penalties or
    slashing.
- Running the validator software also makes a node eligible to be
    selected to propose a new block.


### Components of a Node Comparison

```
Execution Client Consensus Client Validator
```
Gossips transactions over its
p2p network

```
Gossips blocks and
attestations overs its p2p
network
```
```
Proposes blocks
```
Executes/re-executes
transactions

```
Runs the fork choice
algorithm Accrues rewards/penalties
```
Verifies incoming state
changes

```
Keeps track of the head of
the chain Makes attestations
```
Manages state and receipts
tries

```
Manages the Beacon state
(contains consensus and
execution info)
```
```
Requires 32 ETH to be
staked
```
Creates execution payload Keeps track of accumulated randomness in RANDAO Proposes blocks

Exposes JSON-RPC API for
interacting with Ethereum

```
Keeps track of justification
and finalization Can be slashed
```

### Summary

- Ethereum Node

Architecture

- What does the Execution

Client do?

- What does the Consensus

Client do?

- Validators
- Components of a Node

Comparison


### References

- https://ethereum.org/en/developers/docs/nodes-and-

clients/node-architecture/



`


`

## Module 10:

## Ethereum Consensus

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Consensus Mechanism
- Proof of Stake (POS)
- Validators
- How a Transaction gets
    executed in Ethereum POS?
- Finality
- Crypto-Economic Security
- Fork Choice
- POS and Security
- Pros and Cons of POS
- Sybil Resistance & Chain
    Selection


### What is Consensus?

- By consensus, we mean that a general agreement has been
    reached.
- Regarding the Ethereum blockchain, the process is formalized, and
    reaching consensus means that at least 66% of the nodes on the
    network agree on the global state of the network.


- The term consensus mechanism refers to the entire stack of protocols,
    incentives and ideas that allow a network of nodes to agree on the state
    of a blockchain.
- Ethereum uses a proof-of-stake-based consensus mechanism that
    derives its crypto-economic security from a set of rewards and penalties
    applied to capital locked by stakers.
- This incentive structure encourages individual stakers to operate as
    honest validators, punishes those who don't, and creates an extremely
    high cost to attack the network.
- There is a protocol that governs how honest validators are selected to
    propose or validate blocks, process transactions and vote for their view
    of the head of the chain.

### Consensus Mechanism


- In the rare situations where multiple blocks are in the same position
    near the head of the chain, there is a fork-choice mechanism that
    selects blocks that make up the 'heaviest' chain, measured by the
    number of validators that voted for the blocks weighted by their
    staked ether balance.
- Some concepts are important to consensus that are not explicitly
    defined in code, such as the additional security offered by
    potential out-of-band social coordination as a last line of defense
    against attacks on the network.
- These components together form the consensus mechanism.
- Ethereum uses a consensus mechanism known as Gasper that
    combines Casper FFG proof-of-stake with the GHOST fork-choice
    rule.

### Consensus Mechanism (continued)


### Proof of Stake based Consensus Mechanism

- **Block creation:**
    - Validators create blocks.
    - One validator is randomly selected in each slot to be the block
       proposer.
    - Their consensus client requests a bundle of transactions as an
       'execution payload' from their paired execution client.
    - They wrap this in consensus data to form a block, which they
       send to other nodes on the Ethereum network.
    - This block production is rewarded in ETH.
    - In rare cases when multiple possible blocks exist for a single
       slot, or nodes hear about blocks at different times, the fork
       choice algorithm picks the block that forms the chain with the
       greatest weight of attestations (where weight is the number of
       validators attesting scaled by their ETH balance).


- **Security**
    - A proof-of-stake system is secure crypto-economically because an
       attacker attempting to take control of the chain must destroy a
       massive amount of ETH.
    - A system of rewards incentivizes individual stakers to behave
       honestly, and penalties disincentivize stakers from acting maliciously.
- POS alone are not consensus protocols but are Sybil resistance
    mechanisms and block author selectors; they are a way to decide
    who is the author of the latest block.
- Another important component is the chain selection (aka fork
    choice) algorithm that enables nodes to pick one single correct
    block at the head of the chain in scenarios where multiple blocks
    exist in the same position.

### POS based Consensus Mechanism (continued)


### Proof of Stake

- Proof of Stake comes with several improvements :
    - Better energy efficiency – there is no need to use lots of energy on
       proof-of-stake computations
    - Lower barriers to entry, reduced hardware requirements –there is no
       need for elite hardware to stand a chance of creating new blocks
    - Reduced centralization risk – proof-of-stake should lead to more
       nodes securing the network
    - Because of the low energy requirement less ETH issuance is required
       to incentivize participation
    - Economic penalties for misbehavior make 51% style attacks
       exponentially more costly for an attacker compared to proof-of-work
    - The community can resort to social recovery of an honest chain if a
       51% attack were to overcome the crypto-economic defenses


### Validators

- To participate as a validator, a user must deposit 32 ETH into the deposit
    contract and run three separate pieces of software: an execution client, a
    consensus client, and a validator.
- On depositing their ETH, the user joins an activation queue that limits
    the rate of new validators joining the network.
- Once activated, validators receive new blocks from peers on the
    Ethereum network.
- The transactions delivered in the block are re-executed, and the block
    signature is checked to ensure the block is valid.
- The validator then sends a vote (called an attestation) in favor of that
    block across the network.


- Whereas under proof-of-work, the timing of blocks is determined
    by the mining difficulty, in proof-of-stake, the tempo is fixed.
- Time in proof-of-stake Ethereum is divided into slots (12 seconds)
    and epochs (32 slots).
- One validator is randomly selected to be a block proposer in every
    slot.
- This validator is responsible for creating a new block and sending it
    out to other nodes on the network.
- Also in every slot, a committee of validators is randomly chosen,
    whose votes are used to determine the validity of the block being
    proposed.

### Validators (continued)


### How a Transaction gets executed in Ethereum POS

1. A user creates and signs a transaction with their private key.
    - This is usually handled by a wallet or a library such
       as ether.js,web3js,web3py etc. but under the hood the user is
       making a request to a node using the Ethereum JSON-RPC API.
    - The user defines the amount of gas that they are prepared to pay
       as a tip to a validator to encourage them to include the
       transaction in a block.
    - The tips get paid to the validator while the base fee gets burned.
2. The transaction is submitted to an Ethereum execution
    client which verifies its validity.
    - This means ensuring that the sender has enough ETH to fulfill the
       transaction and they have signed it with the correct key.


3. If the transaction is valid, the execution client adds it to its local
    mempool (list of pending transactions) and broadcasts it to other
    nodes over the execution layer gossip network.
- When other nodes hear about the transaction, they add it to
their local mempool too.
- Advanced users might refrain from broadcasting their
transaction and insteads forward it to specialized block builders
such as _Flashbots Auction_.
- This allows them to organize the transactions in upcoming
blocks for maximum profit (MEV).

### How a Transaction gets executed in Ethereum POS


4. One of the nodes on the network is the block proposer for the
    current slot, having previously been selected pseudo-randomly
    using RANDAO.
- This node is responsible for building and broadcasting the next
block to be added to the Ethereum blockchain and updating
the global state.
- The node is made up of three parts: an execution client, a
consensus client and a validator client.
- The execution client bundles transactions from the local
mempool into an "execution payload" and executes them
locally to generate a state change.

### How a Transaction gets executed in Ethereum POS


- This information is passed to the consensus client where the
    execution payload is wrapped as part of a "beacon block" that
    also contains information about rewards, penalties, slashings,
    attestations etc. that enable the network to agree on the
    sequence of blocks at the head of the chain.
5. Other nodes receive the new beacon block on the consensus
layer gossip network.
- They pass it to their execution client where the transactions are
    re-executed locally to ensure the proposed state change is valid.
- The validator client then attests that the block is valid and is the
    logical next block in their view of the chain (meaning it builds on
    the chain with the greatest weight of attestations as defined in
    the fork choice rules).

### How a Transaction gets executed in Ethereum POS


- The block is added to the local database in each node that
    attests to it.
6. The transaction can be considered "finalized", i.e., that it cannot
be reverted, if it has become part of a chain with a "supermajority
link" between two checkpoints.
- Checkpoints occur at the start of each epoch and to have a
    supermajority link they must both be attested to by 66% of the
    total staked ETH on the network.

### How a Transaction gets executed in Ethereum POS


### Finality

- A transaction has "finality" in distributed networks when it's part of
    a block that can't change without a significant amount of ETH
    getting burned.
- On proof-of-stake Ethereum, this is managed using "checkpoint"
    blocks. The first block in each epoch is a checkpoint.
- Validators vote for pairs of checkpoints that it considers to be valid.
- If a pair of checkpoints attracts votes representing at least two-
    thirds of the total staked ETH, the checkpoints are upgraded.
- The more recent of the two (target) becomes "justified".
- The earlier of the two is already justified because it was the "target"
    in the previous epoch. Now it is upgraded to "finalized".


- To revert a finalized block, an attacker would commit to losing at
    least one-third of the total supply of staked ETH.
- Since finality requires a two-thirds majority, an attacker could
    prevent the network from reaching finality by voting with one-third
    of the total stake.
- There is a mechanism to defend against this: the inactivity leak.This
    activates whenever the chain fails to finalize for more than four
    epochs.
- The inactivity leak bleeds away the staked ETH from validators
    voting against the majority, allowing the majority to regain a two-
    thirds majority and finalize the chain.

### Finality (continued)


### Crypto-Economic Security

- Running a validator is a commitment.
- The validator is expected to maintain sufficient hardware and
    connectivity to participate in block validation and proposal.
- In return, the validator is paid in ETH (their staked balance increases).
- On the other hand, participating as a validator also opens new avenues
    for users to attack the network for personal gain or sabotage.
- To prevent this, validators miss out on ETH rewards if they fail to
    participate when called upon, and their existing stake can be destroyed
    if they behave dishonestly.
- There are two primary behaviors that can be considered dishonest:
    proposing multiple blocks in a single slot (equivocating) and submitting
    contradictory attestations.


- The amount of ETH slashed depends on how many validators are
    also being slashed at around the same time.
- This is known as the "correlation penalty", and it can be minor (~1%
    stake for a single validator slashed on their own) or can result in
    100% of the validator's stake getting destroyed (mass slashing
    event).
- It is imposed halfway through a forced exit period that begins with
    an immediate penalty (up to 0.5 ETH) on Day 1, the correlation
    penalty on Day 18, and finally, ejection from the network on Day
    36.
- They receive minor attestation penalties every day because they
    are present on the network but not submitting votes.
- This all means a coordinated attack would be very costly for the
    attacker.

### Crypto-Economic Security (continued)


### Fork Choice

- When the network performs optimally and honestly, there is only ever
    one new block at the head of the chain, and all validators attest to it.
- However, it is possible for validators to have different views of the head
    of the chain due to network latency or because a block proposer has
    equivocated.
- Therefore, consensus clients require an algorithm to decide which one to
    favor.
- The algorithm used in proof-of-stake Ethereum is called LMD-GHOST,
    and it works by identifying the fork that has the greatest weight of
    attestations in its history.


### Proof of Stake and Security

- The threat of a 51% attack still exists on proof-of-stake as it does on
    proof-of-work, but it's even riskier for the attackers.
- An attacker would need 51% of the staked ETH.
- They could then use their own attestations to ensure their preferred
    fork was the one with the most accumulated attestations.
- The 'weight' of accumulated attestations is what consensus clients
    use to determine the correct chain, so this attacker would be able
    to make their fork the canonical one.
- But the honest validators could decide to keep building on the
    minority chain and ignore the attacker's fork while encouraging
    apps, exchanges, and pools to do the same.


- They could also decide to forcibly remove the attacker from the network
    and destroy their staked ETH. These are strong economic defenses
    against a 51% attack.
- 51% attacks are just one flavor of malicious activity.
- Bad actors could attempt long-range attacks (although the finality
    gadget neutralizes this attack vector), short range 'reorgs' (although
    proposer boosting and attestation deadlines mitigate this), bouncing
    and balancing attacks (also mitigated by proposer boosting, and these
    attacks have anyway only been demonstrated under idealized network
    conditions) or avalanche attacks (neutralized by the fork choice
    algorithms rule of only considering the latest message).
- Overall, proof-of-stake, as it is implemented on Ethereum, has been
    demonstrated to be more economically secure than proof-of-work.

### Proof of Stake and Security (continued)


### Pros and Cons of POS

```
Pros Cons
```
Staking makes it easier for individuals
to participate in securing the network,
promoting decentralization. Validator
node can be run on a normal laptop.
Staking pools allow users to stake
without having 32 ETH.

```
POS is younger and less battle-tested
compared to POW
```
Staking is more decentralized.
Economies of scale do not apply in the
same way that they do for POW mining.

```
POS is more complex to implement
than POW
```
POS offers greater crypto-economic
security than POW

```
Users need to run three pieces of
software to participate in Ethereum’s
POS.
```
Less issuance of new ETH is required to
incentivize network participants


### Sybil Resistance & Chain Selection

- **Sybil resistance:**
    - Measures how a protocol fares against a Sybil attack.
    - Sybil attacks are when one user or group pretends to be many
       users.
    - Resistance to this type of attack is essential for a decentralized
       blockchain and enables miners and validators to be rewarded
       equally based on resources put in.
    - These protections are an economic deterrent to Sybil attacks.


- **Chain Selection Rule:**
    - Is used to decide which chain is the "correct" chain.
    - Bitcoin uses the "longest chain" rule, which means that
       whichever blockchain is the longest will be the one the rest of
       the nodes accept as valid and work with.
    - Ethereum used to use the longest chain rule too; however, now
       that Ethereum runs on proof-of-stake it adopted an updated
       fork-choice algorithm that measures the 'weight' of the chain.
    - The weight is the accumulated sum of validator votes, weighted
       by validator staked-ether balances.

### Sybil Resistance & Chain Selection (continued)


### Summary

- Consensus Mechanism
- Proof of Stake (POS)
- Validators
- How a Transaction gets
    executed in Ethereum POS?
- Finality
- Crypto-Economic Security
- Fork Choice
- POS and Security
- Pros and Cons of POS
- Sybil Resistance & Chain
    Selection


### References

- https://ethereum.org/en/developers/docs/consensus-

mechanisms/

- https://ethereum.org/en/developers/docs/consensus-

mechanisms/pos/



`


`

## Module 10:

## Ethereum Stack

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Introduction to Ethereum

Stack

- Level 1: Ethereum Virtual

Machine (EVM)

- Level 2: Smart Contracts
- Level 3: Ethereum Nodes
- Level 4: Ethereum Client

APIs

- Level 5: End-user

Applications


### Introduction to Ethereum Stack

- Like any software stack, the complete "Ethereum stack" will vary
    from project to project depending on the goals.
- There are, however, core components of Ethereum that help
    provide a mental model for how software applications interact with
    the Ethereum blockchain.
- Understanding the layers of the stack will help you understand the
    different ways that Ethereum can be integrated into software
    projects.


### Level 1: Ethereum Virtual Machine

- The Ethereum Virtual Machine (EVM) is the runtime environment
    for smart contracts on Ethereum.
- All smart contracts and state changes on the Ethereum blockchain
    are executed by transactions, and the EVM handles all the
    transaction processing on the Ethereum network.
- As with any virtual machine, the EVM creates a level of abstraction
    between the executing code and the executing machine (an
    Ethereum node).
- Currently, the EVM is running on thousands of nodes distributed
    across the world.


- Under the hood, the EVM uses a set of opcode instructions to
    execute specific tasks.
- These (140 unique) opcodes allow the EVM to be Turing-complete,
    which means the EVM can compute just about anything, given
    enough resources.
- As a dapp developer, one don't need to know much about the
    EVM other than it exists and that it reliably powers all applications
    on Ethereum without downtime.

### Level 1: Ethereum Virtual Machine (continued)


### Level 2: Smart Contract

- Smart contracts are the executable programs that run on the Ethereum
    blockchain.
- Smart contracts are written using specific programming languages that
    compile to EVM bytecode (low-level machine instructions called
    opcodes).
- Not only do smart contracts serve as open-source libraries, but they are
    also essentially open API services that are always running and can't be
    taken down.
- Smart contracts provide public functions which users and applications
    (dapps) may interact with, without needing permission.


- Any application may integrate with deployed smart contracts to
    compose functionality, such as adding data feeds or to support token
    swaps.
- Additionally, anyone can deploy new smart contracts to Ethereum in
    order to add custom functionality to meet their application's needs.
- As a dapp developer, you'll need to write smart contracts only if you
    want to add custom functionality on the Ethereum blockchain.
- You may find you can achieve most or all of your project's needs by
    merely integrating with existing smart contracts, for instance if you want
    to support payments in stablecoins or enable decentralized exchange of
    tokens.

### Level 2: Smart Contract (continued)


### Level 3: Ethereum Nodes

- For an application to interact with the Ethereum blockchain, it must
    connect to an Ethereum node.
- Connecting to a node allows you to read blockchain data and / or
    send transactions to the network.
- Ethereum nodes are computers running software - an Ethereum
    client.
- A client is an implementation of Ethereum that verifies all
    transactions in each block, keeping the network secure and the
    data accurate.


- Ethereum nodes are the Ethereum blockchain.
- They collectively store the state of the Ethereum blockchain and
    reach consensus on transactions to mutate the blockchain state.
- By connecting your application to an Ethereum node (via
    the JSON-RPC API), your application can read data from the
    blockchain (such as user account balances) as well as broadcast
    new transactions to the network (such as transferring ETH between
    user accounts or executing functions of smart contracts).

### Level 3: Ethereum Nodes (continued)


### Level 4: Ethereum Client APIs

- Many convenience libraries (built and maintained by Ethereum's open-
    source community) allow applications to connect to and communicate
    with the Ethereum blockchain.
- If your user-facing application is a web app, you may choose to npm
    install a JavaScript API directly in your frontend, or perhaps choose to
    implement this functionality server-side, using a Python or Java API.
- While these APIs are not a necessary piece of the stack, they abstract
    away much of the complexity of interacting directly with an Ethereum
    node.


- They also provide utility functions (e.g., converting ETH to gwei) so
    as a developer you can spend less time dealing with the intricacies
    of Ethereum clients and more time focused on the functionality
    specific to your application.

### Level 4: Ethereum Client APIs (continued)


### Level 5: End-User Applications

- At the top level of the stack are user-facing applications.
- These are the standard applications you regularly use and build
    today: primarily web and mobile apps.
- The way you develop these user interfaces remains essentially
    unchanged.
- Often users will not need to know the application they're using is
    built using a blockchain.


### Summary

- Introduction to Ethereum

Stack

- Level 1: Ethereum Virtual

Machine (EVM)

- Level 2: Smart Contracts
- Level 3: Ethereum Nodes
- Level 4: Ethereum Client

APIs

- Level 5: End-user

Applications


### References

- https://ethereum.org/en/developers/docs/ethereum-stack/



`


`

## Module 10:

## Smart Contract Lifecycle

## Process

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Smart Contract
- Smart Contract Languages
- Smart Contract Anatomy
- Smart Contract Libraries
- Testing Smart Contracts
- Compiling Smart Contracts
- Deploying Smart Contracts
- Verifying Smart Contracts
- Upgrading Smart Contracts
- Smart Contract Security
- Smart Contract Formal
    Verification
- Smart Contract Composability


### What is a Smart Contract?

- A "smart contract" is simply a program that runs on the Ethereum
    blockchain, i.e., a collection of code (its functions) and data (its
    state) that resides at a specific address on the Ethereum
    blockchain.
- Smart contracts are a type of Ethereum account, i.e., they have a
    balance and can be the target of transactions.
- However, they're not controlled by a user but are deployed to the
    network and run as programmed.
- User accounts can then interact with a smart contract by submitting
    transactions that execute a function defined on the smart contract.
- Smart contracts can define rules, like a regular contract, and
    automatically enforce them via the code.
- Smart contracts cannot be deleted by default, and interactions with
    them are irreversible.


### Smart Contract

- **A digital vending machine** : The best metaphor for a smart
    contract is a vending machine, as described by Nick Szabo.
       - With the right inputs, a certain output is guaranteed.
       - Like how a vending machine removes the need for a vendor
          employee, smart contracts can replace intermediaries in many
          industries.
- **Permissionless** : Anyone can write a smart contract and deploy it to
    the network if they know how to code in a smart contract language
    and have enough ETH to deploy your contract.
       - Deploying a smart contract is technically a transaction, so you
          need to pay Gas in the same way you need to pay gas for a
          simple ETH transfer.


- However, gas costs for contract deployment are far higher.
- However, they must be compiled before they can be deployed
    so that Ethereum's virtual machine can interpret and store the
    contract.
- **Composability** : Smart contracts are public on Ethereum and can
be thought of as open APIs.
- This means you can call other smart contracts in your own smart
contract to greatly extend what's possible.
- Contracts can even deploy other contracts.

### Smart Contract (continued)


- **Limitations** : Smart contracts alone cannot get information about
    "real-world" events because they can't send HTTP requests. This is
    by design.
       - Relying on external information could jeopardize consensus,
          which is important for security and decentralization.
       - There are ways to get around this using oracles.
       - Another limitation of smart contracts is the maximum contract
          size.
       - A smart contract can be a maximum of 24KB, or it will run out of
          gas.
       - This can be circumnavigated by using The Diamond Pattern.

### Smart Contract (continued)


- **Multisig Contract** : Multisig (multiple-signature) contracts are smart
    contract accounts that require multiple valid signatures to execute
    a transaction.
       - This is very useful for avoiding single points of failure for
          contracts holding substantial amounts of ether or other tokens.
       - Multisigs also divide responsibility for contract execution and
          key management between multiple parties and prevent the loss
          of a single private key leading to irreversible loss of funds.

### Smart Contract (continued)


- For these reasons, multisig contracts can be used for simple
    DAO governance.
- Multisigs require N signatures out of M possible acceptable
    signatures (where N ≤ M, and M > 1) in order to execute.
- N=3, M=5 and N=4, M=7 are commonly used.
- A 4/7 multisig requires four out of seven possible valid
    signatures.
- This means the funds are still retrievable even if three signatures
    are lost.
- In this case, it also means that the majority of key-holders must
    agree and sign for the contract to execute.

### Smart Contract (continued)


### Smart Contract Language

- Previous knowledge of programming languages, especially of
    JavaScript or Python, can help you make sense of differences in
    smart contract languages.
- The two most active and maintained languages are:
    - Solidity
    - Vyper
- More experienced developers also might want to use _Yul_ , an
    intermediate language for the EVM, or _Yul+_ , an extension to Yul.
- If you're curious and like to help test new languages that are still
    under heavy development you can experiment with _Fe_ , an
    emerging smart contract language which is currently still in its
    infancy.


### Smart Contract Anatomy

- A smart contract is a program that runs at an address on Ethereum.
- They're made up of data and functions that can execute upon
    receiving a transaction.
- **Data:** Any contract data must be assigned to a location: either to
    storage or memory.
       - It's costly to modify storage in a smart contract so you need to
          consider where your data should live.
- **Storage:** Persistent data is referred to as storage and is
    represented by state variables.
       - These values get stored permanently on the blockchain.
       - You need to declare the type so that the contract can keep track
          of how much storage on the blockchain it needs when it
          compile.


- **Memory:** Values that are only stored for the lifetime of a contract
    function's execution are called memory variables.
       - Since these are not stored permanently on the blockchain, they
          are much cheaper to use.
- **Environment variables:** In addition to the variables, you define on
    your contract, there are some special global variables.
       - They are primarily used to provide information about the
          blockchain or current transaction. E.g.:-

### Smart Contract Anatomy (continued)

```
Prop State variable Description
```
block.timestamp uint256 Current block epoch
timestamp

msg.sender address Sender of the message
(current call)


### Smart Contract Libraries

- There are many open-source smart contract libraries available that
    provide reusable building blocks for your project that can save you from
    having to reinvent the wheel.
- You can usually find two kinds of building blocks in smart contract
    libraries: reusable behaviors you can add to your contracts, and
    implementations of various standards.
- **Behaviours:** When writing smart contracts, there is a good chance you'll
    find yourself writing similar patterns over and over, like assigning
    an admin address to carry out protected operations in a contract, or
    adding an emergency pause button in the event of an unexpected issue.
       - Smart contract libraries usually provide reusable implementations of
          these behaviors as libraries or via inheritance in Solidity.


- **Standards:** To facilitate composability and interoperability, the Ethereum
    community has defined several standards in the form of ERCs.
       - When including an ERC as part of your contracts, it's a good idea to
          look for standard implementations rather than trying to roll out your
          own.
       - Many smart contract libraries include implementations for the most
          popular ERCs.
- **How to add a library:** Always refer to the documentation of the library
    for specific instructions on how to include it.
       - Most tools for compiling contracts will look into your node_modules
          for smart contract libraries.
       - Regardless of the method you use, when including a library, always
          keep an eye on the language version.

### Smart Contract Libraries (continued)


- Smart contract testing means performing detailed analysis and
    evaluation of a smart contract to assess the quality of its source
    code during the development cycle.
- Testing a smart contract makes it easier to identify bugs and
    vulnerabilities and reduces the possibility of software errors that
    could lead to costly exploits.
- Testing smart contracts is one of the most important measures for
    improving smart contract security.
- Unlike traditional software, smart contracts cannot typically be
    updated after launching, making it imperative to test rigorously
    before deploying contracts on the Ethereum network.

### Testing Smart Contracts


- Smart contract testing takes many forms, with different methods
    offering benefits.
- Strategies for testing Ethereum smart contracts can be classified
    into two broad categories: **automated testing** and **manual**
    **testing**.
- **Automated testing:** Automated testing involves using automated
    tools to carry out scripted testing of smart contracts.
       - This technique relies on automated software that can execute
          repeated tests to find defects in smart contracts.
       - Automated testing is efficient, uses fewer resources, and
          promises higher levels of coverage than manual analysis.

### Testing Smart Contracts (continued)


- Automated testing tools can also be configured with test data,
    allowing them to compare predicted behaviors with actual
    results.
- **Manual testing:** Manual testing is human-aided and involves an
individual who executes testing steps manually.
- Code audits, where developers and/or auditors, go over every
line of contract code, are an example of manual testing for
smart contracts.
- Manual testing of smart contracts requires considerable skill and
a considerable investment of time, money, and effort.

### Testing Smart Contracts (continued)


- Moreover, manual testing can sometimes be susceptible to the
    problems of human error.
- However, applying manual testing to smart contracts can also be
    beneficial.
- Code audits harness human intelligence to find defects in contract
    code that might go undetected during automated testing.
- Manual-testing your smart contracts can also reveal vulnerabilities
    that exist outside the code; but can still affect it.
- For example, a smart contract audit can discover vulnerabilities
    arising from flawed interaction with off-chain components.

### Testing Smart Contracts (continued)


### Why is it Important to Smart Contract?

**1. Smart contracts are high-value applications:**
    - Minor vulnerabilities in smart contracts can and often lead to
       massive, irrecoverable losses for users.
    - Comprehensive testing can, however, expose errors in smart
       contract code and reduce security risks before deployment.
**2. Smart contracts are immutable:**
    - Smart contracts deployed in the EVM are immutable by default.
    - While traditional developers may be used to fixing software
       bugs after launching, Ethereum development leaves little room
       for patching security flaws once a smart contract is live on the
       blockchain.
    - Detecting potential vulnerabilities and flaws in your smart
       contract during the pre-launch phase reduces the need for a
       logic upgrade.


### Compiling Smart Contracts

- You need to compile your contract so that your web app and the
    EVM can understand it.
- For the EVM to be able to run your contract it needs to be
    in **bytecode**.
- **Web Applications** : The compiler will also produce the Application
    Binary Interface (ABI) which you need in order for your application
    to understand the contract and call the contract's functions.
       - The ABI is a JSON file that describes the deployed contract and
          its smart contract functions. This helps bridge the gap between
          web2 and web3
       - A JavaScript client library will read the ABI in order for you to
          call on your smart contract in your web app's interface.


### Deploying Smart Contracts

- You need to deploy your smart contract for it to be available to
    users of an Ethereum network.
- To deploy a smart contract, you merely send an Ethereum
    transaction containing the compiled code of the smart contract
    without specifying any recipient.
- Deploying a contract also costs ether (ETH) since they are stored
    on the blockchain, so you should be familiar with gas and fees on
    Ethereum.
- Finally, you'll need to compile your contract before deploying it, so
    make sure you've read about compiling smart contracts.


### How to Deploy a Smart Contract?

- **What you'll need:**
    - your contract's bytecode – this is generated
       through compilation
    - ETH for gas – you'll set your gas limit like other transactions so
       be aware that contract deployment needs a lot more gas than a
       simple ETH transfer
    - a deployment script or plugin
    - access to an Ethereum node, either by running your own,
       connecting to a public node, or via an API key using a node
       service like Infura or Alchemy


### Verifying Smart Contracts

- Smart contracts are designed to be “trustless”, meaning users
    shouldn’t have to trust third parties before interacting with a
    contract.
- As a requisite for trustlessness, users and other developers must be
    able to verify a smart contract’s source code.
- Source code verification assures users and developers that the
    published contract code is the same code running at the contract
    address on the Ethereum blockchain.
- It is important to make the distinction between "source code
    verification" and "formal verification".


- Source code verification, which will be explained in detail below,
    refers to verifying that the given source code of a smart contract in
    a high-level language (e.g., Solidity) compiles to the same
    bytecode to be executed at the contract address.
- However, formal verification describes verifying the correctness of
    a smart contract, meaning the contract behaves as expected.
- Although context-dependent, contract verification usually refers to
    source code verification.

### Verifying Smart Contracts (continued)


### Upgrading Smart Contracts

- A smart contract upgrade involves changing the business logic of a
    smart contract while preserving the contract's state.
- It is important to clarify that upgradeability and mutability are not
    the same, especially in the context of smart contracts.
- You still cannot change a program deployed to an address on the
    Ethereum network. But you can change the code that's executed
    when users interact with a smart contract.
- This can be done via the following methods:
    1. Creating multiple versions of a smart contract and migrating
       state (i.e., data) from the old contract to a new instance of the
       contract.
    2. Creating separate contracts to store business logic and state.


3. Using proxy patterns to delegate function calls from an
    immutable proxy contract to a modifiable logic contract.
4. Creating an immutable main contract that interfaces with and
    relies on flexible satellite contracts to execute specific
    functions.
5. Using the diamond pattern to delegate function calls from a
    proxy contract to logic contracts.
- **Upgrade mechanism #1: Contract migration:-** Contract
migration involves deploying a new instance of an existing smart
contract and transferring storage and balances to the new contract.
- **Upgrade mechanism #2: Data separation:** Separating business
logic and data storage into separate contracts.
- This means users interact with the logic contract, while data is
stored in the storage contract.

### Upgrading Smart Contracts (continued)


- **Upgrade mechanism #3: Proxy patterns:** The proxy pattern also
    uses data separation to keep business logic and data in separate
    contracts.
       - However, in a proxy pattern, the storage contract (called a
          proxy) calls the logic contract during code execution.
       - This is a reverse of the data separation method, where the logic
          contract calls the storage contract.
- **Upgrade mechanism #4: Strategy pattern:** This technique is
    influenced by the strategy pattern, which encourages creating
    software programs that interface with other programs to
    implement specific features.
       - Applying the strategy pattern to Ethereum development would
          mean building a smart contract that calls functions from other
          contracts.

### Upgrading Smart Contracts (continued)


- **Upgrade mechanism #5: Diamond pattern**
    - The diamond pattern can be considered an improvement on
       the proxy pattern. Diamond patterns differ from proxy patterns
       because the diamond proxy contract can delegate function calls
       to more than one logic contract.
    - The logic contracts in the diamond pattern are known as facets.
       To make the diamond pattern work, you need to create a
       mapping in the proxy contract that maps function selectors to
       different facet addresses.

### Upgrading Smart Contracts (continued)


### Smart Contract Security

**Guidelines for building secure Ethereum Smart Contracts:**

1. Design proper access controls.
2. Use require(), assert(), and revert() statements to guard contract
    operations.
3. Test smart contracts and verify code correctness.
4. Ask for an independent review of your code.
5. Follow best practices during smart contract development.
6. Implement robust disaster recovery plans.
7. Design secure governance systems.
8. Reduce complexity in code to a minimum.
9. Defend against common smart contract vulnerabilities.


- **Tools for analyzing smart contracts and verifying code**
    **correctness:**
       - **Testing tools and libraries** - Collection of industry-standard
          tools and libraries for performing unit tests, static analysis, and
          dynamic analysis on smart contracts.
       - **Formal verification tools** - Tools for verifying functional
          correctness in smart contracts and checking invariants.
       - **Smart contract auditing services** - Listing of organizations
          providing smart contract auditing services for Ethereum
          development projects.
       - **Bug bounty platforms** - Platforms for coordinating bug
          bounties and rewarding responsible disclosure of critical
          vulnerabilities in smart contracts.

### Smart Contract Security Resources


- **Fork Checker** - A free online tool for checking all available
    information regarding a forked contract.
- **ABI Encoder** - A free online service for encoding your Solidity
    contract functions and constructor arguments.
- **Tools for monitoring smart contracts:**
- **OpenZeppelin Defender Sentinels** - A tool for automatically
monitoring and responding to events, functions, and transaction
parameters on your smart contracts.
- **Tenderly Real-Time Alerting** - A tool for getting real-time
notifications when unusual or unexpected events happen on
your smart contracts or wallets.

### Smart Contract Security Resources


### Smart Contract Formal Verification

- Formal verification refers to the process of evaluating the
    correctness of a system with respect to a formal specification.
- In simpler terms, formal verification allows us to check if the
    behavior of a system satisfies some requirements (i.e., it does what
    we want).
- Expected behaviors of the system (a smart contract in this case) are
    described using formal modeling, while specification languages
    enable the creation of formal properties.
- Formal verification techniques can then verify that the
    implementation of a contract complies with its specification and
    derive mathematical proof of the former's correctness.
- When a contract satisfies its specification, it is described as
    “functionally correct”, “correct by design”, or “correct by
    construction”.


- Why use formal verification of Smart Contract?
    - Need for reliability
    - Prove functional correctness
    - Ideal verification targets
    - Faster development cycle
- Drawbacks of Formal Verification:
    - Cost of manual labour
    - False negatives
    - Performance issues

### Smart Contract Formal Verification (continued)


### Smart Contract Composability

- Composability is combining distinct components to create new systems
    or outputs.
- In software development, composability means developers can reuse
    existing software components to build new applications.
- In Ethereum, every smart contract is a Lego of sorts—you can use smart
    contracts from other projects as building blocks for your project. This
    means you don't have to spend time reinventing the wheel or building
    from scratch.
- Ethereum smart contracts are like public APIs, so anyone can interact
    with the contract or integrate them into dApps for added functionality.


- Smart contract composability generally works off three principles:
    modularity, autonomy, and discoverability:
       **1. Modularity** : This is the ability of individual components to perform
          a specific task. In Ethereum, every smart contract has a specific use
          case.
       **2. Autonomy** : Composable components must be able to operate
          independently. Each smart contract in Ethereum is self-executing
          and can function without relying on other parts of the system.
       **3. Discoverability** : Developers cannot call external contracts or
          integrate software libraries into applications if the former are not
          publicly available. By design, smart contracts are open-source;
          anyone can call a smart contract or fork a codebase.

### Smart Contract Composability (continued)


- Benefits of Composability:
    - Shorter development cycle
    - Greater innovation
    - Better user experience
- Examples of composability in Ethereum:
    - Token swaps
    - Governance
    - Identity management

### Smart Contract Composability (continued)


### Summary

- Smart Contract
- Smart Contract Languages
- Smart Contract Anatomy
- Smart Contract Libraries
- Testing Smart Contracts
- Compiling Smart Contracts
- Deploying Smart Contracts
- Verifying Smart Contracts
- Upgrading Smart Contracts
- Smart Contract Security
- Smart Contract Formal
    Verification
- Smart Contract Composability


### References

- https://ethereum.org/en/developers/docs/smart-contracts/
- https://ethereum.org/en/developers/docs/smart-

contracts/languages/

- https://ethereum.org/en/developers/docs/smart-

contracts/anatomy/

- https://ethereum.org/en/developers/docs/smart-

contracts/libraries/

- https://ethereum.org/en/developers/docs/smart-

contracts/testing/

- https://ethereum.org/en/developers/docs/smart-

contracts/compiling/


### References (continued)

- https://ethereum.org/en/developers/docs/smart-

contracts/deploying/

- https://ethereum.org/en/developers/docs/smart-

contracts/verifying/

- https://ethereum.org/en/developers/docs/smart-

contracts/upgrading/

- https://ethereum.org/en/developers/docs/smart-

contracts/security/

- https://ethereum.org/en/developers/docs/smart-

contracts/formal-verification/

- https://ethereum.org/en/developers/docs/smart-

contracts/composability/



`


`

## Module 10:

## Development Frameworks

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Introduction to Framework
- Frameworks
- Available Frameworks


### Introduction to Framework

- Building a full-fledged dapp requires different pieces of
    technology.
- Software frameworks include many of the needed features or
    provide easy plugin systems to pick the tools you desire.


### Frameworks

- Frameworks come with a lot of out-of-the-box functionality, like:
    - Features to spin up a local blockchain instance.
    - Utilities to compile and test your smart contracts.
    - Client development add-ons to build your user-facing
       application within the same project / repository.
    - Configuration to connect to Ethereum networks and deploy
       contracts, whether to a locally running instance, or one of
       Ethereum's public networks.
    - Decentralized app distribution - integrations with storage
       options like IPFS.


### Available Frameworks

- **Truffle** :- A development environment, testing framework, build
    pipeline, and other tools.
- **Hardhat** :- Ethereum development environment for professionals.
- **Ape** :- The smart contract development tool for Pythonistas, Data
    Scientists, and Security Professionals.
- **Brownie** :- Python-based development environment and testing
    framework.
- **Web3j** :- A platform for developing blockchain applications on the
    JVM.


- **OpenZeppelin SDK** :- The Ultimate Smart Contract Toolkit: A suite
    of tools to help you develop, compile, upgrade, deploy and
    interact with smart contracts.
- **Create Eth App** :- Create Ethereum-powered apps with one
    command. Comes with a wide offering of UI frameworks and DeFi
    templates to choose from.
- **Scaffold-Eth** :- Ethers.js + Hardhat + React components and hooks
    for web3: everything you need to get started building
    decentralized applications powered by smart contracts.

### Available Frameworks (continued)


- **Tenderly** :- Web3 development platform that enables blockchain
    developers to build, test, debug, monitor, and operate smart
    contracts and improve dapp UX.
- **The Graph** :- The Graph for querying blockchain data efficiently.
- **Alchemy** :- Ethereum Development Platform.
- **Foundry** :- A blazing fast, portable and modular toolkit for
    Ethereum application development written in Rust.
- **NodeReal** :- Ethereum Development Platform.

### Available Frameworks (continued)


### Summary

- Introduction to Framework
- Frameworks
- Available Frameworks


### References

- https://ethereum.org/en/developers/docs/frameworks/



`


`

## Module 11:

## Ethereum Tokens

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Token Standards
- Popular Token Standards
    - ERC-20 Fungible Token
    - ERC-721 Non-Fungible
       Token
    - ERC-777 Extra Functionality
       Token
    - ERC-1155 Efficient Trading
       Token
    - ERC-4626 Tokenized Vault


### Introduction to Token Standards

- Many Ethereum development standards focus on token interfaces.
- These standards help ensure smart contracts remain composable,
    so for instance when a new project issues a token, that it remains
    compatible with existing decentralized exchanges.
- Token naming convention standard:
    - ERC-XX to XXXX is known as Ethereum Request for Comments XX to
       XXXX.


### What is a Token?

Tokens can represent virtually anything in Ethereum:

- reputation points in an online platform
- skills of a character in a game
- lottery tickets
- financial assets like a share in a company
- a fiat currency like USD
- an ounce of gold
- and more....


### Popular Token Standards

- ERC- 20 - A standard interface for fungible (interchangeable) tokens, like
    voting tokens, staking tokens or virtual currencies.
- ERC- 721 - A standard interface for non-fungible tokens, like a deed for
    artwork or a song.
- ERC- 777 - ERC-777 allows people to build extra functionality on top of
    tokens such as a mixer contract for improved transaction privacy or an
    emergency recover function to bail you out if you lose your private keys.
- ERC- 1155 - ERC-1155 allows for more efficient trades and bundling of
    transactions – thus saving costs. This token standard allows for creating
    both utility tokens (such as $BNB or $BAT) and Non-Fungible Tokens like
    CryptoPunks.
- ERC- 4626 - A tokenized vault standard designed to optimize and unify
    the technical parameters of yield-bearing vaults.


### ERC-20 Fungible Token

- The ERC-20 proposed by Fabian Vogelsteller in November 2015, is a
    Token Standard that implements an API for tokens within Smart
    Contracts.
       - A standard interface for fungible (interchangeable) tokens, like voting
          tokens, staking tokens or virtual currencies.
       - In other words, they have a property that makes each Token be the
          same (in type and value) as another Token.
       - For e.g., an ERC-20 Token acts just like the ETH, meaning that 1 Token
          is and will always be equal to all the other Tokens.


- Example functionalities ERC-20 provides:
    - transfer tokens from one account to another
    - get the current token balance of an account
    - get the total supply of the token available on the network
    - approve whether an amount of token from an account can
       be spent by a third-party account

### ERC-20 Fungible Token (continued)


- The ERC-721 proposed by William Entriken, Dieter Shirley, Jacob
    Evans, Nastassia Sachs in January 2018, is a Non-Fungible Token
    Standard that implements an API for tokens within Smart Contracts.
       - The ERC-721 introduces a standard interface for NFT,like a deed for
          artwork or a song,in other words, this type of Token is unique and
          can have different value than another Token from the same Smart
          Contract, maybe due to its age, rarity or even something else like its
          visual.
       - It provides functionalities like to transfer tokens from one account to
          another, to get the current token balance of an account, to get the
          owner of a specific token and the total supply of the token available
          on the network.

### ERC-721 Non-Fungible Token (NFT)


- Other functionalities like to approve that an amount of token from an
    account can be moved by a third-party account.
- **Some popular NFTs:**
- Etherscan NFT Tracker list the top NFT on Ethereum by transfers volume.
- CryptoKitties is a game centered around breedable, collectible, and oh-
    so-adorable creatures we call CryptoKitties.
- Sorare is a global fantasy football game where you can collect limited
    editions collectibles, manage your teams and compete to earn prizes.
- The Ethereum Name Service (ENS) offers a secure & decentralized way
    to address resources both on and off the blockchain using simple,
    human-readable names.

### ERC-721 Non-Fungible Token (NFT)


- POAPdelivers free to create and distribute NFTs to people who attend events
    or complete specific actions.
- Unstoppable Domainsis a San Francisco-based company building domains
    on blockchains. Blockchain domains replace cryptocurrency addresses with
    human-readable names and can be used to enable censorship-resistant
    websites.
- Gods Unchained Cards is a TCG on the Ethereum blockchain that uses NFT's
    to bring real ownership to in-game assets.
- Bored Ape Yacht Club is a collection of 10,000 unique NFTs, which, as well as
    being a provably-rare piece of art, acts as a membership token to the club,
    providing member perks and benefits that increase over time as a result of
    community efforts.

### ERC-721 Non-Fungible Token (NFT)


- ERC-777 allows people to build extra functionality on top of tokens such
    as a mixer contract for improved transaction privacy or an emergency
    recover function to bail you out if you lose your private keys.
       - ERC-777 is difficult to implement properly, due to its susceptibility to
          different forms of attack, so it is recommended to use ERC-20 instead.
       - ERC-777 provides the following improvements over ERC-20:
          - Hooks are a function described in the code of a smart contract.
          - Hooks get called when tokens are sent or received through the
             contract, which allows a smart contract to react to incoming or
             outgoing tokens.
          - The hooks are registered and discovered using the ERC- 1820
             standard.

### ERC-777 Extra Functionality Token


- Hooks allow sending tokens to a contract and notifying the
    contract in a single transaction, unlike ERC- 20 , which requires a
    double call (approve / transferFrom) to achieve this.
- Contracts that have not registered hooks are incompatible with
    ERC-777. The sending contract will abort the transaction when
    the receiving contract has not registered a hook and prevents
    accidental transfers to non-ERC-777 smart contracts.
- Hooks can reject transactions.
- **Decimals** : The standard also solves the confusion around decimals
caused in ERC-20. This clarity improves the developer experience.
- **Backwards compatibility with ERC-20:** ERC-777 contracts can be
interacted with as if they were ERC-20 contracts.

### ERC-777 Extra Functionality Token


- ERC-1155 allows for more efficient trades and bundling of
    transactions – thus saving costs.
       - This token standard allows for creating both utility tokens (such
          as $BNB or $BAT) and Non-Fungible Tokens like CryptoPunks.
       - A standard interface for contracts that manage multiple token
          types.
       - A single deployed contract may include any combination of
          fungible tokens, non-fungible tokens or other configurations
          (e.g., semi-fungible tokens).

### ERC-1155 Efficient Trading Token


- FUNCTIONS AND FEATURES:
    - Batch Transfer: Transfer multiple assets in a single call.
    - Batch Balance: Get the balances of multiple assets in a single call.
    - Batch Approval: Approve all tokens to an address.
    - Hooks: Receive tokens hook.
    - NFT Support: If supply is only 1, treat it as NFT.
    - Safe Transfer Rules: Set of rules for secure transfer.

### ERC-1155 Efficient Trading Token


- A tokenized vault standard designed to optimize and unify the
    technical parameters of yield-bearing vaults.
       - ERC-4626 is a standard to optimize and unify the technical
          parameters of yield-bearing vaults.
       - It provides a standard API for tokenized yield-bearing vaults that
          represent shares of a single underlying ERC-20 token.
       - ERC-4626 also outlines an optional extension for tokenized vaults
          utilizing ERC-20, offering basic functionality for depositing,
          withdrawing tokens and reading balances.
       - ERC-4626 in yield-bearing vaults will lower the integration effort
          and unlock access to yield in various applications with little
          specialized effort from developers by creating more consistent
          and robust implementation patterns.

### ERC-4626 Tokenized Vault


### Summary

- Token Standards
- Popular Token Standards
    - ERC-20 Fungible Token
    - ERC-721 Non-Fungible
       Token
    - ERC-777 Extra Functionality
       Token
    - ERC-1155 Efficient Trading
       Token
    - ERC-4626 Tokenized Vault


### References

- https://ethereum.org/en/developers/docs/standards/tokens/
- https://ethereum.org/en/developers/docs/standards/tokens/er

c-20/

- https://ethereum.org/en/developers/docs/standards/tokens/er

c-721/

- https://ethereum.org/en/developers/docs/standards/tokens/er

c-777/

- https://ethereum.org/en/developers/docs/standards/tokens/er

c-1155/

- https://ethereum.org/en/developers/docs/standards/tokens/er

c-4626/



`


`

## Module 11:

## Truffle Development

## Framework

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- About Truffle
- Truffle Project Structure
- Installation
- Basic Commands
- Steps to Setting Up a

Simple Truffle dApp

- Create a Project


### About Truffle

- A development environment, testing framework and asset pipeline for
    blockchains using the Ethereum Virtual Machine (EVM).
- Built-in smart contract compilation, linking, deployment and binary
    management.
- Advanced debugging with breakpoints, variable analysis, and step
    functionality.
- Deployments and transactions through MetaMask to protect your
    mnemonic.
- External script runner that executes scripts within a Truffle environment.


- Interactive console for direct contract communication.
- Automated contract testing for rapid development.
- Scriptable, extensible deployment & migrations framework.
- Network management for deploying to any number of public &
    private networks.
- Package management with NPM, using the ERC190 standard.
- Configurable build pipeline with support for tight integration.

### About Truffle (continued)


### Truffle Project Structure


### Installation

- The Truffle framework comprises several node.js packages.
- Before you install truffle, you need to have an up-to-date and
    working installation of node.js and the Node Package Manager
    (npm).
- The recommended way to install node.js and npm is to use the
    Node Version Manager (nvm). Once you install nvm, it will handle
    all the dependencies and updates for you.

Requirements :

- node.js v14 - v18
- Windows, Linux, or macOS

**NOTE:** Avoid using sudo while installing Truffle, it can cause
permission error.


### Installation Steps

1. In a terminal, use npm to install Truffle:

```
npm install -g truffle
```
2. You may receive a list of warnings during installation. To confirm

```
that Truffle was installed correctly, run:
truffle version
```
- Ethereum client:
    - Truffle requires a running Ethereum client which supports the
       standard JSON-RPC API. There are many to choose from, and
       some better than others for development.


## Basic Commands

1. truffle init
2. truffle develop
3. truffle compile
4. truffle migrate
5. truffle migrate –reset
6. truffle test


### Running a dApp using Truffle

1. truffle unbox pet-shop
    - https://trufflesuite.com/boxes/
2. truffle compile
3. truffle migrate
4. npm run dev


### Steps to Setting Up a Simple Truffle dApp

➢Step 1 - Setting Up theStructure

➢Step 2 - Writing Smart Contract

➢Step 3 - Developing a Client-sideApplication to Interact with the

```
Contract
```

### Setting Up the Structure

- If we wanted to create a project from scratch, truffle init is run in your root
    project directory. This will create a very bare bones structure for you to


- Using Truffle’s unbox command, we can first download pre-built
    boilerplate project to bootstrap our dapp. (e.g., truffle unbox pet-
    shop)

### Setting Up the Structure (continued)


Let’s discuss each folder of Truffle Box :

- **Contracts** - This is where all smart contacts live. We already have a
    Migration contract that handlesour migrations to the blockchain.
- **Migrations** - This is where all the migration files live. These migrations

```
are like other web development frameworks, that require migrations to
```
```
change the state of a database.
```
- Whenever we deploy smart contracts to the blockchain, we are updating

```
the blockchain's state, and therefore need a migration.
```
### Setting Up the Structure (continued)


- **Node_modules** - Contains all node dependencies.
- **Src** - Home for all client-side applicationcode.
- **Test** - Where we write tests for our smart contract either in solidity

```
or JavaScript. This is where we'll write our tests for our smart
contracts.
```
- **truffle.js file** - This is the main configuration file for our Truffle

```
project.
```
### Setting Up the Structure (continued)


### Writing Smart Contract

- Create a new file
    news.sol in contract
    folder and write the
    following code in
    it.


### truffle

### compile


- Now let's migrate our current smart contract on Ganache. To do

```
this, create a new file in Migration folder named
“2_deploy_contracts.js”. Paste the following code in that file to
migrate your contract.
```
### Writing Smart Contract (continued)


### truffle

### migrate


### truffle test


### Developing a Client-side Application to Interact with

### the Contract

- Go to your index.html file and paste the following code.



- Go to your
    app.js file
    and paste
    the following
    code in your
    “app.js” file.
- First, add the
    following
    code to set
    up the web3
    provider for
    web3.js.

### Developing a Client-side Application to Interact with

### the Contract (continued)


- When we compile our contract “news.json” is created in the build folder.
- Truffle has a library called “TruffleContract” that keeps information about the
    contract. So, using this library we setweb3 provider for our contract.
- This enables our client-side application to interact with our smart contract
    deployed on blockchain.


- This following code will
    take the user-entered
    news and pass it to our
    add news function in
    smart contract.
- Smart contract will
    write the publisher
    address and news on
    blockchain using
    mapping.

### Developing a Client-side Application to Interact with

### the Contract (continued)


- Add the following
    code in app.js to
    render the HTML
    template with data on
    every page reload so
    your news will be
    displayed.

###### Developing a Client-side Application to Interact with the

###### Contract (continued)


- Now in
    your
    console,
    type “npm
    run dev”
    to run
    your
    dApp.


### dApp in Your Browser


### Create a Project

- Most Truffle commands require that you run them against an
    existing Truffle project. So, the first step is to create a Truffle
    project.
- You can create a bare project, but for those just getting started, you
    can use Truffle Boxes, which are example applications and project
    templates.
- For e.g., we'll use the MetaCoin box, which creates a token that can
    be transferred between accounts.


1. Create a new directory for your Truffle project:

```
mkdir MetaCoin
cd MetaCoin
```
2. Download ("unbox") the MetaCoin box:

```
truffle unbox metacoin
```
Note:

- You can use truffle unbox <box-name> command to download
    any of the other Truffle Boxes.
- To create a bare Truffle project with no smart contracts included,
    use truffle init.

### Create a Project (continued)


Once this operation is completed, you'll now have a project structure
with the following items:

- contracts/: Directory for Solidity contracts
- migrations/: Directory for scriptable deployment files
- test/: Directory for test files for testing your application and
    contract
- truffle-config.js: Truffle configuration file

### Create a Project (continued)


### Summary

- About Truffle
- Truffle Project Structure
- Installation
- Basic Commands
- Steps to Setting Up a

Simple Truffle dApp

- Create a Project


### References

- https://trufflesuite.com/docs/truffle/how-to/install/
- https://trufflesuite.com/docs/truffle/how-to/create-a-project/



`


`

## Module 11:

## Ethereum Client APIs

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- JavaScript APIs
- Backend APIs
- JSON-RPC APIs


### JavaScript API Libraries

- For a web app to interact with the Ethereum blockchain, it must connect
    to an Ethereum node.
- For this purpose, every Ethereum client implements the JSON-
    RPC specification, so there are a uniform set of methods that
    applications can rely on.
- To use JavaScript to connect with an Ethereum node, it's possible to use
    vanilla JavaScript but several convenience libraries exist within the
    ecosystem that make this much easier.
- With these libraries, developers can write intuitive, one-line methods to
    initialize JSON RPC requests (under the hood) that interact with
    Ethereum.


### JavaScript API Libraries (continued)

- Since The Merge, two connected pieces of Ethereum software - an
    execution client and a consensus client - are required to run a
    node.
- Please ensure your node includes both an execution and
    consensus client.
- If your node is not on your local machine (e.g., your node is
    running on an AWS instance) update the IP addresses in the
    tutorial accordingly.


### Library Features

- **Connect to Ethereum nodes -** Using providers, these libraries
    allow you to connect to Ethereum and read its data, whether that's
    over JSON-RPC, INFURA, Etherscan, Alchemy or MetaMask.

```
Web3js
example
```

- **Wallet functionality -** These libraries give you functionality to
    create wallets, manage keys and sign transactions.
- **Interact with smart contract functions -** JavaScript client libraries
    allow your application to call smart contract functions by reading
    the Application Binary Interface (ABI) of a compiled contract.
       - The ABI essentially explains the contract's functions in a JSON
          format and allows you to use it like a normal JavaScript object.
- **Utility functions -** Utility functions give you handy shortcuts that
    make building with Ethereum a little easier.
       - Web3js utility functions
       - Ethers utility functions

### Library Features (continued)


### Available Libraries

- **Web3.js** - Ethereum JavaScript API.
- **Ethers.js** - Complete Ethereum wallet implementation and utilities
    in JavaScript and TypeScript.
- **The Graph** - A protocol for indexing Ethereum and IPFS data and
    querying it using GraphQL.
- **light.js** - A high-level reactive JS library optimized for light clients.
- **Web3-wrapper** - Typescript alternative to Web3.js.
- **Alchemyweb3** - Wrapper around Web3.js with automatic retries
    and enhanced apis.
- **Alchemy NFT API** - API for fetching NFT data, including ownership,
    metadata attributes and more.
- **viem** - TypeScript Interface for Ethereum.


### Backend APIs

- If you want to use a specific programming language to connect
    with an Ethereum node, there are many convenience libraries
    within the ecosystem that make this much easier.
- With these libraries, developers can write intuitive, one-line
    methods to initialize JSON-RPC requests (under the hood) that
    interact with Ethereum
- These libraries abstract away much of the complexity of interacting
    directly with an Ethereum node.
- They also provide utility functions (e.g., converting ETH to gwei) so
    as a developer you can spend less time dealing with the intricacies
    of Ethereum clients and more time focused on the unique
    functionality of your application.


- **Alchemy** - Ethereum Development Platform.
- **BlockCypher** - Ethereum Web APIs.
- **Blast by Bware Labs** - Decentralized APIs for Ethereum Mainnet
    and Testnets.
- **Infura** - The Ethereum API as a service.
- **Cloudflare Ethereum Gateway.**
- **Coinbase Cloud Node** - Blockchain Infrastructure API.
- **DataHub by Figment** - Web3 API services with Ethereum Mainnet
    and testnets.
- **NFTPort** - Ethereum Data and Mint APIs.
- **Nodesmith** - JSON-RPC API access to Ethereum Mainnet and
    testnets.

### Available Libraries


- **Ethercluster** - Run your own Ethereum API service supporting both
    ETH and ETC.
- **Chainstack** - Elastic and dedicated Ethereum nodes as a service.
- **QuickNode** - Blockchain Infrastructure as a Service.
- **Python Tooling** - Variety of libraries for Ethereum interaction via
    Python.
- **web3j** - A Java/Android/Kotlin/Scala integration library for
    Ethereum.
- **Rivet** - Ethereum and Ethereum Classic APIs as a service powered
    by open-source software.

### Available Libraries (continued)


- **Nethereum** - An open-source .NET integration library for
    blockchain.
- **Tatum** - The ultimate blockchain development platform.
- **Watchdata** - Provide simple and reliable API access to Ethereum
    blockchain.
- **Zmok** - Speed-oriented Ethereum nodes as JSON-RPC /
    WebSockets API.
- **NOWNodes** - Full Nodes and Block Explorers.
- **Moralis** - Enterprise-Grade EVM API Provider.
- **GetBlock** - Blockchain-as-a-service for Web3 development.

### Available Libraries (continued)


### JSON-RPC API

- JSON-RPC is a stateless, light-weight remote procedure call (RPC)
    protocol.
- It defines several data structures and the rules around their
    processing.
- It is transport agnostic in that the concepts can be used within the
    same process, over sockets, over HTTP, or in many various message
    passing environments.
- It uses JSON (RFC 4627) as data format.
- **Client Implementation:** Ethereum clients each may utilize
    different programming languages when implementing the JSON-
    RPC specification.


- **Convenience Libraries:** While you may choose to interact directly
    with Ethereum clients via the JSON-RPC API, there are often easier
    options for dApp developers.
       - Many JavaScript and backend API libraries exist to provide
          wrappers on top of the JSON-RPC API.
       - With these libraries, developers can write intuitive, one-line
          methods in the programming language of their choice to
          initialize JSON-RPC requests (under the hood) that interact with
          Ethereum
- **Consensus Client APIs:** Consensus clients also have an RPC API
    that allows users to query information about the node, request
    Beacon blocks, Beacon state, and other consensus-related
    information directly from a node.
       - An internal API, called the 'Engine API’, is also used for inter-
          client communication within a node - that is, it enables the
          consensus client and execution client to swap data.

### JSON-RPC (continued)


### Summary

- JavaScript APIs
- Backend APIs
- JSON-RPC APIs


### References

- https://ethereum.org/en/developers/docs/apis/javascript/
- https://ethereum.org/en/developers/docs/apis/backend/
- https://ethereum.org/en/developers/docs/apis/json-rpc/



`


`

## Module 11:

## Data and Analytics

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Data & Analytics
- Block Explorers
    - Execution Layer Data
    - Consensus Layer Data
    - Block Explorer Tools


### Data & Analytics

- As utilization of the network continues to grow, an increasing
    amount of valuable information will exist in the on-chain data.
- As the volume of data rapidly increases, calculating and
    aggregating this information to report upon or drive a dApp can
    become a time and process heavy endeavor.
- Leveraging existing data providers can expedite development,
    produce more accurate results, and reduce ongoing maintenance
    efforts.
- This will enable a team to concentrate on the core functionality
    their project is trying to provide.


### Data & Analytics (continued)

- **Block Explorers** :- Many Block Explorers offer RESTful API gateways
    that will provide developers visibility into real-time data on blocks,
    transactions, miners, accounts, and other on-chain activity.
       - Developers can then process and transform this data to give their users
          unique insights and interactions with the blockchain.
       - For example,Etherscan provides execution and consensus data for
          every 12s slot.
- **The Graph** :- The Graph Network is a decentralized indexing
    protocol for organizing blockchain data.
       - Instead of building and managing off-chain and centralized data stores
          to aggregate on-chain data, with The Graph, developers can build
          serverless applications that run entirely on public infrastructure.


- Using GraphQL, developers can query any of the curated open
    APIs, known as sub-graphs, to acquire the necessary information
    they need to drive their dApp.
- By querying these indexed sub-graphs, Reports and dApps not
    only get performance and scalability benefits but also the built
    in accuracy provided by network consensus.
- As new improvements and / or sub-graphs are added to the
    network, your projects can rapidly iterate to take advantage of
    these enhancements.
- **Client Diversity** :- Client diversity is important for the overall health
of the Ethereum network because it provides resilience to bugs
and exploits.

### Data & Analytics (continued)


- There are now several client diversity dashboards
    including clientdiversity.org,rated.network, pool.invis.cloud,
    slashed.info and Ethernodes.
- **Dune Analytics** :-Dune Analytics pre-processes blockchain data
into relational database (PostgreSQL and DatabricksSQL) tables,
allows users to query blockchain data using SQL and build
dashboards based on query results.
- On-chain data are organized into 4 raw tables: blocks, transactions,
(event) logs and (call) traces.
- Popular contracts and protocols have been decoded, and each has
its own set of event and call tables.
- Those event and call tables are processed further and organized into
abstraction tables by the type of protocols, for example, dex, lending,
stablecoins, etc.

### Data & Analytics (continued)


### Block Explorers

- Block explorers are your portal to Ethereum's data.
- You can use them to see real-time data on blocks, transactions,
    miners, accounts, and other on-chain activity.
- **Services** :- Etherscan, Beaconcha.in, Blockchair, Blockscout,
    Etherchain, Ethplorer, OKLink , Otterscan
- **Data** :- Data is divided into execution data and consensus data.
    - The execution data refers to the transactions that have been
       executed in a specific block.
    - The consensus data refers to the blocks themselves and the
       validators who proposed them.


### Execution Data

- **Standard data:**
    - Block height - The block number and length of the blockchain
       (in blocks) on creation of the current block
    - Timestamp - The time at which a block was proposed
    - Transactions - The number of transactions included within the
       block
    - Fee recipient - The address that received gas fee tips from
       transactions
    - Block Reward - The amount of ETH awarded to the validator
       who proposed the block
    - Size - The size of the data within the block (measured in bytes)
    - Gas used - The total units of gas used by the transactions in the
       block


- Gas limit - The total gas limits set by the transactions in the
    block
- Base fee per gas - The minimum multiplier required for a
    transaction to be included in a block
- Burnt fees - How much ETH is burned in the block
- Extra data - Any extra data the miner has included in the block
- **Advanced data:**
- Hash - The cryptographic hash that represents the block
header (the unique identifier of the block)
- Parent hash - The hash of the block that came before the
current block
- StateRoot - The root hash of Merkle trie which stores the entire
state of the system

### Execution Data (continued)


### Gas

- Not only will block explorers give you data about Gas usage in
    transactions and blocks, but some will give you information on the
    network's current gas prices.
- This will help you understand network usage, submit safe
    transactions and not overspend on gas.
- Gas-specific data covers:
    - Estimated units of gas needed for a safe but slow transaction (+
       estimated price and duration)
    - Estimated units of gas needed for an average transaction (+
       estimated price and duration)
    - Estimated units of gas needed for a fast transaction (+ estimated
       price and duration)


- Average confirmation time based on gas price
- Contracts that are consuming gas - in other words, popular
    products that are seeing lots of usage on the network
- Accounts that are spending gas - in other words, frequent
    network user

### Gas (continued)


### Transactions

- **Standard data:**
    - Transaction hash - A hash generated when the transaction is
       submitted
    - Status - An indication of whether the transaction is pending,
       failed or a success
    - Block - The block in which the transaction has been included
    - Timestamp - The time at which a miner mined the transaction.
    - From - The address of the account that submitted the
       transaction.
    - To - The address of the recipient or smart contract that the
       transaction interacts with.
    - Tokens transferred - A list of tokens that were transferred as part
       of the transaction


- Value - The total ETH value being transferred
- Transaction fee - The amount paid to the miner to process the
    transaction (calculated by gas price*gas used)
- **Advanced data:**
- Gas limit - The maximum numbers of gas units this transaction
can consume
- Gas used - The actual amount of gas units the transaction
consumed
- Gas price - The price set per gas unit
- Nonce - The transaction number for the from address
- Input data - Any extra information required by the transaction

### Transactions (continued)


### Accounts

- There's a lot of data that you can access about an account.
- This is why it's often recommended to use multiple accounts so
    that your assets and value can't be easily tracked.
- **User accounts:**
    - Account address - The public address you can use to send
       funds to
    - ETH balance - The amount of ETH associated with that account
    - Total ETH value - The value of the ETH
    - Tokens - The tokens associated with the account and their value
    - Transaction history - A list of all the transactions where this
       account was either the sender or the recipient


### Accounts (continued)

- **Smart Contract:** Smart contract accounts have all the data that a
    user account will have, but some block explorers will even display
    some code information too. Examples include:
       - Contract creator -The address that deployed the contract to Mainnet
       - Creation transaction -The transaction that included the deployment
          to Mainnet
       - Source code -The solidity or vyper code of the smart contract
       - Contract ABI -The Application Binary Interface of the contract—the
          calls the contract makes, and the data received
       - Contract creation code -The compiled bytecode of the smart
          contract—created when you compile a smart contract written in
          Solidity or Vyper, etc.
       - Contract events -A history of the methods called in the smart
          contract—basically a way to see how the contract is being used and
          how often


### Tokens

Tokens are a type of contract, so they'll have similar data to a smart
contract. But because they have value and can be traded, they have
additional data points:

- Type - Whether they're an ERC-20, ERC-721 or another token
    standard
- Price - If they're an ERC-20 they'll have a current market value
- Market cap - If they're an ERC-20 they'll have a market cap (calculated
    by price*total supply)
- Total supply -The number of tokens in circulation
- Holders -The number of addresses that hold the token
- Transfers -The number of times the token has been transferred
    between accounts
- Transaction history -A history of all the transactions including the
    token
- Contract address -The address of the token that was deployed to
    Mainnet
- Decimals -ERC-20 tokens are divisible and have decimal places


### Network

Some block data is concerned about the health of Ethereum more
holistically.

- Total transactions - The number of transactions since Ethereum
    was created
- Transactions per second - The number of transactions
    processable within a second
- ETH price - The current valuations of 1 ETH
- Total ETH supply - Number of ETH in circulation—remember new
    ETH is created with the creation of every block in the form of
    block rewards
- Market cap - Calculation of price*supply


### Consensus Layer Data

- **Epoch:** For security reasons, randomized committees of validators
    are created at the end of every epoch (every 6.4 minutes).
       - Epoch number
       - Finalized status- Whether the epoch has been finalized (Yes/No)
       - Time -The time the epoch ended
       - Attestations -The number of attestations in the epoch (votes for blocks
          within slots)
       - Deposits -The number of ETH deposits included in the epoch (validators
          must stake ETH to become validators)
       - Slashings -Number of penalties given to proposers of blocks or attestors
       - Voting participation -The amount of staked ETH used to attest blocks
       - Validators -Number of validators active for the epoch
       - Average Validator balance -Average balance for active validators
       - Slots -Number of slots included in the epoch (slots include one valid block)


### Slots

- Slots are opportunities for block creation, the data available for
    each slot includes:
       - Epoch -The epoch in which the slot is valid
       - Slot number
       - Status -The status of the slot (Proposed/Missed)
       - Time -The slot timestamp
       - Proposer -The validator that proposed the block for the slot
       - Block root -The hash-tree-root of the BeaconBlock
       - Parent root -The hash of the block that came before
       - State root -The hash-tree-root of the BeaconState
       - Signature
       - Randao reveal
       - Graffiti -A block proposer can include 32-byte long message to its
          block proposal


### Slots (continued)

- Execution Data
    - Block hash
    - Deposit count
    - Deposit root
- Attestations - Number of attestations for the block in this slot
- Deposits -The number of deposits during this slot
- Voluntary exits -The number of validators that left during the slot
- Slashings - Number of penalties given to proposers of blocks or
    attestors
- Votes -The validators that voted for the block in this slot


### Blocks

- Proof-of-stake divides time into slots and epochs, ie, new data
    - Proposer - The validator that was algorithmically chosen to
       propose the new block
    - Epoch - The epoch in which the block was proposed
    - Slot - The slot in which the block was proposed
    - Attestations - The number of attestation included in the slot—
       attestations are like votes that indicate the block is ready to go
       to the Beacon Chain


- Validators are responsible for proposing blocks and attesting to
    them within slots.
       - Validator number - Unique number that represents the validator
       - Current balance -The validator's balance including rewards
       - Effective balance -The validator's balance that is used for staking
       - Income -The rewards or penalties received by the validator
       - Status -Whether the validator is currently online and active or not
       - Attestation effectiveness -The average time it takes for the validator's
          attestations to be included in the chain
       - Eligibility for activation -Date (and epoch) when the validator became
          available to validate
       - Active since - Date (and epoch) when the validator became active
       - Proposed blocks -The block that the validator has proposed
       - Attestations -The attestations that the validator has provided
       - Deposits -The from address, transaction hash, block number, timestamp,
          amount and status of the staking deposit made by the validator

### Validators


### Attestations

- Attestations are "yes" votes to include blocks in the chain. Their
    data relates to a record of the attestation and the validators who
    attested.
       - Slot -The slot in which the attestation took place
       - Committee index -The index of the committee at the given slot
       - Aggregation bits -Represents the aggregated attestation of all
          participating validators in the attestation
       - Validators - The validators that provided attestations
       - Beacon block root -Points to the block to which validators are
          attesting
       - Source - Points to the latest justified epoch
       - Target - Points to the latest epoch boundary
       - Signature


### Network

- The consensus layer top-level data includes the following:
    - Current epoch
    - Current slot
    - Active validators - Number of active validators
    - Pending validators - Number of validators waiting for to be
       made active
    - Staked ETH - Amount of ETH staked in the network
    - Average balance - Average ETH balance of validators


### Block Explorer Tools

- **Etherscan** - a block explorer you can use to fetch data for
    Ethereum Mainnet and Goerli Testnet
- **Beaconcha.in** - an open source block explorer for Ethereum
    Mainnet and Goerli Testnet
- **Blockchair** - the most private Ethereum explorer. Also for sorting
    and filtering (mempool) data
- **Etherchain** - a block explorer for the Ethereum Mainnet
- **Ethplorer** - a block explorer with a focus on tokens for the
    Ethereum Mainnet and the Kovan testnet


### Summary

- Data & Analytics
- Block Explorers
    - Execution Layer Data
    - Consensus Layer Data
    - Block Explorer Tools


### References

- https://ethereum.org/en/developers/docs/data-and-analytics/
- https://ethereum.org/en/developers/docs/data-and-

analytics/block-explorers/



`


`

## Module 11:

## Node as a Service (NaaS)

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Introduction to NaaS
- How do Node Services

Work?

- Benefits of using a Node

Service

- Cons of using a Node

Service

- Popular Node Services


### Introduction to NaaS

- Running your own Ethereum node can be challenging, especially
    when getting started or while scaling fast.
- There are a number of services that run optimized node
    infrastructures for you, so you can focus on developing your
    application or product instead.
- Stakers: Solo stakers must run their own infrastructure rather than
    relying on third-party providers, i.e., running an execution client
    coupled with a consensus client.
       - Before The Merge, it was possible to run a consensus client only
          and use a centralized provider for execution data; this is no
          longer possible - a solo staker must run both clients.
       - However, there are services available to ease this process.


### How do Node Services Work?

- Node service providers run distributed node clients behind the
    scenes for you, so you don't have to.
- These services typically provide an API key that you can use to write
    to and read from the blockchain.
- They often include access to Ethereum testnets in addition to
    Mainnet.
- Some services offer you your own dedicated node that they
    manage for you, while others use load balancers to distribute
    activity across nodes.


- Almost all node services are extremely easy to integrate with,
    involving one-line changes in your code to swap out your self
    hosted node, or even switch between the services themselves.
- Often node services will run a variety of node clients and types,
    allowing you to access full and archive nodes in addition to client
    specific methods in one API.
- It's important to note that node services do not and should not
    store your private keys or information.

### How do Node Services Work? (continued)


### Benefits of using a Node Service

- The main benefit for using a node service is not having to spend
    engineering time maintaining and managing nodes yourself.
- This allows you to focus on building your product rather than
    having to worry about infrastructure maintenance.
- Running your own nodes can be very expensive from storage to
    bandwidth to valuable engineering time.
- Things like spinning up more nodes when scaling, upgrading
    nodes to the latest versions, and ensuring state consistency, can
    distract from building and spending resources on your desired
    web3 product.


### Cons of using a Node Service

- By using a node service, you are centralizing the infrastructure
    aspect of your product.
- For this reason, projects that hold decentralization to the upmost
    importance might prefer self-hosting nodes rather than
    outsourcing to a 3rd party.


### Popular Node Services

- **Alchemy**
    - Features
       - Largest free tier with 300M compute units per month (~30M
          getLatestBlock requests)
       - Multichain support for Polygon, Starknet, Optimism, Arbitrum
       - Powering ~70% of the largest Ethereum dApps and DeFi
          transaction volume
       - Real-time webhook alerts via Alchemy Notify
       - Best-in-class support and reliability / stability
       - Alchemy's NFT API
       - Dashboard with Request Explorer, Mempool Watcher, and
          Composer
       - Integrated testnet faucet access
       - Active Discord builder community with 18k users


- **All That Node**
    - Features
       - Largest free tier with 150,000 requests daily
       - Access to 24+ blockchain nodes
       - RPC, HTTPS and WSS endpoints
       - Unlimited access to archive data
       - 24/7 support and uptime over 99.9%
       - Faucet available on multi chains
       - Unlimited endpoint access with limitless number of API keys
       - Trace/Debug namespace available
       - Automated updates
       - Technical support

### Popular Node Services


- **Ankr**
    - Features
       - Ankr Protocol - open access to Public RPC API endpoints for 8+
          chains
       - Load balancing and node health monitoring for a fast and
          reliable gateway to the nearest available node
       - Premium tier enabling WSS endpoint and uncapped rate limit
       - One-click full node and validator node deployment for 40+
          chains
       - Scale as you go
       - Analytics tools
       - Dashboard
       - RPC, HTTPS and WSS endpoints
       - Direct support

### Popular Node Services


- **Blast**
    - Features
       - RPC and WSS support
       - Multi-region node hosting
       - Decentralized infrastructure
       - Public API
       - Dedicated Free Plan
       - Multichain support (17+ blockchains)
       - Archive Nodes
       - 24/7 Discord Support
       - 24/7 Monitoring and alerts
       - An overall SLA of 99.9%
       - Pay in crypto

### Popular Node Services


- **BlockDaemon**
    - Benefits
       - Dashboard
       - Per node basis
       - Analytics
- **Infura**
    - Features
       - Free tier option
       - Scale as you go
       - Paid archival data
       - Direct Support
       - Dashboard

### Popular Node Services


- **BlockPI**
    - Features
       - Robust & distributed node structure
       - Up to 40 HTTPS and WSS endpoints
       - Free signup package and monthly package
       - Trace method + Archive data support
       - Packages up to 90 days validity
       - Custom plan and pay as you go payment
       - Pay in crypto
       - Direct support & Technical support

### Popular Node Services


- **Chainstack**
    - Features
       - Free shared nodes
       - Shared archive nodes
       - GraphQL support
       - RPC and WSS endpoints
       - Dedicated full and archive nodes
       - Fast sync time for dedicated deployments
       - Bring your cloud
       - Pay-per-hour pricing
       - Direct 24/7 support

### Popular Node Services


- **DataHub**
    - Features
       - Free tier option with 3,000,000 reqs / month
       - RPC and WSS endpoints
       - Dedicated full and archive nodes
       - Auto-Scaling (Volume Discounts)
       - Free archival data
       - Service Analytics
       - Dashboard
       - Direct 24/7 Support
       - Pay in Crypto (Enterprise)

### Popular Node Services


- **GetBlock**
    - Features
       - Access to 40+ blockchain nodes
       - 40K free daily requests
       - Unlimited number of API keys
       - High connection speed at 1GB/sec
       - Trace+Archive
       - Advanced analytics
       - Automated updates
       - Technical support

### Popular Node Services


- **InfStones**
    - Features
       - Free tier option
       - Scale as you go
       - Analytics
       - Dashboard
       - Unique API endpoints
       - Dedicated full nodes
       - Fast sync time for dedicated deployments
       - Direct 24/7 support
       - Access to 50+ blockchain nodes

### Popular Node Services


- **Kaleido**
    - Features
       - Free starter tier
       - One-click Ethereum node deployment
       - Customizable clients and algorithms (Geth, Quorum & Besu ||
          POA, IBFT & Raft)
       - 500+ administrative and service APIs
       - RESTful interface for Ethereum transaction submission
          (Apache Kafka backed)
       - Outbound streams for event delivery (Apache Kafka backed)
       - Deep collection of "off-chain" and ancillary services (e.g.
          bilateral encrypted messaging transport)

### Popular Node Services


- Straightforward network onboarding with governance and
    role-based access control
- Sophisticated user management for both administrators and
    end users
- Highly scalable, resilient, enterprise-grade infrastructure
- Cloud HSM private key management
- Ethereum Mainnet Tethering
- ISO 27k and SOC 2, Type 2 certifications
- Dynamic runtime configuration (e.g. adding cloud
    integrations, altering node ingresses, etc.)
- Support for multi-cloud, multi-region and hybrid deployment
    orchestrations
- Simple hourly SaaS-based pricing
- SLAs and 24x7 support

### Popular Node Services


- **Moralis**
    - Features
       - Free shared nodes
       - Free shared archive nodes
       - Privacy focused (no logs policy)
       - Cross chain support
       - Scale as you go
       - Dashboard
       - Unique Ethereum SDK
       - Unique API endpoints
       - Direct, technical support

### Popular Node Services


- **NodeReal MegaNode**
    - Features
       - Reliable, fast and scalable RPC API services
       - Enhanced API for web3 developers
       - Multi-chain support
       - Get started for free

### Popular Node Services


- **NOWNodes**
    - Features
       - Access to 50+ blockchain nodes
       - Free API Key
       - Block Explorers
       - API Response Time ⩽ 1 sec
       - 24/7 Support Team
       - Personal Account Manager
       - Shared, archive, backup and dedicated nodes

### Popular Node Services


- **Pocket Network**
    - Features
       - Decentralized RPC Protocol and Marketplace
       - 1M Requests Per Day Free Tier (per endpoint, max 2)
       - Public Endpoints
       - Pre-Stake+ Program (if you need more than 1M
          requests per day)
       - 15+ Blockchains Supported
       - 6400+ Nodes earning POKT for serving applications
       - Archival Node, Archival Node w/ Tracing, & Testnet
          Node Support
       - Ethereum Mainnet Node Client Diversity

### Popular Node Services


- No Single Point of Failure
- Zero Downtime
- Cost-Effective Near-Zero Tokenomics (stake POKT once

for network bandwidth)

- No monthly sunk costs, turn your infrastructure into an

asset

- Load-Balancing built into the Protocol
- Infinitely scale the number of requests per day and

nodes per hour as you go

- The most private, censorship-resistant option
- Hands-on developer support
- Pocket Portal dashboard and analytics


- **QuickNode**
    - Features
       - Industry-leading performance and reliability
       - 24/7 technical support & dev Discord community
       - Geo-balanced, multi cloud/metal, low-latency network
       - Multichain support (Optimism, Arbitrum, Polygon + 11 others)
       - Middle-layers for speed & stability (call routing, cache, indexing)
       - Smart-Contract monitoring via Webhooks
       - Intuitive dashboard, analytics suite, RPC composer
       - Advanced security features (JWT, masking, whitelisting)
       - NFT data and analytics API
       - SOC2 Certified
       - Suitable for Developers to Enterprises

### Popular Node Services


- **Rivet**
    - Features
       - Free tier option
       - Scale as you go
- **SenseiNode**
    - Features
       - Dedicated and Share nodes
       - Dashboard
       - Hosting off AWS on multiple hosting providers across
          different locations in Latin America
       - Prysm and Lighthouse clients

### Popular Node Services


- **SettleMint**
    - Features
       - Free trial
       - Scale as you go
       - GraphQL support
       - RPC and WSS endpoints
       - Dedicated full nodes
       - Bring your cloud
       - Analytics tools
       - Dashboard
       - Pay-per-hour pricing
       - Direct support
-

### Popular Node Services


- **Tenderly**
    - Features
       - Free tier including 25 million Tenderly Units per month
       - Free access to historical data
       - Up to 8x faster read-heavy workloads
       - 100% consistent read access
       - JSON RPC endpoints
       - UI-based RPC request builder and request preview
       - Tightly integrated with Tenderly’s development, debugging, and
          testing tools
       - Transaction simulations
       - Usage analytics and filtering
       - Easy access key management
       - Dedicated engineering support via chat, email, and Discord

### Popular Node Services


- **Watchdata**
    - Features
       - Data reliability
       - Uninterrupted connection with no downtime
       - Process automation
       - Free tariffs
       - High limits that suit any user
       - Support for various nodes
       - Resource scaling
       - High processing speeds

### Popular Node Services


- **ZMOK**
    - Features
       - Front-running as a service
       - Global transactions mempool with search/filtering
          methods
       - Unlimited TX fee and infinite Gas for sending
          transactions
       - Fastest getting of the new block and reading of the
          blockchain
       - The best price per API call guarantee

### Popular Node Services


- **Zeeve**
- Features
    - Enterprise-grade no-code automation platform providing deployment,
       monitoring and management of Blockchain nodes and networks
    - 30+ Supported Protocols & Integrations, and adding more
    - Value added web3 infrastructure services like decentralized storage,
       decentralized identity and Blockchain Ledger data APIs for real-world use
       cases
    - 24/7 support and proactive monitoring ensure the health of nodes all the
       time.
    - RPC endpoints offer authenticated access to API’s, hassle free management
       with intuitive dashboard and analytics.
    - Provides both managed cloud and bring your own cloud options to choose
       from and supports all major cloud providers like AWS, Azure, Google
       Cloud, Digital Ocean and on-premise.
    - We use intelligent routing to hit the node closest to your user every time

### Popular Node Services


### Summary

- Introduction to NaaS
- How do Node Services

Work?

- Benefits of using a Node

Service

- Cons of using a Node

Service

- Popular Node Services


### References

- https://ethereum.org/en/developers/docs/nodes-and-

clients/nodes-as-a-service/



`


`

## Module 12:

## Hyperledger

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Public vs Private

Blockchain

- Hyperledger
- Hyperledger Projects:
    - Distributed Ledgers
    - Libraries
    - Tools &
    - Goals


### Public Blockchain

- Anonymous - Anyone can read, write and joinnetwork
- Decentralized – no entity owns the network
- Cryptocurrency involved. Example: Bitcoin, Ethereum, EOS,

Stellar,etc.


### Challenges with Public Blockchain

- Low performance
- Scalability issue
- Anonymous
- Limited privacy & confidentiality
- Storage constraint
- Unsustainable consensusmechanisms
- Lack of governance and standards
- Quantum computing threat
- Not suitable for Enterprises where privacy and confidentiality is

```
needed
```

### Permissioned Blockchain for Enterprises

- Restricts who can access and do what on thenetwork
- Participants must be identified / identifiable
- Network is permissioned
- High transaction throughputperformance
- Low latency of transaction confirmation
- Privacy and confidentiality of transactions
- Decentralized within the involvedparties
- Governance is enabled Interoperable


### Bitcoin vs Ethereum vs Hyperledger Fabric

```
Parameters Bitcoin Ethereum Hyperledger
Fabric
```
Cryptocurrency Bitcoin Ether None, but can be
implemented
when required
Network Public,
Permissionless

```
Public,
Permissionless
```
```
Private,
Permissioned
Consensus POW (SHA-256) POS (Gasper,
Keccak-256 (SHA3
family))
```
```
PBFT, POA
```
```
Smart Contract None Yes Yes (Chaincode)
Language Bitcoin Scripts,
C++
```
```
Solidity, Yul, Yul+,
FE, and others
```
```
Go, Java,
JavaScript
```

### Hyperledger

- As stated on the Hyperledger’swebsite,

```
“Hyperledger is an open-source
collaborative efforts created to advance
cross-industry blockchain technologies”.
```
- It is a global collaboration, hosted by The

```
Linux Foundation, including leaders in
Finance, Banking, IOT, SupplyChain,
Manufacturing, and Technology”.
```
- Hyperledger incubates a plethora of

```
business blockchain technology frameworks,
under it’s “Umbrella strategy”.
```

### Hyperledger Projects – Distributed Ledgers


**Hyperledger Besu:**

- Hyperledger Besu is an Ethereum client designed to be enterprise-
    friendly for both public and private permissioned network use
    cases, with an extractable EVM implementation.
- It can also be run on test networks such as Sepolia and Görli.
    Hyperledger Besu includes several consensus algorithms including
    Proof of Stake, Proof of Work, and Proof of Authority (IBFT 2.0,
    QBFT, and Clique).
- Its comprehensive permissioning schemes are designed
    specifically for use in a consortium environment.

### Distributed Ledgers


**Hyperledger Fabric:**

- Hyperledger Fabric is intended as a foundation for developing
    applications or solutions with a modular architecture.
- Hyperledger Fabric allows components, such as consensus and
    membership services, to be plug-and-play.
- Its modular and versatile design satisfies a broad range of industry use
    cases.
- It offers a unique approach to consensus that enables performance at
    scale while preserving privacy.

### Distributed Ledgers (continued)


**Hyperledger Indy:**

- Hyperledger Indy provides tools, libraries, and reusable
    components for providing digital identities rooted on blockchains
    or other distributed ledgers so that they are interoperable across
    administrative domains, applications, and any other silo.
- Indy is interoperable with other blockchains or can be used
    standalone powering the decentralization of identity.

**Hyperledger Iroha:**

- Hyperledger Iroha is designed to be simple and easy to
    incorporate into infrastructural or IOT projects requiring distributed
    ledger technology.

### Distributed Ledgers (continued)


- Hyperledger Iroha features a simple construction, modular,
    domain-driven C++ design, emphasis on client application
    development and a new, crash fault tolerant consensus algorithm,
    called YAC.

**Hyperledger Sawtooth:**

- Hyperledger Sawtooth offers a flexible and modular architecture
    separates the core system from the application domain, so smart
    contracts can specify the business rules for applications without
    needing to know the underlying design of the core system.
- Hyperledger Sawtooth supports a variety of consensus algorithms,
    including Practical Byzantine Fault Tolerance (PBFT) and Proof of
    Elapsed Time (POET).

### Distributed Ledgers (continued)


### Hyperledger Projects - Libraries


**Hyperledger Aries:**

- Hyperledger Aries provides a shared, reusable, interoperable tool
    kit designed for initiatives and solutions focused on creating,
    transmitting and storing verifiable digital credentials.
- It is infrastructure for blockchain-rooted, peer-to-peer interactions.
- This project consumes the cryptographic support provided by
    Hyperledger Ursa, to provide secure secret management and
    decentralized key management functionality.

**Hyperledger AnonCreds:**

- Hyperledger AnonCreds is a type of verifiable credential that
    supports important privacy-protecting capabilities based on zero-
    knowledge proof cryptography.

### Libraries


**Hyperledger Transact:**

- Hyperledger Transact aims to reduce the development effort in
    writing distributed ledger software by providing a standard
    interface for executing smart contracts that is separate from the
    distributed ledger implementation.
- Hyperledger Transact takes an extensible approach to
    implementing new smart contract languages called “smart contract
    engines,” that implement a virtual machine or interpreter that
    processes smart contracts.

### Libraries (continued)


**Hyperledger Ursa:**

- Hyperledger Ursa is a shared cryptographic library, it enables
    implementations to avoid duplicating other cryptographic work
    and hopefully increase security in the process.
- The library is an opt-in repository (for Hyperledger and non
    Hyperledger projects) to place and use crypto.
- Hyperledger Ursa consists of sub-projects, which are cohesive
    implementations of cryptographic code or interfaces to
    cryptographic code.

### Libraries (continued)


### Hyperledger Projects - Tools


**Hyperledger Bevel:**

- Hyperledger Bevel is an accelerator by which developers can
    consistently deploy production-ready distributed networks across
    public and private cloud providers.

**Hyperledger Cacti:**

- Hyperledger Cacti is a blockchain integration tool designed to
    allow users to securely integrate different blockchains.

**Hyperledger Caliper:**

- Hyperledger Caliper is a blockchain benchmark tool, it allows users
    to measure the performance of a blockchain implementation with a
    set of predefined use cases.

### Tools


- Hyperledger Caliper will produce reports containing several
    performance indicators to serve as a reference when using the
    following blockchain solutions: Hyperledger Besu, Ethereum,
    Hyperledger Fabric, FISCO BCOS, Hyperledger Iroha, and
    Hyperledger Sawtooth.

**Hyperledger Cello:**

- Hyperledger Cello aims to serve as the operational dashboard for
    Blockchain, which reduces the effort required for creating,
    managing and using blockchains.
- Besides, it can also be used to facilitate creating Blockchain as a
    Service.
- Cello provides an operational console for managing blockchain’s
    efficiently and running on top of various infrastructures, e.g.,
    baremetal, virtual machine, and various container platforms.

### Tools (continued)


**Hyperledger FireFly:**

- Hyperledger FireFly is the first open source Supernode, a complete
    stack for enterprises to build and scale secure Web3 applications.
- The FireFly API for digital assets, data flows, and blockchain
    transactions makes it radically faster to build production-ready
    apps on popular chains and protocols.

**Hyperledger Solang:**

- Hyperledger Solang is a Solidity compiler written in rust which uses
    llvm as the compiler backend.
- Solang can compile Solidity for Solana and Substrate.

### Tools (continued)


### Hyperledger


### Hyperledger Framework


### Hyperledger Framework (continued)


### Hyperledger Tools


### Other Tools

- **Hyperledger Grid:**
    - Hyperledger Grid is a platform for building supply chain solutions
       that include distributed ledger components.
    - This project provides a set of modular components for developing
       smart contracts and client interfaces, including domain-specific data
       models (such as GS1 product definitions), smart-contract business
       logic, libraries, and SDKs.
- **Prometheus:**
    - Prometheus is a monitoring solution for storing time series data like
       metrics.
    - Prometheus collects rich metrics and provides a powerful querying
       language.
- **Grafana:**
    - Grafana transforms metrics into meaningful visualizations.
    - Grafana allows to visualize the data stored in Prometheus (and other
       sources).


### Hyperledger Goals


### Hyperledger Goals


### Summary

- Public vs Private

Blockchain

- Hyperledger
- Hyperledger Projects:
    - Distributed Ledgers
    - Libraries
    - Tools &
    - Goals


### References

- https://www.hyperledger.org/
- https://www.edureka.co/blog/hyperledger-fabric/
- https://intellipaat.com/blog/tutorial/blockchain-

tutorial/hyperledger/



`


`

## Module 12:

## Fabric Architecture

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Hyperledger Fabric
- Fabric Roadmap
- Fabric Architecture
- Transaction Steps


### Hyperledger Fabric

- Permissionednetwork
- Confidential transactions
- Highly modular and configurable architecture
- Pluggable consensus protocols that enable the platform to be

```
moreeffective
```
- Highly modular platform
- High transaction throughputperformance
- Low latency of transaction confirmation
- No cryptocurrency to incent costly mining or to fuel smart contract

```
execution
```
- Programmable smart contracts


### Fabric Roadmap


### Fabric Architecture


### Transaction Steps

❖Propose transaction

❖Execute proposal

❖Proposal Response

❖OrderTransaction

❖DeliverTransaction

❖ValidateTransaction

❖NotifyTransaction


### Summary

- Hyperledger Fabric
- Fabric Roadmap
- Fabric Architecture
- Transaction Steps


### References

- https://medium.com/coinmonks/how-does-hyperledger-

fabric-works-cdb68e6066f5

- https://hyperledger-fabric.readthedocs.io/en/release-2.5/



`


`

## Module 12:

## Fabric Components

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Fabric Components
- Client Node
- Peers
    - Committer Peer
    - Endorsing Peer
    - Anchor Peer
    - Ordering Peer
- Ledger


### Fabric Components

- Client Node
- Peers
    - Committer Peer
    - Endorsing Peer
    - Anchor Peer
    - Ordering Peer
- Ledger
    - World State
    - Transaction Log


### Nodes

```
CP : Committer peer
EP : Endorsing peer
```

### Client Node

- Client node acts on behalf of

```
the end user
```
- Creates Txn Request and send

```
Endorser(s)
```
- Connects to a Orderer for

```
broadcasting validated
transaction.
```
- Chaincode defines the

```
endorsement policy.
```
- Uses policy to validate

```
transaction.
```

### Peers

- Types of Peers:
    - Committer Peer: Commits
       transactions, maintains ledger
       and state.
    - Endorsing Peer: Receives a
       transaction proposal for
       endorsement, responds
       granting or denying
       endorsement.
    - Ordering Peer: Approves the
       inclusion of transaction blocks
       into the ledger and
       communicates with peer and
       endorsing peer nodes.


### Endorser Peer

- Validates the transaction e.g., Certificate
    checks
- Simulates the chaincode
    - Executes the code
    - But does NOT save the state to the
       Ledger
- Primary objective = Protect thenetwork
    - Intentional attack on the network
    - Misbehaving or misconfigured nodes
       on thenetwork
- Improve scalability as only endorsers need
    to execute the code
       - NO need for all nodes to execute the
          chaincode


### Anchor Peer

- Anchor Peers receive theblocks
- Anchor Peers update other

```
peers in the org
```
- Setup at the channellevel
- Discoverable


### Order Node – Ordering Services

- Communication channel for fabric.
- Responsible for consistent ledger

```
state across the network.
```
- Consensus mechanism.
- Ensures order of transactions.
- Creates the blocks & guarantees

```
atomic delivery.
```
- SOLO or Kafka or RAFT messaging

```
service.
```

### Ledger

- Record of all state transitions ofasset.
- State transitions are a result of chaincode

```
invocations (“transactions”) submitted by
participatingparties.
```
- Immutable, append-only, sequenced, tamper-

```
resistant record.
```
- Each transaction results in entry to Ledger.
- All participant have replica of ledger.
- There is one ledger perchannel.
- The ledger is comprised of a blockchain (‘chain’)

```
to store the immutable, sequenced record in
blocks, as well as a state database to maintain
current state.
```

### Ledger (continued)

- Chaincode modified Ledgerdata
    - Transaction Log
       - Records all transactions
       - Immutable
       - Can perform only Create and Read
       - Uses Level DB -Embedded within the peer
    - Statedatabase
       - Records current state ofAsset
       - Can Perform Create, Read, Update,Delete
       - New Versioned created on update with Key-Value pair
       - We can use Couch DB to execute complex queries
       - CouchDB is an optional alternative external state database that
          provides addition query support when your chaincode data is
          modeled as JSON, permitting rich queries of the JSON content.


### Summary

- Fabric Components
- Client Node
- Peers
    - Committer Peer
    - Endorsing Peer
    - Anchor Peer
    - Ordering Peer
- Ledger


### References

- https://medium.com/coinmonks/how-does-hyperledger-

fabric-works-cdb68e6066f5

- https://hyperledger-fabric.readthedocs.io/en/release-2.5/



`


`

## Module 12:

## Smart Contracts &

## Chaincode

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Smart Contracts
- Chaincode
- System Chaincodes
- How Applications interacts

with the Ledger?

- Chaincode – Smart

Contract


### Smart Contracts

- A smart contract defines the rules between different organizations
    in executable code. Applications invoke a smart contract to
    generate transactions that are recorded on the ledger.


### Chaincode

- A smart contract is defined within a chaincode.
- Multiple smart contracts can be defined within the same
    chaincode.
- Chaincode can also be used for low level system programming of
    Fabric.


### System Chaincodes

- **_lifecycle** runs in all peers and manages the installation of
    chaincode on your peers.
- **Lifecycle system chaincode (LSCC)** manages the chaincode
    lifecycle.
- **Configuration system chaincode (CSCC)** runs in all peers to
    handle changes to a channel configuration, such as a policy
    update.
- **Query system chaincode (QSCC)** runs in all peers to provide
    ledger APIs which include block query, transaction query etc.
- **Endorsement system chaincode (ESCC)** runs in endorsing peers
    to cryptographically sign a transaction response.
- **Validation system chaincode (VSCC)** validates a transaction,
    including checking endorsement policy and read-write set
    versioning.


### How Applications interacts with the Ledger


### Chaincode – Smart contract

- Business logic
- Enforces rules to read or alteringstate
- Defining an asset
- Transaction instruction to change Asset
    state
- Write smart contracts in Java, Go or
    Node.js
- Chaincode execution results in a state
    change in ledger
- Governed by System chaincode’s
    Endorsement Policy
- Each Chaincode instance in its own
    container


### Summary

- Smart Contracts
- Chaincode
- System Chaincodes
- How Applications interacts

with the Ledger?

- Chaincode – Smart

Contract


### References

- https://hyperledger-fabric.readthedocs.io/en/release-

2.5/smartcontract/smartcontract.html



`


`

## Module 12:

## Fabric MSP & IM

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Privacy and Confidentiality
- Membership Services

Provider (MSP)

- Identity
- Identity Management (IM)


### Privacy and Confidentiality

- Privacy:
    - Participant not visible to the public but can decide to disclose
       identity to trusted entities
    - Immutable ledger on a per-channelbasis
    - TLS (Transport Layer Security) uses symmetric cryptography to
       encrypt the data and help to maintain the privacy in the
       network.
- Confidentiality:
    - Only authorized participants are allowed to have access tothe
       information


### Membership Services Provider

- Pluggable interface supporting a range of

```
credential architectures.
```
- Governs identity for Peers, Users, and

```
Orderers.
```
- MSP Provides:
    - Concrete identity format
    - User credential validation
    - User credential revocation
    - Signature generation and verification
    - (Optional) credential issuance


### Identity

- Every actors (participants, peers, orderers, client applications,

```
administrators and more) in a blockchain network has a digital
identity encapsulated in an X.509 digitalcertificate.
```
- Determine the exact permissions over resources and access to

```
information that actors have in a blockchainnetwork.
```
- For an identity to be verifiable, it must come from a trusted

```
authority, and this is achieved through MSP – Membership
ServicesProvider.
```
- Certificates issued and revoked by Certification Authority(CA).


### Identity Management

**PKI**

Digital
Certificate

```
Public /
Private CA CRL
```

### Identity Management (continued)


### Summary

- Privacy and Confidentiality
- Membership Services

Provider (MSP)

- Identity
- Identity Management (IM)


### References

- https://hyperledger-fabric.readthedocs.io/en/latest/msp.html#
- https://hyperledger-fabric.readthedocs.io/en/release-

2.5/identity/identity.html



`


`

## Module 12:

## Fabric Channels

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Channels
- Access Control List
- Transaction Lifecycle of

Fabric


### Channels

- Private communication between two or more members for private

```
and confidential transactions.
```
- Each party must be authenticatedand authorized to transact on

```
that channel.
```
- Independent Ledger in

```
eachchannel.
```
- Isolates the Ledger
- Chaincode installed on

```
peers that need visibility
also provides data
encryption.
```

### Channels (continued)

- When a chaincode definition is committed to a channel, all the smart
    contracts within the chaincode are made available to the applications on
    that channel.
- Solo, Kafka, or Raft Communications protocol is used in the Channels.


### Access Control List

- Manage access to
    resources by associating
    a policy — which
    specifies a rule that
    evaluates to true or
    false, given a set of
    identities.


### Transaction Lifecycle of Fabric


### Summary

- Channels
- Access Control List
- Transaction Lifecycle of

Fabric


### References

- https://hyperledger-fabric.readthedocs.io/en/release-

2.5/smartcontract/smartcontract.html#channels



`


`

## Module 12:

## Fabric Use Case

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Use Case / Transaction

Flow

- Swimlane Sequence

Diagram


### Use Case / Transaction Flow

- Outlines the transactional mechanics that take place during a
    standard asset exchange.
- The scenario includes two clients, A and B, who are buying and
    selling radishes.
- They each have a peer on the network through which they send
    their transactions and interact with the ledger.


### Assumptions

- A channel is set up and running.
- Application user registered and enrolled with the organization’s CA.
- User received cryptographic material to authenticate to the network.
- The chaincode is installed on the peers and deployed to the channel.
- The chaincode contains logic defining a set of transaction instructions and the
    agreed upon price for a radish.
- An endorsement policy was set for this chaincode, stating that both peerA and
    peerB must endorse any transaction.


### Client A initiates a transaction

- Client A sends a request to purchase radishes. Request targets peerA (Client A)
    and peerB (Client B) to endorse it.
- Endorsement policy states that both peers must endorse any transaction,
    therefore the request goes to peerA and peerB.
- An application leverages SDK (Node, Java, Go) to utilize one of the available
    APIs to generate a transaction proposal.
- Proposal invokes a chaincode function with certain input parameters, with the
    intent of reading / updating the ledger.


### Client A initiates a transaction (continued)

- SDK takes the user’s cryptographic credentials to produce a unique
    signature for this transaction proposal.
- SDK submits the transaction proposal to a target peer, which will
    manage the transaction submission on behalf of the client.
- The target peer first forwards the transaction proposal to other peers for
    execution, as required by the endorsement policy.


### Endorsing peers verify signature & executes

### the transaction

- The endorsing peers verify
    - (1) the transaction proposal is well formed,
    - (2) it has not been submitted already in the past (replay-attack protection),
    - (3) the signature is valid (using the MSP), and
    - (4) the submitter Client A is properly authorized to perform the proposed
       operation on that channel (submitter satisfies the channel’sWriterspolicy).


### Endorsing peers verify signature & executes

### the transaction (continued)

- The endorsing peers take the transaction proposal inputs as arguments
    to the invoked chaincode’s function.
- The chaincode is then executed against the current state database to
    produce transaction results including a response value, read set, and
    write set (i.e., key/value pairs representing an asset to create or update).
- No updates are made to the ledger at this point.
- The set of these values, along with the endorsing peer’s signature is
    passed back as a “proposal response” to the target peer.


### Proposal responses are inspected

- The target peer verifies the proposal responses are the same prior
    to proceeding with the transaction submission.
- The architecture is such that even if a transaction is submitted
    without this check, the endorsement policy will still be checked and
    enforced when each peer validates transactions prior to
    committing them.


### Target peer assembles endorsements into a

### transaction

- The target peer “broadcasts” the transaction proposal and response within a
    “transaction message” to the ordering service.
- The transaction contains the Channel ID, the read/write sets, and a signature
    from each endorsing peer.
- The ordering service does not need to inspect the entire content of a
    transaction in order to perform its operation, it simply receives transactions,
    orders them, and creates blocks of transactions per channel.


### Transaction is validated and committed

- The blocks of transactions are “delivered” to all peers on the channel.
- The transactions within the block are validated to ensure endorsement
    policy is fulfilled and to ensure that there have been no changes to
    ledger state for read set variables since the read set was generated by
    the transaction execution.
- Transactions in the block are tagged as being valid or invalid.


### Ledger updated

- Each peer appends the block to the channel’s chain, and for each valid
    transaction the write sets are committed to current state database.
- An event is emitted by each peer to notify the client application that the
    transaction (invocation) has been immutably appended to the chain, as
    well as notification of whether the transaction was validated or
    invalidated.
- Applications should listen for the transaction event after submitting a
    transaction.
- Without listening for transaction events, you will not know whether your
    transaction has been ordered, validated, and committed to the ledger.


### Swimlane Sequence Diagram


### Summary

- Use Case / Transaction

Flow

- Swimlane Sequence

Diagram


### References

- https://hyperledger-fabric.readthedocs.io/en/release-

2.5/txflow.html



`


`

## Module 12:

## Coding your First

## Application

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Install Pre-Requisites
- Writing your First

Application


### Install Pre-Requisites

- Install Git

```
➢ sudo apt i n s t a l l g i t
```
- Install cURL

```
➢ curl -–version (if not installed, install curl)
➢ sudo apt i n s t a l l c u r l
```
- Install wget (optional, if NOTinstalled)

```
➢ sudo apt i n s t a l l wget
```

### Install Pre-Requisites (continued)

- Install Docker & Docker-Compose

```
➢ docker –version (if not installed, install docker)
➢ sudo apt i n s t a l l docker
➢ docker-compose –version (if not installed, install docker-compose)
➢ sudo apt i n s t a l l docker-compose
```
- # add your user to the dockergroup

```
➢ sudo usermod -a -G docker <username>
```
- newgrp docker

```
➢ sudo chmod 777 /var/run/docker.sock
```

- Install Go-Lang
    ➢ go –version (if not installed, install go)
    ➢ sudo apt i n s t a l l golang-go
- # set GOPATH environment variable
    ➢ export GOPATH=$HOME/go
- Install NodeJS & npm

```
➢ curl -sL https://deb.nodesource.com/setup_10.x -o
nodesource_setup.sh
➢ sudo bash nodesource_setup.sh
➢ sudo apt i n s t a l l node.js
```
### Install Pre-Requisites (continued)


- Install build-essential

```
➢ sudo apt i n s t a l l build-essential
```
- Install Python 2

```
➢ sudo apt i n s t a l l python
```
- Note: Install node.js v10.22.1

### Install Pre-Requisites (continued)


### Writing your First Application

1.Setting up a developmentenvironment.

2.Learning about a sample smart contract,FabCar.

3.Develop a sample application which uses FabCar.


Set up the blockchain network:

- If you’ve already run through Building Your First Network, you will

```
have downloaded fabric-samples and have a network up and
running. Before you run this tutorial, you must stop this network:
➢ ./byfn.sh down
```
- If you have run through this tutorial before, use the following

```
commands to kill any stale or active containers. Note, this will take
down all your containers whether they’re Fabric related or not.
➢ docker rm -f $(docker ps -aq)
➢ docker rmi -f $(docker images | grep fabcar | awk '{print $3}')
```
### Writing your First Application (continued)


- Launch the network

```
➢ ./startFabric.shjavascript
```
- Install theapplication

```
➢ npm install
➢ ls
```
- Enrolling the adminuser

```
➢ node enrollAdmin.js
➢ node registerUser.js
```
- Querying the ledger

```
➢ node query.js
```
### Writing your First Application (continued)


The FabCar

Smart Contract

Updating the

Ledger

➢ _node involve.js_

### Writing your First Application (continued)


### Summary

- Install Pre-Requisites
- Writing your First

Application


### References

- https://hyperledger-fabric.readthedocs.io/en/release-

```
2.5/search.html?q=First+Application+&check_keywords=yes&
area=default
```


`


`

## Module 13:

## Staking with Ethereum

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- What is Staking?
- Why Stake your Eth?
- How to Stake your Eth?
- Comparison of Staking

Options


### What is Staking?

- Staking is the act of depositing 32 ETH to activate validator
    software.
- As a validator you’ll be responsible for storing data, processing
    transactions, and adding new blocks to the blockchain.
- This will keep Ethereum secure for everyone and earn you new ETH
    in the process.


### Why Stake your Eth?

1. Earn Reward:
- Rewards are given for actions that help the network reach
    consensus.
- You'll get rewards for running software that properly batches
    transactions into new blocks and checks the work of other
    validators because that's what keeps the chain running securely.
2. Better Security:
- The network gets stronger against attacks as more ETH is staked,
    as it then requires more ETH to control a majority of the network.
- To become a threat, you would need to hold the majority of
    validators, which means you'd need to control the majority of ETH
    in the system–that's a lot!


3. More sustainable:
- Stakers don't need to do energy-intensive proof-of-work
    computations to participate in securing the network meaning
    staking nodes can run on relatively modest hardware using very
    little energy.

### Why Stake your Eth? (continued)


### How to Stake your Eth?

- You'll need 32 ETH to activate your own validator, but it is possible
    to stake less.
- Following are some of the options available.
1. Solo home staking:
- Solo staking on Ethereum is the gold standard for staking.
- It provides full participation rewards, improves the decentralization
    of the network, and never requires trusting anyone else with your
    funds.
- Those considering solo staking should have at least 32 ETH and a
    dedicated computer connected to the internet ~24/7.
- Some technical know-how is helpful, but easy-to-use tools now
    exist to help simplify this process.


2. Staking as a Service:
- If you don't want or don't feel comfortable dealing with hardware
    but still want to stake your 32 ETH, staking-as-a-service options
    allow you to delegate the hard part while you earn native block
    rewards.
- These options usually walk you through creating a set of validator
    credentials, uploading your signing keys to them, and depositing
    your 32 ETH. This allows the service to validate on your behalf.
- This method of staking requires a certain level of trust in the
    provider.
- To limit counter-party risk, the keys to withdrawal your ETH are
    usually kept in your possession.

### How to Stake your Eth? (continued)


3. Pooled staking:
- Several pooling solutions now exist to assist users who do not have
    or feel comfortable staking 32 ETH.
- Many of these options include what is known as 'liquid staking'
    which involves an ERC-20 liquidity token that represents your
    staked ETH.
- Liquid staking enables easy and anytime exiting and makes staking
    as simple as a token swap.
- This option also allows users to hold custody of their assets in their
    own Ethereum wallet.
- Pooled staking is not native to the Ethereum network.
- Third parties are building these solutions, and they carry their own
    risks.

### How to Stake your Eth? (continued)


4. Centralized exchanges:
- Many centralized exchanges provide staking services if you are not
    yet comfortable holding ETH in your own wallet.
- They can be a fallback to allow you to earn some yield on your ETH
    holdings with minimal oversight or effort.
- The trade-off here is that centralized providers consolidate large
    pools of ETH to run large numbers of validators.
- This can be dangerous for the network and its users as it creates a
    large centralized target and point of failure, making the network
    more vulnerable to attack or bugs.

### How to Stake your Eth? (continued)


### Comparison of Staking Options

```
Solo staking Staking as a Service Pooled Staking
Rewards Rewards Rewards
```
Maximum rewards - receive
full rewards directly from the
protocol

```
Usually involves full protocol
rewards minus monthly fee
for node operations
```
```
Pooled stakers accrue
rewards differently,
depending on which
method of pooled staking
chosen
```
You'll get rewards for
batching transactions into a
new block or checking the
work of other validators to
keep the chain running
securely

```
Dashboards often available
to easily track your validator
client
```
```
Many pooled staking
services offer one or more
liquidity tokens that
represents your staked ETH
plus your share of the
validator rewards
```
You’ll also receive unburnt
transaction fees for blocks
you propose

```
Liquidity tokens can be held
in your own wallet, used in
DeFi and sold if you decide
to exit
```

### Comparison of Staking Options (continued)

```
Solo staking Staking as a Service Pooled Staking
Risks Risks Risks
```
Your ETH is at stake Same risks as solo staking
plus counter-party risk of
service provider

```
Risks vary depending on the
method used
```
There are penalties, which
cost ETH, for going offline

```
Use of your signing keys is
entrusted to someone else
who could behave
maliciously
```
```
In general, risks consist of a
combination of counter-
party, smart contract and
execution risk
```
Malicious behavior can
result in 'slashing' of larger
amounts of ETH and forced
ejection from the network


### Comparison of Staking Options (continued)

```
Solo staking Staking as a Service Pooled Staking
Requirements Requirements Requirements
```
You must deposit 32ETH Deposit 32ETH and
generate your keys with
assistance

```
Lowest ETH requirements,
some projects require as
little as 0.01 ETH
```
Maintain hardware that runs
both an Ethereum execution
client and consensus client
while connected to the
internet

```
Store your keys securely Deposit directly from your
wallet to different pooled
staking platforms or simply
trade for one of the staking
liquidity tokens
```
The Staking Launchpad will
walk you through the
process and hardware
requirements

```
The rest is taken care of,
though specific services will
vary
```

### Summary

- What is Staking?
- Why Stake your Eth?
- How to Stake your Eth?
- Comparison of Staking

Options


### References

- https://ethereum.org/en/staking/
- https://ethereum.org/en/staking/#what-is-staking



`


`

## Module 13:

## Ethereum Improvement

## Proposal (EIP)

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- What are EIPs?
- Why do EIPs matter?
- EIP Process
- EIP Status Terms
- EIP Types


### What are EIPs?

- Ethereum Improvement Proposals (EIPs) are standards specifying
    potential new features or processes for Ethereum.
- EIPs contain technical specifications for the proposed changes and
    act as the “source of truth” for the community.
- Network upgrades and application standards for Ethereum are
    discussed and developed through the EIP process.
- Anyone within the Ethereum community could create an EIP.
- Guidelines for writing EIPs are included in EIP-1.
- An EIP should primarily provide a concise technical specification
    with a small amount of motivation.
- The EIP author is responsible for reaching consensus within the
    community and documenting alternative opinions.


### Why do EIPs matter?

- Along with providing a technical specification for changes, EIPs are
    the unit around which governance happens in Ethereum:
       - Anyone is free to propose one, and then various stakeholders in
          the community will debate to determine if it should be adopted
          as a standard or included in a network upgrade.
- Because non-core EIPs don't have to be adopted by all
    applications (for example, it is possible to create a fungible token
    that doesn't implement EIP-20), but core EIPs must be widely
    adopted (because all nodes must upgrade to stay part of the same
    network), core EIPs require a broader consensus within the
    community than non-core EIPs.


### EIP Process

- The following is the standardization process for all EIPs in all

tracks:


### EIP Status Terms

- **Idea** - An idea that is pre-draft. This is not tracked within the EIP
    Repository.
- **Draft** - The first formally tracked stage of an EIP in development.
    An EIP is merged by an EIP Editor into the EIP repository when
    properly formatted.
- **Review** - An EIP Author marks an EIP as ready for and requesting
    Peer Review.
- **Last Call** - This is the final review window for an EIP before moving
    to FINAL. An EIP editor will assign Last Call status and set a review
    end date (`last-call-deadline’), typically 14 days later. If this period
    results in necessary normative changes, it will revert the EIP to
    Review.


- **Final** - This EIP represents the final standard. A Final EIP exists in a
    state of finality and should only be updated to correct errata and
    add non-normative clarifications.
- **Stagnant** - Any EIP in Draft or Review if inactive for a period of 6
    months or greater is moved to Stagnant. An EIP may be
    resurrected from this state by Authors or EIP Editors through
    moving it back to Draft.
- **Withdrawn** - The EIP Author(s) have withdrawn the proposed EIP.
    This state has finality and can no longer be resurrected using this
    EIP number. If the idea is pursued at later date, it is considered a
    new proposal.
- **Living** - A special status for EIPs that are designed to be continually
    updated and not reach a state of finality. This includes most notably
    EIP-1.

### EIP Status Terms (continued)


### EIP Types

- There are three types of EIP:

**1:** A **Standards Track EIP** describes any change that affects most or
all Ethereum implementations, such as—a change to the network
protocol, a change in block or transaction validity rules, proposed
application standards/conventions, or any change or addition that
affects the interoperability of applications using Ethereum.

- Standards Track EIPs consist of three parts—a design document,
    an implementation, and (if warranted) an update to the formal
    specification.
- Standards Track EIPs can be broken down into the following
    categories:


- **Core** : improvements requiring a consensus fork (e.g., EIP-
    5 ,EIP- 101 ), as well as changes that are not necessarily
    consensus critical but may be relevant to “core dev”
    discussions.
- **Networking** : includes improvements around devp2p (EIP- 8 )
    and Light Ethereum Subprotocol, as well as proposed
    improvements to network protocol specifications
    of whisper and swarm.
- **Interface** : includes improvements around
    client API/RPC specifications and standards, and also certain
    language-level standards like method names (EIP- 6 )
    and contract ABIs. The label “interface” aligns with the
    [interfaces repo] and discussion should primarily occur in
    that repository before an EIP is submitted to the EIPs
    repository.

### EIP Types (continued)


- **ERC** : application-level standards and conventions, including
    contract standards such as token standards (ERC- 20 ), name
    registries (ERC- 137 ), URI schemes, library/package formats, and
    wallet formats.

**2: Meta EIP** describes a process surrounding Ethereum or proposes
a change to (or an event in) a process.

- Process EIPs are like Standards Track EIPs but apply to areas
    other than the Ethereum protocol itself.
- They may propose an implementation, but not to Ethereum’s
    codebase; they often require community consensus; unlike
    Informational EIPs, they are more than recommendations, and
    users are typically not free to ignore them.

### EIP Types (continued)


- Examples include procedures, guidelines, changes to the
    decision-making process, and changes to the tools or
    environment used in Ethereum development.
- Any meta-EIP is also considered a Process EIP.

**3: Informational EIP** describes an Ethereum design issue or
provides general guidelines or information to the Ethereum
community; but does not propose a new feature.

- Informational EIPs do not necessarily represent Ethereum
    community consensus or a recommendation, so users and
    implementers are free to ignore Informational EIPs or follow
    their advice.

### EIP Types (continued)


### Summary

- What are EIPs?
- Why do EIPs matter?
- EIP Process
- EIP Status Terms
- EIP Types


### References

- https://ethereum.org/en/eips/#introduction-to-ethereum-

improvement-proposals

- https://eips.ethereum.org/
- https://eips.ethereum.org/EIPS/eip- 1
- https://eips.ethereum.org/EIPS/eip-1#eip-types



`


`

## Module 13: Stablecoins

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Stablecoins
- The Stablecoin Trilemma
- Types of Stablecoins:
    - Fiat-backed
    - Commodity-backed
    - Cryptocurrency-backed
    - Algorithmic &
    - Hybrid
- Stablecoin Regulation


### Stablecoins

Digital money for everyday use:

- Stablecoins are Ethereum tokens

```
designed to stay at a fixed value,
even when the price of ETH
changes.
```

### Stablecoins (continued)

- Stablecoins are cryptocurrencies without the volatility.
- They share a lot of the same powers as ETH, but their value is
    steady, more like a traditional currency. So, you have access to
    stable money that you can use on Ethereum.
- Stablecoins are global and can be sent over the internet. They're
    easy to receive or send once you have an Ethereum account.
- Stablecoins are exchangeable for ETH and other Ethereum tokens.
    Lots of dApps rely on stablecoins.
- Stablecoins are secured by cryptography. No one can forge
    transactions on your behalf.
- Stablecoins aim to provide an alternative to the high volatility of the
    most popular cryptocurrencies, including Bitcoin (BTC), which has
    made crypto investments less suitable for common transactions.


### Why are Stablecoins so important?

- Stablecoins aim to address the problem of this volatility by
    promising to hold the value of the cryptocurrency steady in a
    variety of ways.
- They give traders temporary reprieve from volatility when the
    market is tumbling and can also be used in the rapidly growing
    world of decentralized finance (DeFi) for things like yield-farming,
    lending, and liquidity provision.
- Most traders and investors gain exposure to stablecoins by
    purchasing them from exchange platforms, but it is also often
    possible to mint fresh stablecoins by depositing the requisite
    collateral with the issuing company, such as US dollars with Tether
    or physical gold with CACHE gold.


### The Stablecoin Trilemma

I. Price Stability

II. Capital Efficiency

III. Decentralization

IV. Balancing the Trilemma
caused:

1. Fiat-backed
2. Commodity-backed
3. Cryptocurrency-
    backed
4. Algorithmic
5. Hybrid


### Fiat-backed Stablecoins

Most used Stablecoin Category:

- The Challenges of Centralization
- Maintaining Dominant Position
- Maintain a reserve of a fiat currency (or currencies) such as the U.S.
dollar or any other, as collateral assuring the stablecoin's value.
- Reserves are regularly

```
audited.
```

Advantages & Disadvantages:

Top Fiat-backed Stablecoins by Market Cap:

### Fiat-backed Stablecoins (continued)

```
Pros Cons
Safe against crypto volatility. Centralized –someone must issue
the tokens.
Changes in price are minimal. Requires auditing to ensure company
has sufficient reserves.
```

Most used Stablecoin Category:

- The Challenges of Centralization
- Maintaining Dominant Position
- Other forms can include precious metals like gold or silver as well as
commodities like crude oil, as collateral assuring the stablecoin's
value.

Advantages & Disadvantages:

### Commodity-backed Stablecoins

```
Pros Cons
Safe against crypto volatility. Centralized –someone must issue
the tokens.
You need to trust the token issuer
and the precious metal reserves.
```

The Trade-Offs for Decentralization:

- The Price of Decentralization
- Outlook
- Due high volatility of reserve cryptocurrency, such stablecoins are
overcollateralized.

### Cryptocurrency-backed Stablecoins


- A cryptocurrency worth $2 million might be held as reserve to issue $1
    million in a crypto-backed stablecoin, insuring against a 50% decline in
    the price of the reserve cryptocurrency.
- For example, MakerDAO's Dai (DAI) stablecoin is pegged to the U.S.
    dollar but backed by Ethereum (ETH) and other cryptocurrencies worth
    150% of the DAI stablecoin in circulation.

Top Crypto-backed Stablecoins by Market Cap:

#### Cryptocurrency-backed Stablecoins (continued)


```
Pros Cons
```
Transparent and fully decentralized. Less stable than fiat-backed
stablecoins.

Quick to turn into other crypto assets. You need to keep an eye on the value
of the crypto collateral.

No external custodians – all assets are
controlled by Ethereum accounts.

### Cryptocurrency-backed Stablecoins

### (continued)

Advantages & Disadvantages:


### Algorithmic Stablecoins

Can Algorithmic Stablecoins solve the Trilemma?

- The Case of UST (crash of UST)
- The Future of Algorithmic Stablecoins
- Algorithmic stablecoins may or may not hold reserve assets.


- Their primary distinction is the strategy of keeping the stablecoin's value
    stable by controlling its supply through an algorithm, essentially a
    computer program running a preset formula.
- In some ways that's not so different from central banks, which also don't
    rely on a reserve asset to keep the value of the currency they issue
    stable.
- Algorithmic stablecoin issuers can't fall back on such advantages in a
    crisis.

Top Algorithmic Stablecoins by Market Cap:

### Algorithmic Stablecoins (continued)


- An algorithm will sell tokens if the price falls below the desired
    value and supply tokens if the value goes beyond the desired
    amount.
- Because the number of these tokens in circulation changes
    regularly, the number of tokens you own will change, but will
    always reflect your share.

Advantages & Disadvantages:

### Algorithmic Stablecoins (continued)

```
Pros Cons
```
No collateral needed. You need to trust (or be able to read) the
algorithm.

Controlled by a public algorithm. Your balance of coins will change based on
total supply.


FRAX Stablecoin: Fractional-Algorithmic

- Frax isa unique stablecoin with parts of its supply backed by collateral
    and parts of the supply algorithmic.
- The ratio of collateralized and algorithmic depends on the market's
    pricing of the FRAX stablecoin.
- If FRAX is trading at above $1, the protocol decreases the collateral ratio.

Top Hybrid Stablecoins by Market Cap:

### Hybrid Stablecoins


### Stablecoin Regulation

- Stablecoins continue to come under scrutiny by regulators, given
    the rapid growth of the $130 billion market and its potential to
    affect the broader financial system.
- In October 2021, the International Organization of Securities
    Commissions (IOSCO) said stablecoins should be regulated as
    financial market infrastructure alongside payment systems and
    clearinghouses.
- The proposed rules focus on stablecoins that are deemed
    systemically important by regulators, those with the potential to
    disrupt payment and settlement transactions.
- Moreover, politicians have increased calls for tighter regulation of
    stablecoins, like calling for regular audits of stablecoin issuers,
    while others back bank-like regulations for the sector.


### Summary

- Stablecoins
- The Stablecoin Trilemma
- Types of Stablecoins:
    - Fiat-backed
    - Commodity-backed
    - Cryptocurrency-backed
    - Algorithmic &
    - Hybrid
- Stablecoin Regulation


### References

- https://ethereum.org/en/stablecoins/
- https://decrypt.co/resources/stablecoins
- https://www.investopedia.com/terms/s/stablecoin.asp
- https://stablecoins.wtf/resources/the-stablecoin-trillema#price-

stability

- https://stablecoins.wtf/resources/fiat-backed-stablecoins
- https://stablecoins.wtf/resources/crypto-backed-stablecoins
- https://stablecoins.wtf/resources/algorithmic-stablecoins



`


`

## Module 13:

## Non-Fungible Tokens

## (NFTs)

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- What’s an NFT?
- Internet of Assets (IOA)
- How do NFTs work?
- What are NFTs used for?
- NFTs and DeFi
- Ethereum and NFTs


### Non-Fungible Tokens (NFTs)

- A way to represent anything
    unique as an Ethereum-based
    asset.
- NFTs are giving more power to
    content creators than ever
    before.
- Powered by smart contracts on
    the Ethereum blockchain.


### What’s an NFT?

- NFTs are tokens that we can use to represent ownership of unique
    asset, like a deed for an item in the digital or physical realm.
- Ownership of an asset is secured by the Ethereum blockchain – no
    one can modify the record of ownership or copy / paste a new NFT
    into existence.
- NFTs are currently taking the digital art and collectibles world by
    storm.
- But digital art is only one way to use NFTs. They can be used to
    represent ownership of any unique asset.


`


### Internet of Assets (IOA)

- NFTs and Ethereum solve some of the problems that exist on the
    internet today.
- As everything becomes more digital, there's a need to replicate the
    properties of physical items like scarcity, uniqueness, and proof of
    ownership.
- Not to mention that digital items often only work in the context of
    their product.
- For example, you can't re-sell an iTunes mp3 you've purchased, or
    you can't exchange one company's loyalty points for another
    platform's credit even if there's a market for it.


###### Comparison of NFT Internet vs Internet of Today

**An NFT internet The Internet Today**
NFTs are digitally unique, no two NFTs are the
same.

```
A copy of a file, like an .mp3 or .jpg, is the same
as the original.
```
Every NFT must have an owner, and this is of
public record and easy for anyone to verify.

Ownership records of digital items are stored on
servers controlled by institutions –you must take
their word for it.
NFTs are compatible with anything built using
Ethereum. An NFT ticket for an event can be
traded on every Ethereum marketplace, for an
entirely different NFT. You could trade a piece of
art for a ticket!

```
Companies with digital items must build their
own infrastructure. For example, an app that
issues digital tickets for events would have to
build their own ticket exchange.
```
Content creators can sell their work anywhere and
can access a global market.

Creators rely on the infrastructure and distribution
of the platforms they use. These are often subject
to terms of use and geographical restrictions.
Creators can retain ownership rights over their
own work and claim resale royalties directly.

Platforms, such as music streaming services,
retain most profits from sales.
Items can be used in surprising ways. For example,
you can use digital artwork as collateral in a
decentralized loan.


### How do NFTs work?

- NFTs are different from ERC-20 tokens, such as DAI or LINK, in that each
    individual token is completely unique and is not divisible.
- An NFT is minted from digital objects as a representation of digital or
    non-digital assets.
- Ownership of NFTs is managed through the unique ID and metadata
    that no other token can replicate.
- NFTs are minted through smart contracts that assign ownership and
    manage the transferability of the NFT’s.
- When someone creates or mints an NFT, they execute code stored in
    smart contracts that conform to different standards, such as ERC-721.


- This information is added to the blockchain where the NFT is being
    managed.
- The minting process, from a high level, has the following steps that
    it goes through:
       - Creating a new block
       - Validating information
       - Recording information into the blockchain
- **Scarcity:** The creator of an NFT gets to decide the scarcity of their
    asset.
- **Royalties:** Some NFTs will automatically pay out royalties to their
    creators when they're sold.

### How do NFTs work? (continued)


### What are NFTs used for?

Here's more information of some of the better developed use-

cases and visions for NFTs on Ethereum.

- Digital content
- Gaming items
- Domain names
- Physical items
- Investments and collateral
- Tokengating


### Boosting Gaming Potential

- NFTs have seen a lot of interest from game developers.
- NFTs can provide records of ownership for in-game items, fuel in-
    game economies, and bring a host of benefits to the players.
- But if the item you buy in a game was an NFT, you could recoup
    your money by selling it on when you're done with the game.
- For game developers – as issuers of the NFT – they could earn a
    royalty every time an item is re-sold in the open marketplace.
- This creates a more mutually-beneficial business model where both
    players and developers earn from the secondary NFT market.
- This also means that if a game is no longer maintained by the
    developers, the items you've collected remain yours.


### Making Ethereum Addresses more memorable

- The Ethereum Name Service uses NFTs to provide your Ethereum
    address with an easier-to-remember name like mywallet.eth_._
- This works in a similar way to a website domain name which makes
    an IP address more memorable.
- And like domains, ENS names have value, usually based on length
    and relevance.
- With ENS you don't need a domain registry to facilitate the transfer
    of ownership.
- Instead, you can trade your ENS names on an NFT marketplace.


- Your ENS name can:
    - Receive cryptocurrency and other NFTs.
    - Point to a decentralized website, like ethereum.eth
    - Store any arbitrary information, including profile information like
       email addresses and Twitter handles.

### Making Ethereum Addresses more memorable


### Physical Items

- As NFTs are essentially deeds, one day you could buy a car or home
    using ETH and receive the deed as an NFT in return (in the same
    transaction).
- As things become increasingly high-tech, it's not hard to imagine a world
    where your Ethereum wallet becomes the key to your car or home – your
    door being unlocked by the cryptographic proof of ownership.
- With valuable assets like cars and property representable on Ethereum,
    you can use NFTs as collateral in decentralized loans.
- This is particularly helpful if you're not cash or crypto-rich but own
    physical items of value.


### NFTs and DeFi

- **NFT-backed loans:** There are DeFi applications that let you
    borrow money by using collateral.
       - For e.g., you collateralize 10 ETH so you can borrow 5000 DAI (a
          stablecoin).
       - This guarantees that the lender gets paid back – if the borrower
          doesn't pay back the DAI, the collateral is sent to the lender.
       - However not everyone has enough crypto to use as collateral.
- **Fractional ownership:** NFT creators can also create "shares" for
    their NFT.
       - This gives investors and fans the opportunity to own a part of an
          NFT without having to buy the whole thing.


- This adds even more opportunities for NFT minters and
    collectors alike.
- Fractionalized NFTs can be traded on DEXslike Uniswap, not
    just NFT marketplaces. That means more buyers and sellers.
- **Certificates of authenticity:** Companies offering fake certificates
for university degrees are reportedly a billion-dollar industry that
NFTs can help combat.
- NFTs can be a secure and quick way to verify someone's degree
credentials.

### NFTs and DeFi (continued)


### Tokengating

- Tokengating is a way of restricting access to something and using
    NFTs to unlock access.
- These things can vary hugely based on the platform, but popular
    examples are gated content, private chat servers, and, in the
    world of ecommerce, exclusive products.
- Since NFTs are on Ethereum, they can be used to unlock
    Ethereum tokengates on any platform that implements them.
- If minting and distributing NFTs is about community-generation
    or community digitization, tokengating is about community
    nurturing.
- It sees NFTs used more as a tool for membership or loyalty – and
    a great way to reliably deliver the rewards that come with it.


### Ethereum and NFTs

Ethereum makes it possible for NFTs to work for several reasons:

- Transaction history and token metadata is publicly verifiable – it's
    simple to prove ownership history.
- Once a transaction is confirmed, it's nearly impossible to
    manipulate that data to "steal" ownership.
- Trading NFTs can happen peer-to-peer without needing platforms
    that can take large cuts as compensation.
- All Ethereum products share the same "backend” – this makes NFTs
    portable across products. You can buy an NFT on one product and
    sell it on another easily.
- Ethereum never goes down, meaning your tokens will always be
    available to sell.


### Minting NFTs

When you mint an NFT, a few things must happen:

- It needs to be confirmed as an asset on the blockchain.
- The owner's account balance must be updated to include that
    asset. This makes it possible for it to then be traded or verifiably
    "owned".
- The transactions that confirm the above need to be added to a
    block and "immortalized" on the chain.
- The block needs to be confirmed by everyone in the network as
    "correct". This consensus removes the need for intermediaries
    because the network agrees that your NFT exists and belongs to
    you. And it's on chain so anyone can check it. This is one of the
    ways Ethereum helps NFT creators to maximize their earnings.


### NFT Security

- Ethereum's security comes from proof-of-stake.
- The system is designed to economically disincentivize malicious actions,
    making Ethereum tamper-proof. This is what makes NFTs possible.
- Once the block containing your NFT transaction becomes finalized it
    would cost an attacker millions of ETH to change it.
- Anyone running Ethereum software would immediately be able to
    detect dishonest tampering with an NFT, and the bad actor would be
    economically penalized and ejected.
- Security issues relating to NFTs are most often related to phishing scams,
    smart contract vulnerabilities or user errors (such as inadvertently
    exposing private keys), making good wallet security critical for NFT
    owners.


### Build with NFTs

- Most NFTs are built using a consistent standard known as ERC-721.
- The ERC-1155 standard allows for semi-fungible tokens which is
    particularly useful in the realm of gaming.
- And more recently, EIP-2309 has been proposed to make minting
    NFTs a lot more efficient. This standard lets you mint as many as
    you like in one transaction.


### Summary

- What’s an NFT?
- Internet of Assets (IOA)
- How do NFTs work?
- What are NFTs used for?
- NFTs and DeFi
- Ethereum and NFTs


### References

- https://ethereum.org/en/nft/
- https://ethereum.org/en/nft/#how-nfts-work



`


`

## Module 13:

## Decentralized Finance

## (DeFi)

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- What is DeFi?
- DeFi vs Traditional Finance
- What can you do with

DeFi?

- How does DeFi work?
- Ethereum and DeFi
- Build DeFi


### What is Decentralized Finance (DeFi)?

- A global, open alternative to the current financial system.
- Products that let you borrow, save, invest, trade, and more.
- Based on open-source technology that anyone can program with.
- DeFi is a collective term for financial products and services that are
    accessible to anyone who can use Ethereum – anyone with an internet
    connection.
- With DeFi, the markets are always open and there are no centralized
    authorities who can block payments or deny you access to anything.
- Services that were previously slow and at risk of human error are
    automatic and safer now that they're handled by code that anyone can
    inspect and scrutinize.


### DeFi vs Traditional Finance

One of the best ways to see the potential of DeFi is to understand
the problems that exist today.

- Some people aren't granted access to set up a bank account or use
    financial services.
- Lack of access to financial services can prevent people from being
    employable.
- Financial services can block you from getting paid.


- A hidden charge of financial services is your personal data.
- Governments and centralized institutions can close markets at will.
- Trading hours often limited to business hours of specific time zone.
- Money transfers can take days due to internal human processes.
- There's a premium to financial services because intermediary
    institutions need their cut.

### DeFi vs Traditional Finance (continued)


### Comparison of DeFi vs Traditional Finance

```
Decentralized Finance Traditional Finance
```
You hold your money. Your money is held by companies.

You control where your money goes and
how it's spent.

```
You must trust companies not to
mismanage your money, like lend to risky
borrowers.
```
Transfers of funds happen in minutes. Payments can take days due to manual processes.

Transaction activity is pseudonymous. Financial activity is tightly coupled with your identity.

DeFi is open to anyone. You must apply to use financial services.

The markets are always open. Markets close because employees need breaks.

It's built on transparency –anyone can look
at a product's data and inspect how the
system works.

```
Financial institutions are closed books: you
can't ask to see their loan history, a record
of their managed assets, and so on.
```

### Started with Bitcoin...

- Bitcoin in many ways was the first DeFi application.
- It does this by providing a way for many people, who don't trust each
    other, to agree on a ledger of accounts without the need for a trusted
    intermediary.
- Bitcoin is open to anyone, and no one has the authority to change its
    rules.
- Bitcoin's rules, like its scarcity and its openness, are written into the
    technology.
- It's not like traditional finance where governments can print money
    which devalues your savings and companies can shut down markets.
- Ethereum builds on this. Like Bitcoin, the rules can't change on you, and
    everyone has access.
- But it also makes this digital money programmable, using smart
    contracts, so you can go beyond storing and sending value.


### What can you do with DeFi?

- Send money around the globe
- Stream money around the globe
- Access stable currencies
- Borrow funds with collateral
- Borrow without collateral
- Start crypto savings
- Trade tokens
- Grow your portfolio
- Fund your ideas
- Buy insurance
- Manage your portfolio


### How does DeFi work?

- DeFi uses cryptocurrencies and smart contracts to provide services
    that don't need intermediaries.
- In today's financial world, financial institutions act as guarantors of
    transactions. This gives these institutions immense power because
    your money flows through them.
- In DeFi, a smart contract replaces the financial institution in the
    transaction.
- A smart contract is a type of Ethereum account that can hold funds
    and can send / refund them based on certain conditions.
- No one can alter that smart contract when it's live – it will always run
    as programmed.


- A contract that's designed to hand out an allowance or pocket
    money could be programmed to send money from Account A to
    Account B every Friday.
- It will do that as long as Account A has the required funds.
- No one can change the contract and add Account C as a recipient
    to steal funds.
- Contracts are also public for anyone to inspect and audit. This
    means bad contracts will often come under community scrutiny
    quickly.

### How does DeFi work? (continued)


- This does mean there's currently a need to trust the more technical
    members of the Ethereum community who can read code.
- The open-source based community helps keep developers in
    check, but this need will diminish over time as smart contracts
    become easier to read and other ways to prove trustworthiness of
    code are developed.

### How does DeFi work? (continued)


### Ethereum and DeFi

Ethereum is the perfect foundation for DeFi for several reasons:

- No one owns Ethereum or the smart contracts that live on it – this
    gives everyone an opportunity to use DeFi. This also means no one
    can change the rules on you.
- DeFi products all speak the same language behind the scenes:
    Ethereum.
       - This means many of the products work together seamlessly.
       - You can lend tokens on one platform and exchange the interest-
          bearing token in a different market on an entirely different
          application.
       - This is like being able to cash loyalty points in at your bank.


- Tokens and cryptocurrency are built into Ethereum, a shared

```
ledger – keeping track of transactions and ownership is kinda
Ethereum's thing.
```
- Ethereum allows complete financial freedom – most products

will never take custody of your funds, leaving you in control.

### Ethereum and DeFi (continued)


You can think of DeFi in layers:

1. The blockchain – Ethereum contains the transaction history and
    state of accounts.
2. The assets – ETH and the other tokens (currencies).
3. The protocols – smart contracts that provide the functionality, for
    example a service that allows for decentralized lending of assets.
4. The applications – the products we use to manage and access the
    protocols.

### Ethereum and DeFi (continued)


### Build DeFi

- DeFi is an open-source movement.
- The DeFi protocols and applications are all open for you to inspect,
    fork, and innovate on.
- Because of this layered stack (they all share the same base
    blockchain and assets), protocols can be mixed and matched to
    unlock unique combo opportunities.


### Summary

- What is DeFi?
- DeFi vs Traditional Finance
- What can you do with

DeFi?

- How does DeFi work?
- Ethereum and DeFi
- Build DeFi


### References

- https://ethereum.org/en/defi/



`


`

## Module 13:

## Decentralized Autonomous

## Organization (DAO)

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- What are DAOs?
- Why do we need DAOs?
- Comparison of DAO vs
    Traditional Organization
- DAO Examples
- How do DAOs work?
- Ethereum and DAO
- DAO
    - Governance
    - Laws
    - Membership


##### Decentralized Autonomous Organization (DAO)

- Member-owned communities

without centralized leadership.

- A safe way to collaborate with

internet strangers.

- A safe place to commit funds to a

specific cause.


### What are DAOs?

- A DAO is a collectively-owned, blockchain-governed organization
    working towards a shared mission.
- DAOs allow us to work with like-minded folks around the globe
    without trusting a benevolent leader to manage the funds or
    operations.
- Blockchain-based rules baked into the code define how the
    organization works and how funds are spent.
- They have built-in treasuries that no one has the authority to access
    without the approval of the group.
- Decisions are governed by proposals and voting to ensure
    everyone in the organization has a voice, and everything happens
    transparently on-chain.


### Why do we need DAOs?

- Starting an organization with someone that involves funding and
    money requires a lot of trust in the people you're working with.
- But it’s hard to trust someone you’ve only ever interacted with on
    the internet.
- With DAOs you don’t need to trust anyone else in the group, just
    the DAO’s code, which is 100% transparent and verifiable by
    anyone.
- This opens up so many new opportunities for global collaboration
    and coordination.



### DAO vs Traditional Organization

```
Decentralized Autonomous
Organization Traditional Organization
```
Usually flat, and fully democratized. Usually, hierarchical.

Voting required by members for any
changes to be implemented.

```
Depending on structure, changes can
be demanded from a sole party, or
voting may be offered.
```
Votes tallied, and outcome
implemented automatically without
trusted intermediary.

```
If voting allowed, votes are tallied
internally, and outcome of voting must
be handled manually.
```
Services offered are handled
automatically in a decentralized manner
(for example distribution of
philanthropic funds).

```
Requires human handling, or centrally
controlled automation, prone to
manipulation.
```
All activity is transparent and fully
public.

```
Activity is typically private and limited
to the public.
```

### DAO Examples

- A charity – you could accept donations from anyone in the world
    and vote on which causes to fund.
- Collective ownership – you could purchase physical or digital
    assets and members can vote on how to use them.
- Ventures and grants – you could create a venture fund that pools
    investment capital and votes on ventures to back. Repaid money
    could later be redistributed amongst DAO-members.


### How do DAOs work?

- The backbone of a DAO is its smart contract, which defines the
    rules of the organization and holds the group's treasury.
- Once the contract is live on Ethereum, no one can change the rules
    except by a vote.
- If anyone tries to do something that's not covered by the rules and
    logic in the code, it will fail.
- And because the treasury is defined by the smart contract too that
    means no one can spend the money without the group's approval
    either.
- This means that DAOs don't need a central authority. Instead, the
    group makes decisions collectively, and payments are
    automatically authorized when votes pass.
- This is possible because smart contracts are tamper-proof once
    they go live on Ethereum. You can't just edit the code (the DAOs
    rules) without people noticing because everything is public.


### Ethereum and DAOs

Ethereum is the perfect foundation for DAOs for a number of
reasons:

- Ethereum’s own consensus is distributed and established enough
    for organizations to trust the network.
- Smart contract code can’t be modified once live, even by its
    owners. This allows the DAO to run by the rules it was
    programmed with.
- Smart contracts can send / receive funds. Without this you'd need
    a trusted intermediary to manage group funds.
- The Ethereum community has proven to be more collaborative
    than competitive, allowing for best practices and support systems
    to emerge quickly.


### DAO Governance

There are many considerations when governing a DAO, such as how
voting and proposals work.

- **Delegation** is like the DAO version of representative democracy.
    Token holders delegate votes to users who nominate themselves
    and commit to stewarding the protocol and staying informed.
- **Automatic transaction governance:** In many DAOs, transactions
    will be automatically executed if a quorum of members votes
    affirmative.
- **Multisig governance:** While DAOs may have thousands of voting
    members, funds can live in a wallet shared by 5-20 active
    community members who are trusted and usually doxxed (public
    identities known to the community). After a vote, the multisig
    signers execute the will of the community.


### DAO Laws

- In 1977, Wyoming invented the LLC, which protects entrepreneurs
    and limits their liability.
- More recently, they pioneered the DAO law that establishes legal
    status for DAOs.
- Currently Wyoming, Vermont, and the Virgin Islands have DAO
    laws in some form.
- **A famous example:** CityDAO used Wyoming's DAO law to buy 40
    acres of land near Yellowstone National Park.


### DAO Membership

- There are different models for DAO membership. Membership can
    determine how voting works and other key parts of the DAO.
- **Token-based membership:** Usually fully permissionless,
    depending on the token used.
       - Mostly these governance tokens can be traded permissionlessly
          on a decentralized exchange.
       - Others must be earned through providing liquidity or some
          other ‘proof-of-work’.
       - Either way, simply holding the token grants access to voting.
       - Typically used to govern broad decentralized protocols and / or
          tokens themselves.


- **Share-based membership:** Share-based DAOs are more
    permissioned, but still quite open.
       - Any prospective members can submit a proposal to join the
          DAO, usually offering a tribute of some value in the form of
          tokens or work.
       - Shares represent direct voting power and ownership.
       - Members can exit at any time with their proportionate share of
          the treasury.
       - Typically used for more closer-knit, human-centric organizations
          like charities, worker collectives, and investment clubs. Can also
          govern protocols and tokens as well.

### DAO Membership (continued)


- **Reputation-based membership:** Reputation represents proof of
    participation and grants voting power in the DAO.
       - Unlike token or share-based membership, reputation-based
          DAOs don't transfer ownership to contributors.
       - Reputation cannot be bought, transferred or delegated; DAO
          members must earn reputation through participation.
       - On-chain voting is permissionless and prospective members
          can freely submit proposals to join the DAO and request to
          receive reputation and tokens as a reward in exchange for their
          contributions.
       - Typically used for decentralized development and governance
          of protocols and dApps, but also well suited to a diverse set of
          organizations like charities, worker collectives, investment clubs,
          etc.

### DAO Membership (continued)


### Summary

- What are DAOs?
- Why do we need DAOs?
- Comparison of DAO vs
    Traditional Organization
- DAO Examples
- How do DAOs work?
- Ethereum and DAO
- DAO
    - Governance
    - Laws
    - Membership


### References

- https://ethereum.org/en/dao/
- https://www.coindesk.com/learn/what-is-a-decentralized-

application/



`


`

## Module 13:

## Decentralized Others

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

I. Decentralized Social

Networks

II. Decentralized Identity

III. Decentralized Science

(DeSci)


### 1. Decentralized Social Networks

- Decentralized social networks are blockchain-based platforms that allow
    users to exchange information as well as publish and distribute content
    to audiences.
- Because these applications run on the blockchain, they are capable of
    being decentralized and resistant to censorship and undue control.
- Many decentralized social networks exist as alternatives to established
    social media services, such as Facebook, LinkedIn, Twitter, and Medium.
- But blockchain-powered social networks have several features that put
    them ahead of traditional social platforms.
- Tokens and NFTs create new ways to monetize content.


### How do Decentralized Social Networks work?

- Decentralized social networks are a class of decentralized
    applications (dApps) — applications powered by smart
    contracts deployed on the blockchain.
- The contract code serves as the backend for these apps and
    defines their business logic.
- Traditional social media platforms rely on databases to store user
    information, program code, and other forms of data.
- Decentralized social networks exist on a peer-to-peer network
    comprising thousands of nodes around the globe.
- Even if some nodes fail, the network will run uninterrupted, making
    applications resistant to failures and outages.


- Using decentralized storage systems like the Inter Planetary File
    System (IPFS), social networks built on Ethereum can protect user
    information from exploitation and malicious use.
- No one will sell your personal information to advertisers, neither
    will hackers be able to steal your confidential details.
- Many blockchain-based social platforms have native tokens that
    power monetization in absence of advertising revenue.
- Users can buy these tokens to access certain features, complete in-
    app purchases, or tip their favorite content creators.

### How do Decentralized Social Networks work?


### Decentralized Social Networks on Ethereum

- The Ethereum network has become the preferred tool for
    developers creating decentralized social media owing to the
    popularity of its tokens (ERC-20 / ERC-721) and its massive user
    base.
- **Peepeth** is a microblogging platform similar to Twitter. It runs on
    the Ethereum blockchain and uses IPFS to store user data.
       - Users can send short messages called "Peeps", which cannot be
          deleted or modified.
       - You can collect tips or tip anyone on the platform in ether (ETH)
          without leaving the app.
- **Mirror** is a web3-enabled writing platform that aims to be
    decentralized and user-owned.


- Users can read and write for free by simply connecting their wallets.
- Users can also collect writing and subscribe to their favorite writers.
- Posts published on Mirror are permanently stored on Arweave, a
    decentralized storage platform, and can be minted as
    collectable NFTs known as Writing NFTs.
- Writing NFTs are completely free for writers to create, and collection
    happens on an Ethereum L2 — making transactions inexpensive, fast,
    and environmentally friendly.
- **MINDS** is one of the most used decentralized social networks.
- Users use the platform's native ERC-20 token $MIND to pay for items.
- Users can also earn $MIND tokens by publishing popular content,
contributing to the ecosystem, and referring others to the platform.

### Decentralized Social Networks on Ethereum


### Use Decentralized Social Networks

- **Status.im** - Status is a secure messaging app that uses an open-source,
    peer-to-peer protocol, and end-to-end encryption to protect your
    messages from third parties.
- **Mirror.xyz** - Mirror is a decentralized, user-owned publishing platform
    built on Ethereum for users to crowdfund ideas, monetize content, and
    build high-value communities.
- **Lens Protocol** - Lens Protocol is a composable and decentralized social
    graph helping creators take ownership of their content wherever they go
    in the digital garden of the decentralized internet.
- **Farcaster** - Farcaster is a sufficiently decentralized social network. It is an
    open protocol that can support many clients, just like email.


### 2. Decentralized Identity

- Traditional identity systems have centralized the issuance,
    maintenance and control of your identifiers.
- Decentralized identity removes reliance on centralized third
    parties.
- Thanks to crypto, users now have the tools to issue, hold and
    control their own identifiers and attestations once again.


### What are Decentralized Identifiers?

- Traditional identifiers like your legal name or email address rely on
    third parties—governments and email providers.
- Decentralized identifiers (DIDs) are different—they aren't issued,
    managed, or controlled by any central entity.
- Decentralized identifiers are issued, held, and controlled by
    individuals.
- An Ethereum account is an example of a decentralized identifier.
- You can create as many accounts as you want without permission
    from anyone and without the need to store them in a central
    registry.


- Decentralized identifiers are stored on distributed ledgers
    (blockchains) or peer-to-peer networks.
- This makes DIDs globally unique, resolvable with high availability,
    and cryptographically verifiable.
- A decentralized identifier can be associated with different entities,
    including people, organizations, or government institutions.

###### What are Decentralized Identifiers? (continued)


### 3. Decentralized Science (DeSci)

- A global, open alternative to the current scientific system.
- Technology that enables scientists to raise funding, run
    experiments, share data, distribute insights, and more.
- Builds on the open science movement.
- A decentralized science system will require robust security, minimal
    monetary and transaction costs, and a rich ecosystem for
    application development.
- Ethereum provides everything needed for building a decentralized
    science stack.


### How DeSci improves Science?

```
Decentralized Science Traditional Science
```
Distribution of funds is determined by the
public using mechanisms such as quadratic
donations or DAOs.

```
Small, closed, centralized groups control
the distribution of funds.
```
You collaborate with peers from all over the
globe in dynamic teams.

```
Funding organizations and home
institutions limit your collaborations.
```
Funding decisions are made online and
transparently. New funding mechanisms
are explored.

```
Funding decisions are made with a long
turnaround time and limited transparency.
Few funding mechanisms exist.
```
Sharing laboratory services is made easier
and more transparent using Web3
primitives.

```
Sharing laboratory resources is often slow
and opaque.
```
New models for publishing can be
developed that use Web3 primitives for
trust, transparency and universal access.

```
You publish through established pathways
frequently acknowledged as inefficient,
biased and exploitative.
```

```
Decentralized Science Traditional Science
```
You can earn tokens and reputation for
peer-reviewing work.

```
Your peer-review work is unpaid,
benefiting for-profit publishers.
```
You own the intellectual property (IP)
you generate and distribute it
according to transparent terms.

```
Your home institution owns the IP you
generate. Access to the IP is not
transparent.
```
Sharing all the research, including the
data from unsuccessful efforts, by
having all steps on-chain.

```
Publication bias means that researchers
are more likely to share experiments
that had successful results.
```
### How DeSci improves Science? (continued)


### Summary

I. Decentralized Social

Networks

II. Decentralized Identity

III. Decentralized Science

(DeSci)


### References

- https://ethereum.org/en/social-networks/
- https://ethereum.org/en/decentralized-identity/
- https://ethereum.org/en/desci/



`


`

## Module 14:

## Attacks on Digital Assets

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

Attacks on Digital Assets:

- Consensus Mechanism,
    Mining and Ledger
- Peer-to-Peer Network
- Smart Contract
- Wallet
- Transaction Verification
    Mechanism
- Mining Pool

Other Attacks:

- Various Double Spending
- Game Theory & Network


### Consensus Mechanism, Mining and Ledger-

### based Attacks

- Selfish mining attack
- Mining malware
- 51% attack
- Timejack attack
- Finney attack
- Race attack


### Peer-to-Peer Network-based Attacks

- Sybil attack
- Eclipse attack
- Distributed Denial-of-Service (DDoS)
- Routing attack
- Transaction malleability attack
- Timejacking attack
- Routing attack
- Long range attacks on POS networks
    - Simple
    - Posterior corruption
    - Stake bleeding


### Smart Contract-based Attacks

- Decentralized Autonomous Organization (DAO) attack
- Vulnerabilities in Smart Contract source codes
- Vulnerabilities in Virtual Machines
    - Immutable defects
    - Cryptocurrency lost in transfer
    - Bugs in access control
    - Short address attack


### Wallet-based Attacks

- Parity multisig Wallet attack
- Proof of Concept (POC) attack
    - Bitcoin deanonymization attack
    - Bitcoin reflection & amplification spamming attack
    - Mobile Bitcoin wallet fraud attack
- Phishing attack
- Dictionary attack
- Vulnerable signatures
- Flawed key generation
- Attacks on Cold Wallets
- Attacks on Hot Wallets


- Copy & Paste aka “Clipboard Hijackers”
- 2 Factor Authentication by SMS or TEXT
    - Hacked Coinbase Wallet
- Fake Mobile Apps

### Wallet-based Attacks (continued)


### Transaction Verification Mechanism Attacks

- Double Spending attack
- Finney attack
- Race attack
- Vector76 attack
    - Combination of two previous attacks
- Alternative history attack
- 51% or majority attack


### Mining Pool Attacks

- Selfish mining attack
- Fork after withholding attack (FAW)


### Various Double Spending Attacks

Double-spend attacks happen for multiple reasons:

```
Double-Spend Attack Reasons
Normal Buyer sending to multiple Sellers using the
same set of coins.
Zero Confirmation transaction Seller without waiting for confirmation, accepts
the transaction and sell the item or provide the
service.
Replace-By-Fee (RBF) The new transaction with improved fee will
overwrite the earlier transfer.
Forking attack Theobviouswaytoprofittoperformadouble-
spend to one of miner's own addresses.
51% attack Attacker does variety of double-spend attacks
to destroy the currency and people will lose
trust and confidence in the currency.
```

### Game Theory and Network Attacks

- Forking attack via Bribery
- Sybil attack
- Denial of service (DOS) attack
- 51 - percent attack
- Passphrase generation
- Key stretching
- Goldfinger attack
- Temporary Block-with holding
    attack
- Blacklisting and punitive
    forking attack
- Feather forking attack
- Anonymity attacks
    - Transaction Graph Analysis
    - Bad Mixes / Peers
    - Side-channel attack
    - Block discarding attack
    - Vigilante / Sabotage attack
    - Stake-grinding attack
    - Attack on Proof-of-Clairvoyance
    - Bitcoin Beacon
    - Altcoin infanticide attack
    - Replay attack


### Summary

Attacks on Digital Assets:

- Consensus Mechanism,
    Mining and Ledger
- Peer-to-Peer Network
- Smart Contract
- Wallet
- Transaction Verification
    Mechanism
- Mining Pool

Other Attacks:

- Various Double Spending
- Game Theory & Network


### References

- Bitcoin and Cryptocurrency Technologies by Arvind Narayanan,

```
Joseph Bonneau, Edward Felten, Andrew Miller and Steven
Goldfeder
```


`


`

## Module 14:

## Funding Crypto

## Development

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Initial Coin Offering (ICO)
- Security Token Offering

(STO)

- Types of Security Tokens
- How is STO different from

ICO?

- ICO vs STO
    - Advantages,
    - Disadvantages &
    - Comparison


### Initial Coin Offering (ICO)

- An initial coin offering (ICO) is a type
    of capital-raising activity in
    the cryptocurrency and blockchain
    environment.
- The ICO can be viewed as an initial
    public offering (IPO) that uses
    cryptocurrencies.
- However, it is not the most precise
    comparison, as there are some
    crucial differences between the two
    fundraising activities.
- Startups primarily use an ICO is to
    raise capital


- ICOs themselves are a method of fundraising where a company
    who is looking to establish a new product or service will look for
    outside investment to help fund their venture.
- The company running the ICO will do this through various forms of
    marketing.
- In exchange for their investment, the investor will receive a certain
    number of cryptocurrency tokens that are unique to the ICO.
- Investors can either use traditional, fiat currency or other tokens.

### ICO (Continued)


- A few ICOs have yielded returns for investors. Numerous others
    have turned out to be fraudulent or have performed poorly.
- To participate in an ICO, you usually need to first purchase a more
    established digital currency, plus have a basic understanding of
    cryptocurrency wallets and exchanges.
- ICOs are, for the most part, completely unregulated, so investors
    must exercise a high degree of caution and diligence when
    researching and investing in them.

### ICO (Continued)


### Security Token Offering (STO)

- An STO, also known as a Security Token Offering, is a digital token
    supported by blockchain technology that represents a stake in an
    asset.
- STOs enable digital funding, while still complying with government
    regulations.
- Security tokens require extensive regulations, so they are not
    traded on regular token exchanges.
- However, they are like ICOs in that they are fungible tokens,
    meaning that they hold monetary value.


### Types of Security Tokens

- **Equity Tokens:** Equity token holders are entitled to a company’s
    profit and even have the right to vote like a shareholder.
       - The main difference between a traditional stock and an equity
          token is how the ownership information is recorded.
       - Equity tokens will be recorded on the blockchain, while
          traditional stocks are printed on certificates and / or stored in a
          database.
- **Asset-Backed Tokens:** Asset-Backed Tokens represent real-world
    assets, like real estate or art.
       - These tokens use the blockchain to securely save a record of
          these assets.


- These tokens not only provide a secure transaction record but
    can also retain value which means that the token can itself act as
    a digital asset.
- **Debt Tokens:** Debt tokens work like short-term loans that
investors give to a company.
- The contract created for this loan will exist on the blockchain
network and act as a security for the debt.
- The price of the debt token will be largely dependent on the
dividend model and the risk involved in the loan.

### Types of Security Tokens (continued)


### How is STO different from ICO?


### ICO vs STO — Advantages

The most mentioned advantages of an ICO include:

- No entry barrier for both buyers and sellers.
- Positive network effects.
- The tokens are distributed in a simple automated way.
- The teams can manage their funds however they prefer.
- A successful ICO often requires just a well-executed digital
    campaign.
- If a coin raises in price and team delivers, investors enjoy high
    profitability and early adopter benefits.
- Some ICOs allow for anonymous participation.


At the same time, an STO offers the following advantages:

- Investors acquire underlying assets that derive their value from
    something else.
- 100% regulated offerings that ensure investors security.
- Projects that go for STOs are generally more mature and trustworthy
    than the ones in the ICO sphere.
- STOs are experiencing significant growth while ICOs space shrinks.
- It is an ongoing trend.
- Security tokens are expected to be traded via broker-dealers who are
    also supervised by regulatory bodies.
- Security tokens are the next big step in traditional finance.
- Less speculation and market manipulation.

### ICO vs STO — Advantages (continued)


### ICO vs STO — Disadvantages

The most obvious disadvantages of an ICO are:

- High volatility and manipulation of the crypto market.
- Low liquidity.
- Uncertainty if the product will be finished and delivered as stated
    in the white paper.
- Scams and pump and dump schemes are common for ICOs.
- Regulations can cause problems for both projects and investors.
- Unregulated space with a lot of risks.


Meanwhile, the disadvantages of STOs are:

- Takes a lot of time, effort, and money to get a green light from the
    regulators.
- Can be limited to accredited investors only.
- Can require significant amounts of money.
- So far, the SEC has not approved a single Reg A+ STO, and only
    allows for institutional investor participation

### ICO vs STO — Disadvantages (continued)


### ICO vs STO Comparison


### Summary

- Initial Coin Offering (ICO)
- Security Token Offering

(STO)

- Type of Security Tokens
- How is STO different from

ICO?

- ICO vs STO
    - Advantages,
    - Disadvantages &
    - Comparison


### References

- https://cryptonews.com/guides/the-difference-between-ico-

and-sto.htm#how-is-sto-different-from-ico?

- https://hackernoon.com/ico-vs-sto-all-you-need-to-know-

```
about-the-new-fundraising-method-in-the-crypto-world-
54a1a43a08d6
```
- https://www.investopedia.com/terms/i/initial-coin-offering-

ico.asp

- https://www.tokenex.com/blog/ab-what-is-a-security-token-

offering-sto/



`


`

## Module 14:

## Scaling of Blockchains

```
Narayanan Subramanian
Amrita School of Engineering
Amrita Vishwa Vidyapeetham
```

### Objectives

- Scalability Trilemma
- Scaling of Blockchains
- Decrease Transaction Size:
    - Segregated Witness
       (SegWit)
    - Recursive Snarks
- Different Types of Scaling:
    - Vertical Scaling
    - Horizontal Scaling
    - Diagonal Scaling


### Scalability Trilemma

- The consensus
    classification conflated
    with Buterin’s
    ‘Scalability Trilemma’
    illustrating the choose-
    2 tradeoff.
- Only 2 out of 3 is
    possible, otherwise
    needs to be balanced
    by losing some to gain
    other.
- Scalability
- Security
- Decentralization


### Scaling of Blockchains

- For more scalability increase transactions per second:
    - Increase volume of transactions
       - Increase size of the transaction
       - Increase size of the block
    - Decrease Block Time
       - Decrease Block creation rate
    - Decrease Transaction Size:
       - SegWit
       - Recursive Snarks


- Vertical Scaling: (add more RAM / CPU power to each existing
    machine)
       - Increase Block size (Large Transaction attack is possible)
       - GHOST (POW – Proof of Work solution – Decreasing difficulty)
       - Vertical Scaling Off Chain:
          - Payment Channels
          - Lightning Network
- Horizontal Scaling: (add more machines of same computational
    power)
       - Sharding
       - Sidechains
       - Child chains

### Scaling of Blockchains (continued)


- Diagonal Scaling: (add more powerful machines)
    - Plasma
    - Plasma Cash
    - Cosmos
- Note: All three scaling types are used by Mining Pools related to
    Infrastructure.

### Scaling of Blockchains (continued)


- **SegWit:** (implemented using soft fork)
    - Segregated Witness (SegWit) is a soft work protocol that
       changes the method of storing data.
    - It was presented in December 2015 by Pieter Wiulle as a
       solution to Bitcoin’s scalability problems.
    - Implemented using two Merkle trees of transactions and
       witnesses (digital signatures) linked to Block Header.
    - The core concept of SegWit is a segregation of the digital
       signature from the transactions data.
    - As the digital signature is 65 percent of transaction, removing it
       from the data will increase Bitcoin’s blockchain maximum size
       from 1MB to a little under 4MB.

### Segregated Witness (SegWit)


- SegWit could also help with fixing a bug called “transaction
    malleability,” which is when anyone could change some small
    details and modify the transaction ID. This bug prevented the
    development of new features for Bitcoin.
- Segregated Witness was activated on August 24, 2017. Still, not
    everyone who accepts SegWit as Bitcoin can still work using the
    old protocol.
- Only around 30 percent of transactions are using a new format.
- Fixing transaction malleability, allows the Lightening Network
    and Sidechains to work.

### SegWit (continued)


- Miners can merely include a single proof that’s validated all the
    other proofs and changes to the state.
- BLOCK = root hash of the content of the ledger + proofs of valid
    transactions that moved the ledger into current state + proof that
    proof present in the previous block was itself valid
- Verify blockchain in under 1 second + include 2x transactions per
    block
- avg tx size = 546 bytes, avg proof size = 288 bytes
- Drawbacks: Proofs are too time consuming to generate, could take
    hours & requires trusted setup.

### Recursive Snarks


### Vertical Scaling

- Payment Channels:
    - A Micropayment Channel or Payment Channel is class of
       techniques designed to allow users to make multiple Bitcoin
       transactions without committing all the transactions to the
       Bitcoin block chain.
    - In a typical payment channel, only two transactions are added to
       the blockchain, but an unlimited or nearly unlimited number of
       payments can be made between the participants
    - Several channel designs have been proposed or implemented
       over the years.


- Many designs are vulnerable to transaction malleability.
    Specifically, many designs require a way to be able to spend an
    unsigned transaction, in order to ensure that the channel can be
    opened atomically.
- Thus, these designs require a malleability fix that separates the
    signatures from the part of the transaction that is hashed to form
    the txid (SegWit fix in Bitcoin).
- Famous Payment Channel is Hash Time Locked Contracts
    (HTLC). Only two transactions on the blockchain (opening &
    settlement / closing a channel) and supports arbitrary number
    of transactions between 2 parties.

### Vertical Scaling (continued)


- Lightning Network:
    - The Lightning Network is a secondary layer which operates on
       top of a blockchain. In theory, it can process an unlimited
       number of transactions — payments which are not publicly
       recorded in the blockchain.
    - Final balances are only added to the ledger when every
       transaction has been completed.
    - Although there has been hope that this will solve Bitcoin’s
       scaling issues, there are downsides — mainly concerning
       security.
    - It could be the case that such a protocol ends up being the
       standard for smaller, everyday payments — freeing up the
       blockchain for more substantial transactions and enabling fees
       to tumble.

### Vertical Scaling (continued)


### Horizontal Scaling

- Sharding:
    - Sharding is the idea of not requiring every validator to be
       working on every single block, essentially creating parallel but
       connected blockchains.
- Sidechains:
    - Bitcoin’s sharding.
    - Sidechain is a designation for a blockchain ledger that runs in
       parallel to a primary blockchain.
    - Entries from the primary blockchain can be linked to and from
       the sidechain; this allows the sidechain to otherwise operate
       independently of the primary blockchain (e.g., by using an
       alternate means of record keeping).


- Child Chains:
    - Developers of NXT, created a new platform called Ardor which
       introduces this new scalable solution named Child Chains, in
       which it is said that it could be a better alternative towards
       making a cryptocurrency scale, than Sidechains.
    - Header information is stored in Parent blockchain, and
       transactions stored in the Child chain.

### Horizontal Scaling (continued)


- Plasma:
    - Plasma is a hierarchical tree of side chains that periodically
       transfers information back to the main-chain.
    - Ethereum (ETH) has implemented the Plasma as a Scalable
       Autonomous Smart Contracts.
    - Plasma is a design pattern that allows for off-chain messages to
       dictate the transfer of on-chain assets.
    - It scales the root chain by offloading transaction throughput to
       Plasma chains.

### Diagonal Scaling


- Plasma Cash (PETH):
    - In Plasma Cash, users only need to download the histories of
       and watch the tokens they care about.
    - Sharded client-side validation allows for a lighter data load for
       each user.
    - However, if a coin is spent many many times, then the history of
       the coin becomes unfeasibly large to transact.
    - One proposal to remedy this is to introduce checkpoints.
    - Once a checkpoint has been finalized, clients can instead
       provide proofs from the finalized checkpoint onwards which
       would reduce the proofs to constant, rather than linear size.
    - Plasma Cash Checkpoints are based on crypto-economic
       aggregate signatures which provide an economic guarantee
       that a coin is owned by person X at height Y.

### Diagonal Scaling (continued)


- Cosmos:
    - Cosmos proposes a modular architecture with two classes of
       blockchain: Hubs and Zones.
    - Zones are regular heterogeneous blockchains and Hubs are
       blockchains specifically designed to connect Zones together.
    - When a Zone creates an IBC connection with a Hub, it can
       automatically access (i.e., send to and receive from) every other
       Zone that is connected to it.
    - As a result, each Zone only needs to establish a limited number
       of connections with a restricted set of Hubs.

### Diagonal Scaling (continued)


- Hubs also prevent double spending among Zones.
- This means that when a Zone receives a token from a Hub, it
    only needs to trust the origin Zone of this token and the Hub.
- The first Hub to launch in the Cosmos Network will be the
    Cosmos Hub.
- The Cosmos Hub is a public Proof-of-Stake blockchain whose
    native staking token is called the Atom, and where transactions
    fees will be payable in multiple tokens.
- The launch of the Hub will also mark the launch of the Cosmos
    network.

### Diagonal Scaling (continued)


### Summary

- Scalability Trilemma
- Scaling of Blockchains
- Decrease Transaction Size:
    - Segregated Witness
       (SegWit)
    - Recursive Snarks
- Different Types of Scaling:
    - Vertical Scaling
    - Horizontal Scaling
    - Diagonal Scaling


### References

- https://ieeexplore.ieee.org/abstract/document/9031204
- https://en.bitcoin.it/wiki/Payment_channels
- https://en.bitcoin.it/wiki/Hash_Time_Locked_Contracts
- https://lightning.network/lightning-network-summary.pdf
- https://lightning.network/lightning-network-paper.pdf
- https://www.jelurida.com/child-chains-and-side-chains
- https://plasma.io/
- https://cosmos.network/intro
- https://www.cryptonewsz.com/cosmos-the-internet-of-

blockchains-goes-live/11525/

- https://blog.daglabs.com/an-introduction-to-the-blockdag-

paradigm-50027f44facb


### References (continued)

- https://www.investinblockchain.com/solving-blockchain-

scalability-problem/

- https://hackernoon.com/state-of-cryptocurrencies-scaling-

173cebb600dd



